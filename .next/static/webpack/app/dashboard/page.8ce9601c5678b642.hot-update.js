"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/dashboard/page",{

/***/ "(app-pages-browser)/./hooks/use-crash-detection.ts":
/*!**************************************!*\
  !*** ./hooks/use-crash-detection.ts ***!
  \**************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useCrashDetection: () => (/* binding */ useCrashDetection)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\nfunction useCrashDetection(isEnabled, currentSpeed, position, onCrashDetected) {\n    const [crashDetected, setCrashDetected] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const lastAcceleration = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        x: 0,\n        y: 0,\n        z: 0\n    });\n    const lastRotation = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        alpha: 0,\n        beta: 0,\n        gamma: 0\n    });\n    const lastTime = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(Date.now());\n    const previousSpeed = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const baselineOrientation = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        alpha: 0,\n        beta: 0,\n        gamma: 0\n    });\n    const impactSamples = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    const audioContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const analyser = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const loudSoundDetected = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const speedHistory = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    const lastCrashTime = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const accelerationPattern = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    const normalDrivingBaseline = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        avgG: 1,\n        maxG: 2\n    });\n    const falsePositiveHistory = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    const userCancelCount = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useCrashDetection.useEffect\": ()=>{\n            previousSpeed.current = currentSpeed;\n            // Track speed history for sudden drop detection\n            speedHistory.current.push(currentSpeed);\n            if (speedHistory.current.length > 10) {\n                speedHistory.current.shift(); // Keep last 10 readings (2 seconds)\n            }\n        }\n    }[\"useCrashDetection.useEffect\"], [\n        currentSpeed\n    ]);\n    // Sound detection setup\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useCrashDetection.useEffect\": ()=>{\n            if (!isEnabled || \"object\" === \"undefined\") return;\n            const setupAudioDetection = {\n                \"useCrashDetection.useEffect.setupAudioDetection\": async ()=>{\n                    try {\n                        const stream = await navigator.mediaDevices.getUserMedia({\n                            audio: true\n                        });\n                        audioContext.current = new (window.AudioContext || window.webkitAudioContext)();\n                        const source = audioContext.current.createMediaStreamSource(stream);\n                        analyser.current = audioContext.current.createAnalyser();\n                        analyser.current.fftSize = 2048;\n                        source.connect(analyser.current);\n                        // Monitor for loud sounds (crash/airbag)\n                        const checkSound = {\n                            \"useCrashDetection.useEffect.setupAudioDetection.checkSound\": ()=>{\n                                if (!analyser.current) return;\n                                const dataArray = new Uint8Array(analyser.current.frequencyBinCount);\n                                analyser.current.getByteFrequencyData(dataArray);\n                                // Calculate average volume\n                                const average = dataArray.reduce({\n                                    \"useCrashDetection.useEffect.setupAudioDetection.checkSound\": (a, b)=>a + b\n                                }[\"useCrashDetection.useEffect.setupAudioDetection.checkSound\"]) / dataArray.length;\n                                // Detect loud sudden sound (>150 threshold = crash/airbag)\n                                if (average > 150) {\n                                    console.log(\"LOUD SOUND DETECTED:\", average);\n                                    loudSoundDetected.current = true;\n                                    setTimeout({\n                                        \"useCrashDetection.useEffect.setupAudioDetection.checkSound\": ()=>{\n                                            loudSoundDetected.current = false;\n                                        }\n                                    }[\"useCrashDetection.useEffect.setupAudioDetection.checkSound\"], 2000); // Reset after 2 seconds\n                                }\n                            }\n                        }[\"useCrashDetection.useEffect.setupAudioDetection.checkSound\"];\n                        setInterval(checkSound, 100); // Check every 100ms\n                    } catch (error) {\n                        console.log(\"Audio detection not available:\", error);\n                    }\n                }\n            }[\"useCrashDetection.useEffect.setupAudioDetection\"];\n            setupAudioDetection();\n            return ({\n                \"useCrashDetection.useEffect\": ()=>{\n                    if (audioContext.current) {\n                        audioContext.current.close();\n                    }\n                }\n            })[\"useCrashDetection.useEffect\"];\n        }\n    }[\"useCrashDetection.useEffect\"], [\n        isEnabled\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useCrashDetection.useEffect\": ()=>{\n            if (!isEnabled || \"object\" === \"undefined\") return;\n            let rotationRate = 0;\n            let hasGyroscope = false;\n            // Handle gyroscope data for rollover detection\n            const handleOrientation = {\n                \"useCrashDetection.useEffect.handleOrientation\": (event)=>{\n                    if (event.alpha === null || event.beta === null || event.gamma === null) return;\n                    hasGyroscope = true;\n                    const now = Date.now();\n                    const timeDiff = (now - lastTime.current) / 1000;\n                    if (timeDiff < 0.1) return;\n                    // Calculate rotation rate (degrees per second)\n                    const alphaChange = Math.abs(event.alpha - lastRotation.current.alpha);\n                    const betaChange = Math.abs(event.beta - lastRotation.current.beta);\n                    const gammaChange = Math.abs(event.gamma - lastRotation.current.gamma);\n                    // Handle 360-degree wraparound for alpha\n                    const normalizedAlphaChange = alphaChange > 180 ? 360 - alphaChange : alphaChange;\n                    rotationRate = Math.sqrt(normalizedAlphaChange ** 2 + betaChange ** 2 + gammaChange ** 2) / timeDiff;\n                    // Detect rollover: extreme rotation (>90 degrees/sec) while moving\n                    if (rotationRate > 90 && previousSpeed.current > 15) {\n                        console.log(\"ROLLOVER DETECTED!\", {\n                            rotationRate: rotationRate.toFixed(2),\n                            speed: previousSpeed.current\n                        });\n                        setCrashDetected(true);\n                        onCrashDetected({\n                            gForce: 0,\n                            timestamp: now,\n                            position,\n                            speed: previousSpeed.current,\n                            crashType: \"rollover\",\n                            rotationRate\n                        });\n                    }\n                    lastRotation.current = {\n                        alpha: event.alpha,\n                        beta: event.beta,\n                        gamma: event.gamma\n                    };\n                }\n            }[\"useCrashDetection.useEffect.handleOrientation\"];\n            const handleMotion = {\n                \"useCrashDetection.useEffect.handleMotion\": (event)=>{\n                    const acc = event.accelerationIncludingGravity;\n                    const rotation = event.rotationRate;\n                    if (!acc || acc.x === null || acc.y === null || acc.z === null) return;\n                    const now = Date.now();\n                    const timeDiff = (now - lastTime.current) / 1000 // seconds\n                    ;\n                    if (timeDiff < 0.1) return; // Ignore too frequent updates\n                    // Calculate jerk (rate of change of acceleration)\n                    const jerkX = Math.abs(acc.x - lastAcceleration.current.x) / timeDiff;\n                    const jerkY = Math.abs(acc.y - lastAcceleration.current.y) / timeDiff;\n                    const jerkZ = Math.abs(acc.z - lastAcceleration.current.z) / timeDiff;\n                    const totalJerk = Math.sqrt(jerkX ** 2 + jerkY ** 2 + jerkZ ** 2);\n                    // Total acceleration magnitude in G's\n                    const totalG = Math.sqrt(acc.x ** 2 + acc.y ** 2 + acc.z ** 2) / 9.8;\n                    // Get gyroscope rotation rate if available\n                    let gyroRotationRate = 0;\n                    if (rotation && rotation.alpha !== null && rotation.beta !== null && rotation.gamma !== null) {\n                        gyroRotationRate = Math.sqrt(rotation.alpha ** 2 + rotation.beta ** 2 + rotation.gamma ** 2);\n                    }\n                    // Calculate speed drop (sudden deceleration)\n                    const speedDrop = speedHistory.current.length >= 2 ? speedHistory.current[0] - speedHistory.current[speedHistory.current.length - 1] : 0;\n                    // Multi-sample verification: Store last 5 impact readings\n                    impactSamples.current.push(totalG);\n                    if (impactSamples.current.length > 5) {\n                        impactSamples.current.shift();\n                    }\n                    // Check if multiple samples show high G-force (reduces false positives)\n                    const highGSamples = impactSamples.current.filter({\n                        \"useCrashDetection.useEffect.handleMotion\": (g)=>g > 2.5\n                    }[\"useCrashDetection.useEffect.handleMotion\"]).length;\n                    const consistentImpact = highGSamples >= 3 // At least 3 out of 5 samples\n                    ;\n                    // Determine crash type based on acceleration direction\n                    let crashType = \"unknown\";\n                    const dominantAxis = Math.max(Math.abs(acc.x), Math.abs(acc.y), Math.abs(acc.z));\n                    if (Math.abs(acc.y) === dominantAxis) {\n                        crashType = acc.y > 0 ? \"frontal\" : \"rear\";\n                    } else if (Math.abs(acc.x) === dominantAxis) {\n                        crashType = \"side\";\n                    } else if (gyroRotationRate > 5 || rotationRate > 60) {\n                        crashType = \"rollover\";\n                    }\n                    // Calculate confidence score (0-100%)\n                    let confidence = 0;\n                    let confidenceFactors = 0;\n                    // Factor 1: G-force strength (max 30 points)\n                    if (totalG > 4) confidence += 30;\n                    else if (totalG > 3) confidence += 20;\n                    else if (totalG > 2.5) confidence += 10;\n                    confidenceFactors++;\n                    // Factor 2: Jerk magnitude (max 25 points)\n                    if (totalJerk > 40) confidence += 25;\n                    else if (totalJerk > 30) confidence += 15;\n                    else if (totalJerk > 20) confidence += 10;\n                    confidenceFactors++;\n                    // Factor 3: Speed check (max 15 points)\n                    if (previousSpeed.current > 30) confidence += 15;\n                    else if (previousSpeed.current > 20) confidence += 10;\n                    else if (previousSpeed.current > 15) confidence += 5;\n                    confidenceFactors++;\n                    // Factor 4: Sound detection (max 15 points)\n                    if (loudSoundDetected.current) confidence += 15;\n                    confidenceFactors++;\n                    // Factor 5: Speed drop (max 10 points)\n                    if (speedDrop > 20) confidence += 10;\n                    else if (speedDrop > 10) confidence += 5;\n                    confidenceFactors++;\n                    // Factor 6: Multi-sample consistency (max 5 points)\n                    if (consistentImpact) confidence += 5;\n                    confidenceFactors++;\n                    // Enhanced crash detection criteria with confidence scoring\n                    const isHighImpact = totalG > 4 && totalJerk > 40 && previousSpeed.current > 20;\n                    const isMediumImpact = totalG > 3 && totalJerk > 30 && previousSpeed.current > 15;\n                    const isRollover = (gyroRotationRate > 5 || rotationRate > 60) && previousSpeed.current > 15;\n                    const isConfidentCrash = confidence >= 60 && consistentImpact && previousSpeed.current > 15;\n                    // Prevent duplicate detections (cooldown period)\n                    const timeSinceLastCrash = now - lastCrashTime.current;\n                    const cooldownPeriod = 10000 // 10 seconds\n                    ;\n                    if (timeSinceLastCrash < cooldownPeriod) {\n                        // Skip detection during cooldown\n                        lastAcceleration.current = {\n                            x: acc.x,\n                            y: acc.y,\n                            z: acc.z\n                        };\n                        lastTime.current = now;\n                        return;\n                    }\n                    if (isHighImpact || isMediumImpact || isRollover || isConfidentCrash) {\n                        console.log(\"CRASH DETECTED!\", {\n                            totalG: totalG.toFixed(2),\n                            totalJerk: totalJerk.toFixed(2),\n                            speed: previousSpeed.current,\n                            speedDrop: speedDrop.toFixed(1),\n                            crashType,\n                            rotationRate: (gyroRotationRate || rotationRate).toFixed(2),\n                            soundDetected: loudSoundDetected.current,\n                            confidence: confidence.toFixed(0) + \"%\",\n                            consistentImpact\n                        });\n                        lastCrashTime.current = now;\n                        setCrashDetected(true);\n                        onCrashDetected({\n                            gForce: totalG,\n                            timestamp: now,\n                            position,\n                            speed: previousSpeed.current,\n                            crashType,\n                            rotationRate: gyroRotationRate || rotationRate,\n                            speedDrop,\n                            soundDetected: loudSoundDetected.current,\n                            confidence\n                        });\n                    }\n                    lastAcceleration.current = {\n                        x: acc.x,\n                        y: acc.y,\n                        z: acc.z\n                    };\n                    lastTime.current = now;\n                }\n            }[\"useCrashDetection.useEffect.handleMotion\"];\n            // Request permission for motion sensors (iOS 13+)\n            if (typeof DeviceMotionEvent !== \"undefined\" && typeof DeviceMotionEvent.requestPermission === \"function\") {\n                ;\n                DeviceMotionEvent.requestPermission().then({\n                    \"useCrashDetection.useEffect\": (response)=>{\n                        if (response === \"granted\") {\n                            window.addEventListener(\"devicemotion\", handleMotion);\n                            window.addEventListener(\"deviceorientation\", handleOrientation);\n                        }\n                    }\n                }[\"useCrashDetection.useEffect\"]).catch({\n                    \"useCrashDetection.useEffect\": (error)=>{\n                        console.error(\"Motion permission denied:\", error);\n                    }\n                }[\"useCrashDetection.useEffect\"]);\n            } else {\n                // Android or older iOS\n                window.addEventListener(\"devicemotion\", handleMotion);\n                window.addEventListener(\"deviceorientation\", handleOrientation);\n            }\n            return ({\n                \"useCrashDetection.useEffect\": ()=>{\n                    window.removeEventListener(\"devicemotion\", handleMotion);\n                    window.removeEventListener(\"deviceorientation\", handleOrientation);\n                }\n            })[\"useCrashDetection.useEffect\"];\n        }\n    }[\"useCrashDetection.useEffect\"], [\n        isEnabled,\n        position,\n        onCrashDetected\n    ]);\n    return {\n        crashDetected,\n        setCrashDetected\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2hvb2tzL3VzZS1jcmFzaC1kZXRlY3Rpb24udHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQW1EO0FBYzVDLFNBQVNHLGtCQUNkQyxTQUFrQixFQUNsQkMsWUFBb0IsRUFDcEJDLFFBQTZDLEVBQzdDQyxlQUEwQztJQUUxQyxNQUFNLENBQUNDLGVBQWVDLGlCQUFpQixHQUFHUCwrQ0FBUUEsQ0FBQztJQUNuRCxNQUFNUSxtQkFBbUJULDZDQUFNQSxDQUFDO1FBQUVVLEdBQUc7UUFBR0MsR0FBRztRQUFHQyxHQUFHO0lBQUU7SUFDbkQsTUFBTUMsZUFBZWIsNkNBQU1BLENBQUM7UUFBRWMsT0FBTztRQUFHQyxNQUFNO1FBQUdDLE9BQU87SUFBRTtJQUMxRCxNQUFNQyxXQUFXakIsNkNBQU1BLENBQUNrQixLQUFLQyxHQUFHO0lBQ2hDLE1BQU1DLGdCQUFnQnBCLDZDQUFNQSxDQUFDO0lBQzdCLE1BQU1xQixzQkFBc0JyQiw2Q0FBTUEsQ0FBQztRQUFFYyxPQUFPO1FBQUdDLE1BQU07UUFBR0MsT0FBTztJQUFFO0lBQ2pFLE1BQU1NLGdCQUFnQnRCLDZDQUFNQSxDQUFXLEVBQUU7SUFDekMsTUFBTXVCLGVBQWV2Qiw2Q0FBTUEsQ0FBc0I7SUFDakQsTUFBTXdCLFdBQVd4Qiw2Q0FBTUEsQ0FBc0I7SUFDN0MsTUFBTXlCLG9CQUFvQnpCLDZDQUFNQSxDQUFDO0lBQ2pDLE1BQU0wQixlQUFlMUIsNkNBQU1BLENBQVcsRUFBRTtJQUN4QyxNQUFNMkIsZ0JBQWdCM0IsNkNBQU1BLENBQUM7SUFDN0IsTUFBTTRCLHNCQUFzQjVCLDZDQUFNQSxDQUEyRCxFQUFFO0lBQy9GLE1BQU02Qix3QkFBd0I3Qiw2Q0FBTUEsQ0FBQztRQUFFOEIsTUFBTTtRQUFHQyxNQUFNO0lBQUU7SUFDeEQsTUFBTUMsdUJBQXVCaEMsNkNBQU1BLENBQTBDLEVBQUU7SUFDL0UsTUFBTWlDLGtCQUFrQmpDLDZDQUFNQSxDQUFDO0lBRS9CRCxnREFBU0E7dUNBQUM7WUFDUnFCLGNBQWNjLE9BQU8sR0FBRzlCO1lBRXhCLGdEQUFnRDtZQUNoRHNCLGFBQWFRLE9BQU8sQ0FBQ0MsSUFBSSxDQUFDL0I7WUFDMUIsSUFBSXNCLGFBQWFRLE9BQU8sQ0FBQ0UsTUFBTSxHQUFHLElBQUk7Z0JBQ3BDVixhQUFhUSxPQUFPLENBQUNHLEtBQUssSUFBRyxvQ0FBb0M7WUFDbkU7UUFDRjtzQ0FBRztRQUFDakM7S0FBYTtJQUVqQix3QkFBd0I7SUFDeEJMLGdEQUFTQTt1Q0FBQztZQUNSLElBQUksQ0FBQ0ksYUFBYSxhQUFrQixhQUFhO1lBRWpELE1BQU1tQzttRUFBc0I7b0JBQzFCLElBQUk7d0JBQ0YsTUFBTUMsU0FBUyxNQUFNQyxVQUFVQyxZQUFZLENBQUNDLFlBQVksQ0FBQzs0QkFBRUMsT0FBTzt3QkFBSzt3QkFDdkVwQixhQUFhVyxPQUFPLEdBQUcsSUFBS1UsQ0FBQUEsT0FBT0MsWUFBWSxJQUFJLE9BQWdCQyxrQkFBa0I7d0JBQ3JGLE1BQU1DLFNBQVN4QixhQUFhVyxPQUFPLENBQUNjLHVCQUF1QixDQUFDVDt3QkFDNURmLFNBQVNVLE9BQU8sR0FBR1gsYUFBYVcsT0FBTyxDQUFDZSxjQUFjO3dCQUN0RHpCLFNBQVNVLE9BQU8sQ0FBQ2dCLE9BQU8sR0FBRzt3QkFDM0JILE9BQU9JLE9BQU8sQ0FBQzNCLFNBQVNVLE9BQU87d0JBRS9CLHlDQUF5Qzt3QkFDekMsTUFBTWtCOzBGQUFhO2dDQUNqQixJQUFJLENBQUM1QixTQUFTVSxPQUFPLEVBQUU7Z0NBRXZCLE1BQU1tQixZQUFZLElBQUlDLFdBQVc5QixTQUFTVSxPQUFPLENBQUNxQixpQkFBaUI7Z0NBQ25FL0IsU0FBU1UsT0FBTyxDQUFDc0Isb0JBQW9CLENBQUNIO2dDQUV0QywyQkFBMkI7Z0NBQzNCLE1BQU1JLFVBQVVKLFVBQVVLLE1BQU07a0dBQUMsQ0FBQ0MsR0FBR0MsSUFBTUQsSUFBSUM7bUdBQUtQLFVBQVVqQixNQUFNO2dDQUVwRSwyREFBMkQ7Z0NBQzNELElBQUlxQixVQUFVLEtBQUs7b0NBQ2pCSSxRQUFRQyxHQUFHLENBQUMsd0JBQXdCTDtvQ0FDcENoQyxrQkFBa0JTLE9BQU8sR0FBRztvQ0FDNUI2QjtzR0FBVzs0Q0FDVHRDLGtCQUFrQlMsT0FBTyxHQUFHO3dDQUM5QjtxR0FBRyxPQUFNLHdCQUF3QjtnQ0FDbkM7NEJBQ0Y7O3dCQUVBOEIsWUFBWVosWUFBWSxNQUFLLG9CQUFvQjtvQkFDbkQsRUFBRSxPQUFPYSxPQUFPO3dCQUNkSixRQUFRQyxHQUFHLENBQUMsa0NBQWtDRztvQkFDaEQ7Z0JBQ0Y7O1lBRUEzQjtZQUVBOytDQUFPO29CQUNMLElBQUlmLGFBQWFXLE9BQU8sRUFBRTt3QkFDeEJYLGFBQWFXLE9BQU8sQ0FBQ2dDLEtBQUs7b0JBQzVCO2dCQUNGOztRQUNGO3NDQUFHO1FBQUMvRDtLQUFVO0lBRWRKLGdEQUFTQTt1Q0FBQztZQUNSLElBQUksQ0FBQ0ksYUFBYSxhQUFrQixhQUFhO1lBRWpELElBQUlnRSxlQUFlO1lBQ25CLElBQUlDLGVBQWU7WUFFbkIsK0NBQStDO1lBQy9DLE1BQU1DO2lFQUFvQixDQUFDQztvQkFDekIsSUFBSUEsTUFBTXhELEtBQUssS0FBSyxRQUFRd0QsTUFBTXZELElBQUksS0FBSyxRQUFRdUQsTUFBTXRELEtBQUssS0FBSyxNQUFNO29CQUV6RW9ELGVBQWU7b0JBQ2YsTUFBTWpELE1BQU1ELEtBQUtDLEdBQUc7b0JBQ3BCLE1BQU1vRCxXQUFXLENBQUNwRCxNQUFNRixTQUFTaUIsT0FBTyxJQUFJO29CQUU1QyxJQUFJcUMsV0FBVyxLQUFLO29CQUVwQiwrQ0FBK0M7b0JBQy9DLE1BQU1DLGNBQWNDLEtBQUtDLEdBQUcsQ0FBQ0osTUFBTXhELEtBQUssR0FBR0QsYUFBYXFCLE9BQU8sQ0FBQ3BCLEtBQUs7b0JBQ3JFLE1BQU02RCxhQUFhRixLQUFLQyxHQUFHLENBQUNKLE1BQU12RCxJQUFJLEdBQUdGLGFBQWFxQixPQUFPLENBQUNuQixJQUFJO29CQUNsRSxNQUFNNkQsY0FBY0gsS0FBS0MsR0FBRyxDQUFDSixNQUFNdEQsS0FBSyxHQUFHSCxhQUFhcUIsT0FBTyxDQUFDbEIsS0FBSztvQkFFckUseUNBQXlDO29CQUN6QyxNQUFNNkQsd0JBQXdCTCxjQUFjLE1BQU0sTUFBTUEsY0FBY0E7b0JBRXRFTCxlQUFlTSxLQUFLSyxJQUFJLENBQ3RCRCx5QkFBeUIsSUFBSUYsY0FBYyxJQUFJQyxlQUFlLEtBQzVETDtvQkFFSixtRUFBbUU7b0JBQ25FLElBQUlKLGVBQWUsTUFBTS9DLGNBQWNjLE9BQU8sR0FBRyxJQUFJO3dCQUNuRDJCLFFBQVFDLEdBQUcsQ0FBQyxzQkFBc0I7NEJBQ2hDSyxjQUFjQSxhQUFhWSxPQUFPLENBQUM7NEJBQ25DQyxPQUFPNUQsY0FBY2MsT0FBTzt3QkFDOUI7d0JBRUExQixpQkFBaUI7d0JBQ2pCRixnQkFBZ0I7NEJBQ2QyRSxRQUFROzRCQUNSQyxXQUFXL0Q7NEJBQ1hkOzRCQUNBMkUsT0FBTzVELGNBQWNjLE9BQU87NEJBQzVCaUQsV0FBVzs0QkFDWGhCO3dCQUNGO29CQUNGO29CQUVBdEQsYUFBYXFCLE9BQU8sR0FBRzt3QkFBRXBCLE9BQU93RCxNQUFNeEQsS0FBSzt3QkFBRUMsTUFBTXVELE1BQU12RCxJQUFJO3dCQUFFQyxPQUFPc0QsTUFBTXRELEtBQUs7b0JBQUM7Z0JBQ3BGOztZQUVBLE1BQU1vRTs0REFBZSxDQUFDZDtvQkFDcEIsTUFBTWUsTUFBTWYsTUFBTWdCLDRCQUE0QjtvQkFDOUMsTUFBTUMsV0FBV2pCLE1BQU1ILFlBQVk7b0JBRW5DLElBQUksQ0FBQ2tCLE9BQU9BLElBQUkzRSxDQUFDLEtBQUssUUFBUTJFLElBQUkxRSxDQUFDLEtBQUssUUFBUTBFLElBQUl6RSxDQUFDLEtBQUssTUFBTTtvQkFFaEUsTUFBTU8sTUFBTUQsS0FBS0MsR0FBRztvQkFDcEIsTUFBTW9ELFdBQVcsQ0FBQ3BELE1BQU1GLFNBQVNpQixPQUFPLElBQUksS0FBSyxVQUFVOztvQkFFM0QsSUFBSXFDLFdBQVcsS0FBSyxRQUFPLDhCQUE4QjtvQkFFekQsa0RBQWtEO29CQUNsRCxNQUFNaUIsUUFBUWYsS0FBS0MsR0FBRyxDQUFDVyxJQUFJM0UsQ0FBQyxHQUFHRCxpQkFBaUJ5QixPQUFPLENBQUN4QixDQUFDLElBQUk2RDtvQkFDN0QsTUFBTWtCLFFBQVFoQixLQUFLQyxHQUFHLENBQUNXLElBQUkxRSxDQUFDLEdBQUdGLGlCQUFpQnlCLE9BQU8sQ0FBQ3ZCLENBQUMsSUFBSTREO29CQUM3RCxNQUFNbUIsUUFBUWpCLEtBQUtDLEdBQUcsQ0FBQ1csSUFBSXpFLENBQUMsR0FBR0gsaUJBQWlCeUIsT0FBTyxDQUFDdEIsQ0FBQyxJQUFJMkQ7b0JBRTdELE1BQU1vQixZQUFZbEIsS0FBS0ssSUFBSSxDQUFDVSxTQUFTLElBQUlDLFNBQVMsSUFBSUMsU0FBUztvQkFFL0Qsc0NBQXNDO29CQUN0QyxNQUFNRSxTQUFTbkIsS0FBS0ssSUFBSSxDQUFDTyxJQUFJM0UsQ0FBQyxJQUFJLElBQUkyRSxJQUFJMUUsQ0FBQyxJQUFJLElBQUkwRSxJQUFJekUsQ0FBQyxJQUFJLEtBQUs7b0JBRWpFLDJDQUEyQztvQkFDM0MsSUFBSWlGLG1CQUFtQjtvQkFDdkIsSUFBSU4sWUFBWUEsU0FBU3pFLEtBQUssS0FBSyxRQUFReUUsU0FBU3hFLElBQUksS0FBSyxRQUFRd0UsU0FBU3ZFLEtBQUssS0FBSyxNQUFNO3dCQUM1RjZFLG1CQUFtQnBCLEtBQUtLLElBQUksQ0FDMUJTLFNBQVN6RSxLQUFLLElBQUksSUFBSXlFLFNBQVN4RSxJQUFJLElBQUksSUFBSXdFLFNBQVN2RSxLQUFLLElBQUk7b0JBRWpFO29CQUVBLDZDQUE2QztvQkFDN0MsTUFBTThFLFlBQVlwRSxhQUFhUSxPQUFPLENBQUNFLE1BQU0sSUFBSSxJQUM3Q1YsYUFBYVEsT0FBTyxDQUFDLEVBQUUsR0FBR1IsYUFBYVEsT0FBTyxDQUFDUixhQUFhUSxPQUFPLENBQUNFLE1BQU0sR0FBRyxFQUFFLEdBQy9FO29CQUVKLDBEQUEwRDtvQkFDMURkLGNBQWNZLE9BQU8sQ0FBQ0MsSUFBSSxDQUFDeUQ7b0JBQzNCLElBQUl0RSxjQUFjWSxPQUFPLENBQUNFLE1BQU0sR0FBRyxHQUFHO3dCQUNwQ2QsY0FBY1ksT0FBTyxDQUFDRyxLQUFLO29CQUM3QjtvQkFFQSx3RUFBd0U7b0JBQ3hFLE1BQU0wRCxlQUFlekUsY0FBY1ksT0FBTyxDQUFDOEQsTUFBTTtvRUFBQ0MsQ0FBQUEsSUFBS0EsSUFBSTttRUFBSzdELE1BQU07b0JBQ3RFLE1BQU04RCxtQkFBbUJILGdCQUFnQixFQUFFLDhCQUE4Qjs7b0JBRXpFLHVEQUF1RDtvQkFDdkQsSUFBSVosWUFBa0U7b0JBQ3RFLE1BQU1nQixlQUFlMUIsS0FBSzJCLEdBQUcsQ0FBQzNCLEtBQUtDLEdBQUcsQ0FBQ1csSUFBSTNFLENBQUMsR0FBRytELEtBQUtDLEdBQUcsQ0FBQ1csSUFBSTFFLENBQUMsR0FBRzhELEtBQUtDLEdBQUcsQ0FBQ1csSUFBSXpFLENBQUM7b0JBRTlFLElBQUk2RCxLQUFLQyxHQUFHLENBQUNXLElBQUkxRSxDQUFDLE1BQU13RixjQUFjO3dCQUNwQ2hCLFlBQVlFLElBQUkxRSxDQUFDLEdBQUcsSUFBSSxZQUFZO29CQUN0QyxPQUFPLElBQUk4RCxLQUFLQyxHQUFHLENBQUNXLElBQUkzRSxDQUFDLE1BQU15RixjQUFjO3dCQUMzQ2hCLFlBQVk7b0JBQ2QsT0FBTyxJQUFJVSxtQkFBbUIsS0FBSzFCLGVBQWUsSUFBSTt3QkFDcERnQixZQUFZO29CQUNkO29CQUVBLHNDQUFzQztvQkFDdEMsSUFBSWtCLGFBQWE7b0JBQ2pCLElBQUlDLG9CQUFvQjtvQkFFeEIsNkNBQTZDO29CQUM3QyxJQUFJVixTQUFTLEdBQUdTLGNBQWM7eUJBQ3pCLElBQUlULFNBQVMsR0FBR1MsY0FBYzt5QkFDOUIsSUFBSVQsU0FBUyxLQUFLUyxjQUFjO29CQUNyQ0M7b0JBRUEsMkNBQTJDO29CQUMzQyxJQUFJWCxZQUFZLElBQUlVLGNBQWM7eUJBQzdCLElBQUlWLFlBQVksSUFBSVUsY0FBYzt5QkFDbEMsSUFBSVYsWUFBWSxJQUFJVSxjQUFjO29CQUN2Q0M7b0JBRUEsd0NBQXdDO29CQUN4QyxJQUFJbEYsY0FBY2MsT0FBTyxHQUFHLElBQUltRSxjQUFjO3lCQUN6QyxJQUFJakYsY0FBY2MsT0FBTyxHQUFHLElBQUltRSxjQUFjO3lCQUM5QyxJQUFJakYsY0FBY2MsT0FBTyxHQUFHLElBQUltRSxjQUFjO29CQUNuREM7b0JBRUEsNENBQTRDO29CQUM1QyxJQUFJN0Usa0JBQWtCUyxPQUFPLEVBQUVtRSxjQUFjO29CQUM3Q0M7b0JBRUEsdUNBQXVDO29CQUN2QyxJQUFJUixZQUFZLElBQUlPLGNBQWM7eUJBQzdCLElBQUlQLFlBQVksSUFBSU8sY0FBYztvQkFDdkNDO29CQUVBLG9EQUFvRDtvQkFDcEQsSUFBSUosa0JBQWtCRyxjQUFjO29CQUNwQ0M7b0JBRUEsNERBQTREO29CQUM1RCxNQUFNQyxlQUFlWCxTQUFTLEtBQUtELFlBQVksTUFBTXZFLGNBQWNjLE9BQU8sR0FBRztvQkFDN0UsTUFBTXNFLGlCQUFpQlosU0FBUyxLQUFLRCxZQUFZLE1BQU12RSxjQUFjYyxPQUFPLEdBQUc7b0JBQy9FLE1BQU11RSxhQUFhLENBQUNaLG1CQUFtQixLQUFLMUIsZUFBZSxFQUFDLEtBQU0vQyxjQUFjYyxPQUFPLEdBQUc7b0JBQzFGLE1BQU13RSxtQkFBbUJMLGNBQWMsTUFBTUgsb0JBQW9COUUsY0FBY2MsT0FBTyxHQUFHO29CQUV6RixpREFBaUQ7b0JBQ2pELE1BQU15RSxxQkFBcUJ4RixNQUFNUSxjQUFjTyxPQUFPO29CQUN0RCxNQUFNMEUsaUJBQWlCLE1BQU0sYUFBYTs7b0JBRTFDLElBQUlELHFCQUFxQkMsZ0JBQWdCO3dCQUN2QyxpQ0FBaUM7d0JBQ2pDbkcsaUJBQWlCeUIsT0FBTyxHQUFHOzRCQUFFeEIsR0FBRzJFLElBQUkzRSxDQUFDOzRCQUFFQyxHQUFHMEUsSUFBSTFFLENBQUM7NEJBQUVDLEdBQUd5RSxJQUFJekUsQ0FBQzt3QkFBQzt3QkFDMURLLFNBQVNpQixPQUFPLEdBQUdmO3dCQUNuQjtvQkFDRjtvQkFFQSxJQUFJb0YsZ0JBQWdCQyxrQkFBa0JDLGNBQWNDLGtCQUFrQjt3QkFDcEU3QyxRQUFRQyxHQUFHLENBQUMsbUJBQW1COzRCQUM3QjhCLFFBQVFBLE9BQU9iLE9BQU8sQ0FBQzs0QkFDdkJZLFdBQVdBLFVBQVVaLE9BQU8sQ0FBQzs0QkFDN0JDLE9BQU81RCxjQUFjYyxPQUFPOzRCQUM1QjRELFdBQVdBLFVBQVVmLE9BQU8sQ0FBQzs0QkFDN0JJOzRCQUNBaEIsY0FBYyxDQUFDMEIsb0JBQW9CMUIsWUFBVyxFQUFHWSxPQUFPLENBQUM7NEJBQ3pEOEIsZUFBZXBGLGtCQUFrQlMsT0FBTzs0QkFDeENtRSxZQUFZQSxXQUFXdEIsT0FBTyxDQUFDLEtBQUs7NEJBQ3BDbUI7d0JBQ0Y7d0JBRUF2RSxjQUFjTyxPQUFPLEdBQUdmO3dCQUN4QlgsaUJBQWlCO3dCQUNqQkYsZ0JBQWdCOzRCQUNkMkUsUUFBUVc7NEJBQ1JWLFdBQVcvRDs0QkFDWGQ7NEJBQ0EyRSxPQUFPNUQsY0FBY2MsT0FBTzs0QkFDNUJpRDs0QkFDQWhCLGNBQWMwQixvQkFBb0IxQjs0QkFDbEMyQjs0QkFDQWUsZUFBZXBGLGtCQUFrQlMsT0FBTzs0QkFDeENtRTt3QkFDRjtvQkFDRjtvQkFFQTVGLGlCQUFpQnlCLE9BQU8sR0FBRzt3QkFBRXhCLEdBQUcyRSxJQUFJM0UsQ0FBQzt3QkFBRUMsR0FBRzBFLElBQUkxRSxDQUFDO3dCQUFFQyxHQUFHeUUsSUFBSXpFLENBQUM7b0JBQUM7b0JBQzFESyxTQUFTaUIsT0FBTyxHQUFHZjtnQkFDckI7O1lBRUEsa0RBQWtEO1lBQ2xELElBQ0UsT0FBTzJGLHNCQUFzQixlQUM3QixPQUFPLGtCQUEyQkMsaUJBQWlCLEtBQUssWUFDeEQ7O2dCQUNFRCxrQkFDQ0MsaUJBQWlCLEdBQ2pCQyxJQUFJO21EQUFDLENBQUNDO3dCQUNMLElBQUlBLGFBQWEsV0FBVzs0QkFDMUJyRSxPQUFPc0UsZ0JBQWdCLENBQUMsZ0JBQWdCOUI7NEJBQ3hDeEMsT0FBT3NFLGdCQUFnQixDQUFDLHFCQUFxQjdDO3dCQUMvQztvQkFDRjtrREFDQzhDLEtBQUs7bURBQUMsQ0FBQ2xEO3dCQUNOSixRQUFRSSxLQUFLLENBQUMsNkJBQTZCQTtvQkFDN0M7O1lBQ0osT0FBTztnQkFDTCx1QkFBdUI7Z0JBQ3ZCckIsT0FBT3NFLGdCQUFnQixDQUFDLGdCQUFnQjlCO2dCQUN4Q3hDLE9BQU9zRSxnQkFBZ0IsQ0FBQyxxQkFBcUI3QztZQUMvQztZQUVBOytDQUFPO29CQUNMekIsT0FBT3dFLG1CQUFtQixDQUFDLGdCQUFnQmhDO29CQUMzQ3hDLE9BQU93RSxtQkFBbUIsQ0FBQyxxQkFBcUIvQztnQkFDbEQ7O1FBQ0Y7c0NBQUc7UUFBQ2xFO1FBQVdFO1FBQVVDO0tBQWdCO0lBRXpDLE9BQU87UUFBRUM7UUFBZUM7SUFBaUI7QUFDM0MiLCJzb3VyY2VzIjpbIkQ6XFxzbWFydHNhZmVcXHNtYXJ0LWFjY2lkZW50LXNhZmV0eVxcaG9va3NcXHVzZS1jcmFzaC1kZXRlY3Rpb24udHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZVN0YXRlIH0gZnJvbSBcInJlYWN0XCJcclxuXHJcbmludGVyZmFjZSBDcmFzaERhdGEge1xyXG4gIGdGb3JjZTogbnVtYmVyXHJcbiAgdGltZXN0YW1wOiBudW1iZXJcclxuICBwb3NpdGlvbjogeyBsYXQ6IG51bWJlcjsgbG5nOiBudW1iZXIgfSB8IG51bGxcclxuICBzcGVlZDogbnVtYmVyXHJcbiAgY3Jhc2hUeXBlPzogXCJmcm9udGFsXCIgfCBcInNpZGVcIiB8IFwicmVhclwiIHwgXCJyb2xsb3ZlclwiIHwgXCJ1bmtub3duXCJcclxuICByb3RhdGlvblJhdGU/OiBudW1iZXJcclxuICBzcGVlZERyb3A/OiBudW1iZXJcclxuICBzb3VuZERldGVjdGVkPzogYm9vbGVhblxyXG4gIGNvbmZpZGVuY2U/OiBudW1iZXJcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUNyYXNoRGV0ZWN0aW9uKFxyXG4gIGlzRW5hYmxlZDogYm9vbGVhbixcclxuICBjdXJyZW50U3BlZWQ6IG51bWJlcixcclxuICBwb3NpdGlvbjogeyBsYXQ6IG51bWJlcjsgbG5nOiBudW1iZXIgfSB8IG51bGwsXHJcbiAgb25DcmFzaERldGVjdGVkOiAoZGF0YTogQ3Jhc2hEYXRhKSA9PiB2b2lkXHJcbikge1xyXG4gIGNvbnN0IFtjcmFzaERldGVjdGVkLCBzZXRDcmFzaERldGVjdGVkXSA9IHVzZVN0YXRlKGZhbHNlKVxyXG4gIGNvbnN0IGxhc3RBY2NlbGVyYXRpb24gPSB1c2VSZWYoeyB4OiAwLCB5OiAwLCB6OiAwIH0pXHJcbiAgY29uc3QgbGFzdFJvdGF0aW9uID0gdXNlUmVmKHsgYWxwaGE6IDAsIGJldGE6IDAsIGdhbW1hOiAwIH0pXHJcbiAgY29uc3QgbGFzdFRpbWUgPSB1c2VSZWYoRGF0ZS5ub3coKSlcclxuICBjb25zdCBwcmV2aW91c1NwZWVkID0gdXNlUmVmKDApXHJcbiAgY29uc3QgYmFzZWxpbmVPcmllbnRhdGlvbiA9IHVzZVJlZih7IGFscGhhOiAwLCBiZXRhOiAwLCBnYW1tYTogMCB9KVxyXG4gIGNvbnN0IGltcGFjdFNhbXBsZXMgPSB1c2VSZWY8bnVtYmVyW10+KFtdKVxyXG4gIGNvbnN0IGF1ZGlvQ29udGV4dCA9IHVzZVJlZjxBdWRpb0NvbnRleHQgfCBudWxsPihudWxsKVxyXG4gIGNvbnN0IGFuYWx5c2VyID0gdXNlUmVmPEFuYWx5c2VyTm9kZSB8IG51bGw+KG51bGwpXHJcbiAgY29uc3QgbG91ZFNvdW5kRGV0ZWN0ZWQgPSB1c2VSZWYoZmFsc2UpXHJcbiAgY29uc3Qgc3BlZWRIaXN0b3J5ID0gdXNlUmVmPG51bWJlcltdPihbXSlcclxuICBjb25zdCBsYXN0Q3Jhc2hUaW1lID0gdXNlUmVmKDApXHJcbiAgY29uc3QgYWNjZWxlcmF0aW9uUGF0dGVybiA9IHVzZVJlZjx7IHg6IG51bWJlcjsgeTogbnVtYmVyOyB6OiBudW1iZXI7IHRpbWVzdGFtcDogbnVtYmVyIH1bXT4oW10pXHJcbiAgY29uc3Qgbm9ybWFsRHJpdmluZ0Jhc2VsaW5lID0gdXNlUmVmKHsgYXZnRzogMSwgbWF4RzogMiB9KVxyXG4gIGNvbnN0IGZhbHNlUG9zaXRpdmVIaXN0b3J5ID0gdXNlUmVmPHsgdGltZXN0YW1wOiBudW1iZXI7IHJlYXNvbjogc3RyaW5nIH1bXT4oW10pXHJcbiAgY29uc3QgdXNlckNhbmNlbENvdW50ID0gdXNlUmVmKDApXHJcblxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBwcmV2aW91c1NwZWVkLmN1cnJlbnQgPSBjdXJyZW50U3BlZWRcclxuICAgIFxyXG4gICAgLy8gVHJhY2sgc3BlZWQgaGlzdG9yeSBmb3Igc3VkZGVuIGRyb3AgZGV0ZWN0aW9uXHJcbiAgICBzcGVlZEhpc3RvcnkuY3VycmVudC5wdXNoKGN1cnJlbnRTcGVlZClcclxuICAgIGlmIChzcGVlZEhpc3RvcnkuY3VycmVudC5sZW5ndGggPiAxMCkge1xyXG4gICAgICBzcGVlZEhpc3RvcnkuY3VycmVudC5zaGlmdCgpIC8vIEtlZXAgbGFzdCAxMCByZWFkaW5ncyAoMiBzZWNvbmRzKVxyXG4gICAgfVxyXG4gIH0sIFtjdXJyZW50U3BlZWRdKVxyXG5cclxuICAvLyBTb3VuZCBkZXRlY3Rpb24gc2V0dXBcclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgaWYgKCFpc0VuYWJsZWQgfHwgdHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuXHJcblxyXG4gICAgY29uc3Qgc2V0dXBBdWRpb0RldGVjdGlvbiA9IGFzeW5jICgpID0+IHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBzdHJlYW0gPSBhd2FpdCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSh7IGF1ZGlvOiB0cnVlIH0pXHJcbiAgICAgICAgYXVkaW9Db250ZXh0LmN1cnJlbnQgPSBuZXcgKHdpbmRvdy5BdWRpb0NvbnRleHQgfHwgKHdpbmRvdyBhcyBhbnkpLndlYmtpdEF1ZGlvQ29udGV4dCkoKVxyXG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IGF1ZGlvQ29udGV4dC5jdXJyZW50LmNyZWF0ZU1lZGlhU3RyZWFtU291cmNlKHN0cmVhbSlcclxuICAgICAgICBhbmFseXNlci5jdXJyZW50ID0gYXVkaW9Db250ZXh0LmN1cnJlbnQuY3JlYXRlQW5hbHlzZXIoKVxyXG4gICAgICAgIGFuYWx5c2VyLmN1cnJlbnQuZmZ0U2l6ZSA9IDIwNDhcclxuICAgICAgICBzb3VyY2UuY29ubmVjdChhbmFseXNlci5jdXJyZW50KVxyXG5cclxuICAgICAgICAvLyBNb25pdG9yIGZvciBsb3VkIHNvdW5kcyAoY3Jhc2gvYWlyYmFnKVxyXG4gICAgICAgIGNvbnN0IGNoZWNrU291bmQgPSAoKSA9PiB7XHJcbiAgICAgICAgICBpZiAoIWFuYWx5c2VyLmN1cnJlbnQpIHJldHVyblxyXG5cclxuICAgICAgICAgIGNvbnN0IGRhdGFBcnJheSA9IG5ldyBVaW50OEFycmF5KGFuYWx5c2VyLmN1cnJlbnQuZnJlcXVlbmN5QmluQ291bnQpXHJcbiAgICAgICAgICBhbmFseXNlci5jdXJyZW50LmdldEJ5dGVGcmVxdWVuY3lEYXRhKGRhdGFBcnJheSlcclxuXHJcbiAgICAgICAgICAvLyBDYWxjdWxhdGUgYXZlcmFnZSB2b2x1bWVcclxuICAgICAgICAgIGNvbnN0IGF2ZXJhZ2UgPSBkYXRhQXJyYXkucmVkdWNlKChhLCBiKSA9PiBhICsgYikgLyBkYXRhQXJyYXkubGVuZ3RoXHJcblxyXG4gICAgICAgICAgLy8gRGV0ZWN0IGxvdWQgc3VkZGVuIHNvdW5kICg+MTUwIHRocmVzaG9sZCA9IGNyYXNoL2FpcmJhZylcclxuICAgICAgICAgIGlmIChhdmVyYWdlID4gMTUwKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiTE9VRCBTT1VORCBERVRFQ1RFRDpcIiwgYXZlcmFnZSlcclxuICAgICAgICAgICAgbG91ZFNvdW5kRGV0ZWN0ZWQuY3VycmVudCA9IHRydWVcclxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgbG91ZFNvdW5kRGV0ZWN0ZWQuY3VycmVudCA9IGZhbHNlXHJcbiAgICAgICAgICAgIH0sIDIwMDApIC8vIFJlc2V0IGFmdGVyIDIgc2Vjb25kc1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc2V0SW50ZXJ2YWwoY2hlY2tTb3VuZCwgMTAwKSAvLyBDaGVjayBldmVyeSAxMDBtc1xyXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiQXVkaW8gZGV0ZWN0aW9uIG5vdCBhdmFpbGFibGU6XCIsIGVycm9yKVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgc2V0dXBBdWRpb0RldGVjdGlvbigpXHJcblxyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgaWYgKGF1ZGlvQ29udGV4dC5jdXJyZW50KSB7XHJcbiAgICAgICAgYXVkaW9Db250ZXh0LmN1cnJlbnQuY2xvc2UoKVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSwgW2lzRW5hYmxlZF0pXHJcblxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBpZiAoIWlzRW5hYmxlZCB8fCB0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSByZXR1cm5cclxuXHJcbiAgICBsZXQgcm90YXRpb25SYXRlID0gMFxyXG4gICAgbGV0IGhhc0d5cm9zY29wZSA9IGZhbHNlXHJcblxyXG4gICAgLy8gSGFuZGxlIGd5cm9zY29wZSBkYXRhIGZvciByb2xsb3ZlciBkZXRlY3Rpb25cclxuICAgIGNvbnN0IGhhbmRsZU9yaWVudGF0aW9uID0gKGV2ZW50OiBEZXZpY2VPcmllbnRhdGlvbkV2ZW50KSA9PiB7XHJcbiAgICAgIGlmIChldmVudC5hbHBoYSA9PT0gbnVsbCB8fCBldmVudC5iZXRhID09PSBudWxsIHx8IGV2ZW50LmdhbW1hID09PSBudWxsKSByZXR1cm5cclxuICAgICAgXHJcbiAgICAgIGhhc0d5cm9zY29wZSA9IHRydWVcclxuICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKVxyXG4gICAgICBjb25zdCB0aW1lRGlmZiA9IChub3cgLSBsYXN0VGltZS5jdXJyZW50KSAvIDEwMDBcclxuXHJcbiAgICAgIGlmICh0aW1lRGlmZiA8IDAuMSkgcmV0dXJuXHJcblxyXG4gICAgICAvLyBDYWxjdWxhdGUgcm90YXRpb24gcmF0ZSAoZGVncmVlcyBwZXIgc2Vjb25kKVxyXG4gICAgICBjb25zdCBhbHBoYUNoYW5nZSA9IE1hdGguYWJzKGV2ZW50LmFscGhhIC0gbGFzdFJvdGF0aW9uLmN1cnJlbnQuYWxwaGEpXHJcbiAgICAgIGNvbnN0IGJldGFDaGFuZ2UgPSBNYXRoLmFicyhldmVudC5iZXRhIC0gbGFzdFJvdGF0aW9uLmN1cnJlbnQuYmV0YSlcclxuICAgICAgY29uc3QgZ2FtbWFDaGFuZ2UgPSBNYXRoLmFicyhldmVudC5nYW1tYSAtIGxhc3RSb3RhdGlvbi5jdXJyZW50LmdhbW1hKVxyXG5cclxuICAgICAgLy8gSGFuZGxlIDM2MC1kZWdyZWUgd3JhcGFyb3VuZCBmb3IgYWxwaGFcclxuICAgICAgY29uc3Qgbm9ybWFsaXplZEFscGhhQ2hhbmdlID0gYWxwaGFDaGFuZ2UgPiAxODAgPyAzNjAgLSBhbHBoYUNoYW5nZSA6IGFscGhhQ2hhbmdlXHJcblxyXG4gICAgICByb3RhdGlvblJhdGUgPSBNYXRoLnNxcnQoXHJcbiAgICAgICAgbm9ybWFsaXplZEFscGhhQ2hhbmdlICoqIDIgKyBiZXRhQ2hhbmdlICoqIDIgKyBnYW1tYUNoYW5nZSAqKiAyXHJcbiAgICAgICkgLyB0aW1lRGlmZlxyXG5cclxuICAgICAgLy8gRGV0ZWN0IHJvbGxvdmVyOiBleHRyZW1lIHJvdGF0aW9uICg+OTAgZGVncmVlcy9zZWMpIHdoaWxlIG1vdmluZ1xyXG4gICAgICBpZiAocm90YXRpb25SYXRlID4gOTAgJiYgcHJldmlvdXNTcGVlZC5jdXJyZW50ID4gMTUpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhcIlJPTExPVkVSIERFVEVDVEVEIVwiLCB7XHJcbiAgICAgICAgICByb3RhdGlvblJhdGU6IHJvdGF0aW9uUmF0ZS50b0ZpeGVkKDIpLFxyXG4gICAgICAgICAgc3BlZWQ6IHByZXZpb3VzU3BlZWQuY3VycmVudCxcclxuICAgICAgICB9KVxyXG5cclxuICAgICAgICBzZXRDcmFzaERldGVjdGVkKHRydWUpXHJcbiAgICAgICAgb25DcmFzaERldGVjdGVkKHtcclxuICAgICAgICAgIGdGb3JjZTogMCxcclxuICAgICAgICAgIHRpbWVzdGFtcDogbm93LFxyXG4gICAgICAgICAgcG9zaXRpb24sXHJcbiAgICAgICAgICBzcGVlZDogcHJldmlvdXNTcGVlZC5jdXJyZW50LFxyXG4gICAgICAgICAgY3Jhc2hUeXBlOiBcInJvbGxvdmVyXCIsXHJcbiAgICAgICAgICByb3RhdGlvblJhdGUsXHJcbiAgICAgICAgfSlcclxuICAgICAgfVxyXG5cclxuICAgICAgbGFzdFJvdGF0aW9uLmN1cnJlbnQgPSB7IGFscGhhOiBldmVudC5hbHBoYSwgYmV0YTogZXZlbnQuYmV0YSwgZ2FtbWE6IGV2ZW50LmdhbW1hIH1cclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBoYW5kbGVNb3Rpb24gPSAoZXZlbnQ6IERldmljZU1vdGlvbkV2ZW50KSA9PiB7XHJcbiAgICAgIGNvbnN0IGFjYyA9IGV2ZW50LmFjY2VsZXJhdGlvbkluY2x1ZGluZ0dyYXZpdHlcclxuICAgICAgY29uc3Qgcm90YXRpb24gPSBldmVudC5yb3RhdGlvblJhdGVcclxuICAgICAgXHJcbiAgICAgIGlmICghYWNjIHx8IGFjYy54ID09PSBudWxsIHx8IGFjYy55ID09PSBudWxsIHx8IGFjYy56ID09PSBudWxsKSByZXR1cm5cclxuXHJcbiAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KClcclxuICAgICAgY29uc3QgdGltZURpZmYgPSAobm93IC0gbGFzdFRpbWUuY3VycmVudCkgLyAxMDAwIC8vIHNlY29uZHNcclxuXHJcbiAgICAgIGlmICh0aW1lRGlmZiA8IDAuMSkgcmV0dXJuIC8vIElnbm9yZSB0b28gZnJlcXVlbnQgdXBkYXRlc1xyXG5cclxuICAgICAgLy8gQ2FsY3VsYXRlIGplcmsgKHJhdGUgb2YgY2hhbmdlIG9mIGFjY2VsZXJhdGlvbilcclxuICAgICAgY29uc3QgamVya1ggPSBNYXRoLmFicyhhY2MueCAtIGxhc3RBY2NlbGVyYXRpb24uY3VycmVudC54KSAvIHRpbWVEaWZmXHJcbiAgICAgIGNvbnN0IGplcmtZID0gTWF0aC5hYnMoYWNjLnkgLSBsYXN0QWNjZWxlcmF0aW9uLmN1cnJlbnQueSkgLyB0aW1lRGlmZlxyXG4gICAgICBjb25zdCBqZXJrWiA9IE1hdGguYWJzKGFjYy56IC0gbGFzdEFjY2VsZXJhdGlvbi5jdXJyZW50LnopIC8gdGltZURpZmZcclxuXHJcbiAgICAgIGNvbnN0IHRvdGFsSmVyayA9IE1hdGguc3FydChqZXJrWCAqKiAyICsgamVya1kgKiogMiArIGplcmtaICoqIDIpXHJcblxyXG4gICAgICAvLyBUb3RhbCBhY2NlbGVyYXRpb24gbWFnbml0dWRlIGluIEcnc1xyXG4gICAgICBjb25zdCB0b3RhbEcgPSBNYXRoLnNxcnQoYWNjLnggKiogMiArIGFjYy55ICoqIDIgKyBhY2MueiAqKiAyKSAvIDkuOFxyXG5cclxuICAgICAgLy8gR2V0IGd5cm9zY29wZSByb3RhdGlvbiByYXRlIGlmIGF2YWlsYWJsZVxyXG4gICAgICBsZXQgZ3lyb1JvdGF0aW9uUmF0ZSA9IDBcclxuICAgICAgaWYgKHJvdGF0aW9uICYmIHJvdGF0aW9uLmFscGhhICE9PSBudWxsICYmIHJvdGF0aW9uLmJldGEgIT09IG51bGwgJiYgcm90YXRpb24uZ2FtbWEgIT09IG51bGwpIHtcclxuICAgICAgICBneXJvUm90YXRpb25SYXRlID0gTWF0aC5zcXJ0KFxyXG4gICAgICAgICAgcm90YXRpb24uYWxwaGEgKiogMiArIHJvdGF0aW9uLmJldGEgKiogMiArIHJvdGF0aW9uLmdhbW1hICoqIDJcclxuICAgICAgICApXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIENhbGN1bGF0ZSBzcGVlZCBkcm9wIChzdWRkZW4gZGVjZWxlcmF0aW9uKVxyXG4gICAgICBjb25zdCBzcGVlZERyb3AgPSBzcGVlZEhpc3RvcnkuY3VycmVudC5sZW5ndGggPj0gMlxyXG4gICAgICAgID8gc3BlZWRIaXN0b3J5LmN1cnJlbnRbMF0gLSBzcGVlZEhpc3RvcnkuY3VycmVudFtzcGVlZEhpc3RvcnkuY3VycmVudC5sZW5ndGggLSAxXVxyXG4gICAgICAgIDogMFxyXG5cclxuICAgICAgLy8gTXVsdGktc2FtcGxlIHZlcmlmaWNhdGlvbjogU3RvcmUgbGFzdCA1IGltcGFjdCByZWFkaW5nc1xyXG4gICAgICBpbXBhY3RTYW1wbGVzLmN1cnJlbnQucHVzaCh0b3RhbEcpXHJcbiAgICAgIGlmIChpbXBhY3RTYW1wbGVzLmN1cnJlbnQubGVuZ3RoID4gNSkge1xyXG4gICAgICAgIGltcGFjdFNhbXBsZXMuY3VycmVudC5zaGlmdCgpXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIENoZWNrIGlmIG11bHRpcGxlIHNhbXBsZXMgc2hvdyBoaWdoIEctZm9yY2UgKHJlZHVjZXMgZmFsc2UgcG9zaXRpdmVzKVxyXG4gICAgICBjb25zdCBoaWdoR1NhbXBsZXMgPSBpbXBhY3RTYW1wbGVzLmN1cnJlbnQuZmlsdGVyKGcgPT4gZyA+IDIuNSkubGVuZ3RoXHJcbiAgICAgIGNvbnN0IGNvbnNpc3RlbnRJbXBhY3QgPSBoaWdoR1NhbXBsZXMgPj0gMyAvLyBBdCBsZWFzdCAzIG91dCBvZiA1IHNhbXBsZXNcclxuXHJcbiAgICAgIC8vIERldGVybWluZSBjcmFzaCB0eXBlIGJhc2VkIG9uIGFjY2VsZXJhdGlvbiBkaXJlY3Rpb25cclxuICAgICAgbGV0IGNyYXNoVHlwZTogXCJmcm9udGFsXCIgfCBcInNpZGVcIiB8IFwicmVhclwiIHwgXCJyb2xsb3ZlclwiIHwgXCJ1bmtub3duXCIgPSBcInVua25vd25cIlxyXG4gICAgICBjb25zdCBkb21pbmFudEF4aXMgPSBNYXRoLm1heChNYXRoLmFicyhhY2MueCksIE1hdGguYWJzKGFjYy55KSwgTWF0aC5hYnMoYWNjLnopKVxyXG4gICAgICBcclxuICAgICAgaWYgKE1hdGguYWJzKGFjYy55KSA9PT0gZG9taW5hbnRBeGlzKSB7XHJcbiAgICAgICAgY3Jhc2hUeXBlID0gYWNjLnkgPiAwID8gXCJmcm9udGFsXCIgOiBcInJlYXJcIlxyXG4gICAgICB9IGVsc2UgaWYgKE1hdGguYWJzKGFjYy54KSA9PT0gZG9taW5hbnRBeGlzKSB7XHJcbiAgICAgICAgY3Jhc2hUeXBlID0gXCJzaWRlXCJcclxuICAgICAgfSBlbHNlIGlmIChneXJvUm90YXRpb25SYXRlID4gNSB8fCByb3RhdGlvblJhdGUgPiA2MCkge1xyXG4gICAgICAgIGNyYXNoVHlwZSA9IFwicm9sbG92ZXJcIlxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBDYWxjdWxhdGUgY29uZmlkZW5jZSBzY29yZSAoMC0xMDAlKVxyXG4gICAgICBsZXQgY29uZmlkZW5jZSA9IDBcclxuICAgICAgbGV0IGNvbmZpZGVuY2VGYWN0b3JzID0gMFxyXG5cclxuICAgICAgLy8gRmFjdG9yIDE6IEctZm9yY2Ugc3RyZW5ndGggKG1heCAzMCBwb2ludHMpXHJcbiAgICAgIGlmICh0b3RhbEcgPiA0KSBjb25maWRlbmNlICs9IDMwXHJcbiAgICAgIGVsc2UgaWYgKHRvdGFsRyA+IDMpIGNvbmZpZGVuY2UgKz0gMjBcclxuICAgICAgZWxzZSBpZiAodG90YWxHID4gMi41KSBjb25maWRlbmNlICs9IDEwXHJcbiAgICAgIGNvbmZpZGVuY2VGYWN0b3JzKytcclxuXHJcbiAgICAgIC8vIEZhY3RvciAyOiBKZXJrIG1hZ25pdHVkZSAobWF4IDI1IHBvaW50cylcclxuICAgICAgaWYgKHRvdGFsSmVyayA+IDQwKSBjb25maWRlbmNlICs9IDI1XHJcbiAgICAgIGVsc2UgaWYgKHRvdGFsSmVyayA+IDMwKSBjb25maWRlbmNlICs9IDE1XHJcbiAgICAgIGVsc2UgaWYgKHRvdGFsSmVyayA+IDIwKSBjb25maWRlbmNlICs9IDEwXHJcbiAgICAgIGNvbmZpZGVuY2VGYWN0b3JzKytcclxuXHJcbiAgICAgIC8vIEZhY3RvciAzOiBTcGVlZCBjaGVjayAobWF4IDE1IHBvaW50cylcclxuICAgICAgaWYgKHByZXZpb3VzU3BlZWQuY3VycmVudCA+IDMwKSBjb25maWRlbmNlICs9IDE1XHJcbiAgICAgIGVsc2UgaWYgKHByZXZpb3VzU3BlZWQuY3VycmVudCA+IDIwKSBjb25maWRlbmNlICs9IDEwXHJcbiAgICAgIGVsc2UgaWYgKHByZXZpb3VzU3BlZWQuY3VycmVudCA+IDE1KSBjb25maWRlbmNlICs9IDVcclxuICAgICAgY29uZmlkZW5jZUZhY3RvcnMrK1xyXG5cclxuICAgICAgLy8gRmFjdG9yIDQ6IFNvdW5kIGRldGVjdGlvbiAobWF4IDE1IHBvaW50cylcclxuICAgICAgaWYgKGxvdWRTb3VuZERldGVjdGVkLmN1cnJlbnQpIGNvbmZpZGVuY2UgKz0gMTVcclxuICAgICAgY29uZmlkZW5jZUZhY3RvcnMrK1xyXG5cclxuICAgICAgLy8gRmFjdG9yIDU6IFNwZWVkIGRyb3AgKG1heCAxMCBwb2ludHMpXHJcbiAgICAgIGlmIChzcGVlZERyb3AgPiAyMCkgY29uZmlkZW5jZSArPSAxMFxyXG4gICAgICBlbHNlIGlmIChzcGVlZERyb3AgPiAxMCkgY29uZmlkZW5jZSArPSA1XHJcbiAgICAgIGNvbmZpZGVuY2VGYWN0b3JzKytcclxuXHJcbiAgICAgIC8vIEZhY3RvciA2OiBNdWx0aS1zYW1wbGUgY29uc2lzdGVuY3kgKG1heCA1IHBvaW50cylcclxuICAgICAgaWYgKGNvbnNpc3RlbnRJbXBhY3QpIGNvbmZpZGVuY2UgKz0gNVxyXG4gICAgICBjb25maWRlbmNlRmFjdG9ycysrXHJcblxyXG4gICAgICAvLyBFbmhhbmNlZCBjcmFzaCBkZXRlY3Rpb24gY3JpdGVyaWEgd2l0aCBjb25maWRlbmNlIHNjb3JpbmdcclxuICAgICAgY29uc3QgaXNIaWdoSW1wYWN0ID0gdG90YWxHID4gNCAmJiB0b3RhbEplcmsgPiA0MCAmJiBwcmV2aW91c1NwZWVkLmN1cnJlbnQgPiAyMFxyXG4gICAgICBjb25zdCBpc01lZGl1bUltcGFjdCA9IHRvdGFsRyA+IDMgJiYgdG90YWxKZXJrID4gMzAgJiYgcHJldmlvdXNTcGVlZC5jdXJyZW50ID4gMTVcclxuICAgICAgY29uc3QgaXNSb2xsb3ZlciA9IChneXJvUm90YXRpb25SYXRlID4gNSB8fCByb3RhdGlvblJhdGUgPiA2MCkgJiYgcHJldmlvdXNTcGVlZC5jdXJyZW50ID4gMTVcclxuICAgICAgY29uc3QgaXNDb25maWRlbnRDcmFzaCA9IGNvbmZpZGVuY2UgPj0gNjAgJiYgY29uc2lzdGVudEltcGFjdCAmJiBwcmV2aW91c1NwZWVkLmN1cnJlbnQgPiAxNVxyXG5cclxuICAgICAgLy8gUHJldmVudCBkdXBsaWNhdGUgZGV0ZWN0aW9ucyAoY29vbGRvd24gcGVyaW9kKVxyXG4gICAgICBjb25zdCB0aW1lU2luY2VMYXN0Q3Jhc2ggPSBub3cgLSBsYXN0Q3Jhc2hUaW1lLmN1cnJlbnRcclxuICAgICAgY29uc3QgY29vbGRvd25QZXJpb2QgPSAxMDAwMCAvLyAxMCBzZWNvbmRzXHJcblxyXG4gICAgICBpZiAodGltZVNpbmNlTGFzdENyYXNoIDwgY29vbGRvd25QZXJpb2QpIHtcclxuICAgICAgICAvLyBTa2lwIGRldGVjdGlvbiBkdXJpbmcgY29vbGRvd25cclxuICAgICAgICBsYXN0QWNjZWxlcmF0aW9uLmN1cnJlbnQgPSB7IHg6IGFjYy54LCB5OiBhY2MueSwgejogYWNjLnogfVxyXG4gICAgICAgIGxhc3RUaW1lLmN1cnJlbnQgPSBub3dcclxuICAgICAgICByZXR1cm5cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGlzSGlnaEltcGFjdCB8fCBpc01lZGl1bUltcGFjdCB8fCBpc1JvbGxvdmVyIHx8IGlzQ29uZmlkZW50Q3Jhc2gpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhcIkNSQVNIIERFVEVDVEVEIVwiLCB7XHJcbiAgICAgICAgICB0b3RhbEc6IHRvdGFsRy50b0ZpeGVkKDIpLFxyXG4gICAgICAgICAgdG90YWxKZXJrOiB0b3RhbEplcmsudG9GaXhlZCgyKSxcclxuICAgICAgICAgIHNwZWVkOiBwcmV2aW91c1NwZWVkLmN1cnJlbnQsXHJcbiAgICAgICAgICBzcGVlZERyb3A6IHNwZWVkRHJvcC50b0ZpeGVkKDEpLFxyXG4gICAgICAgICAgY3Jhc2hUeXBlLFxyXG4gICAgICAgICAgcm90YXRpb25SYXRlOiAoZ3lyb1JvdGF0aW9uUmF0ZSB8fCByb3RhdGlvblJhdGUpLnRvRml4ZWQoMiksXHJcbiAgICAgICAgICBzb3VuZERldGVjdGVkOiBsb3VkU291bmREZXRlY3RlZC5jdXJyZW50LFxyXG4gICAgICAgICAgY29uZmlkZW5jZTogY29uZmlkZW5jZS50b0ZpeGVkKDApICsgXCIlXCIsXHJcbiAgICAgICAgICBjb25zaXN0ZW50SW1wYWN0LFxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgICAgIGxhc3RDcmFzaFRpbWUuY3VycmVudCA9IG5vd1xyXG4gICAgICAgIHNldENyYXNoRGV0ZWN0ZWQodHJ1ZSlcclxuICAgICAgICBvbkNyYXNoRGV0ZWN0ZWQoe1xyXG4gICAgICAgICAgZ0ZvcmNlOiB0b3RhbEcsXHJcbiAgICAgICAgICB0aW1lc3RhbXA6IG5vdyxcclxuICAgICAgICAgIHBvc2l0aW9uLFxyXG4gICAgICAgICAgc3BlZWQ6IHByZXZpb3VzU3BlZWQuY3VycmVudCxcclxuICAgICAgICAgIGNyYXNoVHlwZSxcclxuICAgICAgICAgIHJvdGF0aW9uUmF0ZTogZ3lyb1JvdGF0aW9uUmF0ZSB8fCByb3RhdGlvblJhdGUsXHJcbiAgICAgICAgICBzcGVlZERyb3AsXHJcbiAgICAgICAgICBzb3VuZERldGVjdGVkOiBsb3VkU291bmREZXRlY3RlZC5jdXJyZW50LFxyXG4gICAgICAgICAgY29uZmlkZW5jZSxcclxuICAgICAgICB9KVxyXG4gICAgICB9XHJcblxyXG4gICAgICBsYXN0QWNjZWxlcmF0aW9uLmN1cnJlbnQgPSB7IHg6IGFjYy54LCB5OiBhY2MueSwgejogYWNjLnogfVxyXG4gICAgICBsYXN0VGltZS5jdXJyZW50ID0gbm93XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmVxdWVzdCBwZXJtaXNzaW9uIGZvciBtb3Rpb24gc2Vuc29ycyAoaU9TIDEzKylcclxuICAgIGlmIChcclxuICAgICAgdHlwZW9mIERldmljZU1vdGlvbkV2ZW50ICE9PSBcInVuZGVmaW5lZFwiICYmXHJcbiAgICAgIHR5cGVvZiAoRGV2aWNlTW90aW9uRXZlbnQgYXMgYW55KS5yZXF1ZXN0UGVybWlzc2lvbiA9PT0gXCJmdW5jdGlvblwiXHJcbiAgICApIHtcclxuICAgICAgOyhEZXZpY2VNb3Rpb25FdmVudCBhcyBhbnkpXHJcbiAgICAgICAgLnJlcXVlc3RQZXJtaXNzaW9uKClcclxuICAgICAgICAudGhlbigocmVzcG9uc2U6IHN0cmluZykgPT4ge1xyXG4gICAgICAgICAgaWYgKHJlc3BvbnNlID09PSBcImdyYW50ZWRcIikge1xyXG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImRldmljZW1vdGlvblwiLCBoYW5kbGVNb3Rpb24pXHJcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiZGV2aWNlb3JpZW50YXRpb25cIiwgaGFuZGxlT3JpZW50YXRpb24pXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgICAgICAuY2F0Y2goKGVycm9yOiBFcnJvcikgPT4ge1xyXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIk1vdGlvbiBwZXJtaXNzaW9uIGRlbmllZDpcIiwgZXJyb3IpXHJcbiAgICAgICAgfSlcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIEFuZHJvaWQgb3Igb2xkZXIgaU9TXHJcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiZGV2aWNlbW90aW9uXCIsIGhhbmRsZU1vdGlvbilcclxuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJkZXZpY2VvcmllbnRhdGlvblwiLCBoYW5kbGVPcmllbnRhdGlvbilcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImRldmljZW1vdGlvblwiLCBoYW5kbGVNb3Rpb24pXHJcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiZGV2aWNlb3JpZW50YXRpb25cIiwgaGFuZGxlT3JpZW50YXRpb24pXHJcbiAgICB9XHJcbiAgfSwgW2lzRW5hYmxlZCwgcG9zaXRpb24sIG9uQ3Jhc2hEZXRlY3RlZF0pXHJcblxyXG4gIHJldHVybiB7IGNyYXNoRGV0ZWN0ZWQsIHNldENyYXNoRGV0ZWN0ZWQgfVxyXG59XHJcbiJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJ1c2VTdGF0ZSIsInVzZUNyYXNoRGV0ZWN0aW9uIiwiaXNFbmFibGVkIiwiY3VycmVudFNwZWVkIiwicG9zaXRpb24iLCJvbkNyYXNoRGV0ZWN0ZWQiLCJjcmFzaERldGVjdGVkIiwic2V0Q3Jhc2hEZXRlY3RlZCIsImxhc3RBY2NlbGVyYXRpb24iLCJ4IiwieSIsInoiLCJsYXN0Um90YXRpb24iLCJhbHBoYSIsImJldGEiLCJnYW1tYSIsImxhc3RUaW1lIiwiRGF0ZSIsIm5vdyIsInByZXZpb3VzU3BlZWQiLCJiYXNlbGluZU9yaWVudGF0aW9uIiwiaW1wYWN0U2FtcGxlcyIsImF1ZGlvQ29udGV4dCIsImFuYWx5c2VyIiwibG91ZFNvdW5kRGV0ZWN0ZWQiLCJzcGVlZEhpc3RvcnkiLCJsYXN0Q3Jhc2hUaW1lIiwiYWNjZWxlcmF0aW9uUGF0dGVybiIsIm5vcm1hbERyaXZpbmdCYXNlbGluZSIsImF2Z0ciLCJtYXhHIiwiZmFsc2VQb3NpdGl2ZUhpc3RvcnkiLCJ1c2VyQ2FuY2VsQ291bnQiLCJjdXJyZW50IiwicHVzaCIsImxlbmd0aCIsInNoaWZ0Iiwic2V0dXBBdWRpb0RldGVjdGlvbiIsInN0cmVhbSIsIm5hdmlnYXRvciIsIm1lZGlhRGV2aWNlcyIsImdldFVzZXJNZWRpYSIsImF1ZGlvIiwid2luZG93IiwiQXVkaW9Db250ZXh0Iiwid2Via2l0QXVkaW9Db250ZXh0Iiwic291cmNlIiwiY3JlYXRlTWVkaWFTdHJlYW1Tb3VyY2UiLCJjcmVhdGVBbmFseXNlciIsImZmdFNpemUiLCJjb25uZWN0IiwiY2hlY2tTb3VuZCIsImRhdGFBcnJheSIsIlVpbnQ4QXJyYXkiLCJmcmVxdWVuY3lCaW5Db3VudCIsImdldEJ5dGVGcmVxdWVuY3lEYXRhIiwiYXZlcmFnZSIsInJlZHVjZSIsImEiLCJiIiwiY29uc29sZSIsImxvZyIsInNldFRpbWVvdXQiLCJzZXRJbnRlcnZhbCIsImVycm9yIiwiY2xvc2UiLCJyb3RhdGlvblJhdGUiLCJoYXNHeXJvc2NvcGUiLCJoYW5kbGVPcmllbnRhdGlvbiIsImV2ZW50IiwidGltZURpZmYiLCJhbHBoYUNoYW5nZSIsIk1hdGgiLCJhYnMiLCJiZXRhQ2hhbmdlIiwiZ2FtbWFDaGFuZ2UiLCJub3JtYWxpemVkQWxwaGFDaGFuZ2UiLCJzcXJ0IiwidG9GaXhlZCIsInNwZWVkIiwiZ0ZvcmNlIiwidGltZXN0YW1wIiwiY3Jhc2hUeXBlIiwiaGFuZGxlTW90aW9uIiwiYWNjIiwiYWNjZWxlcmF0aW9uSW5jbHVkaW5nR3Jhdml0eSIsInJvdGF0aW9uIiwiamVya1giLCJqZXJrWSIsImplcmtaIiwidG90YWxKZXJrIiwidG90YWxHIiwiZ3lyb1JvdGF0aW9uUmF0ZSIsInNwZWVkRHJvcCIsImhpZ2hHU2FtcGxlcyIsImZpbHRlciIsImciLCJjb25zaXN0ZW50SW1wYWN0IiwiZG9taW5hbnRBeGlzIiwibWF4IiwiY29uZmlkZW5jZSIsImNvbmZpZGVuY2VGYWN0b3JzIiwiaXNIaWdoSW1wYWN0IiwiaXNNZWRpdW1JbXBhY3QiLCJpc1JvbGxvdmVyIiwiaXNDb25maWRlbnRDcmFzaCIsInRpbWVTaW5jZUxhc3RDcmFzaCIsImNvb2xkb3duUGVyaW9kIiwic291bmREZXRlY3RlZCIsIkRldmljZU1vdGlvbkV2ZW50IiwicmVxdWVzdFBlcm1pc3Npb24iLCJ0aGVuIiwicmVzcG9uc2UiLCJhZGRFdmVudExpc3RlbmVyIiwiY2F0Y2giLCJyZW1vdmVFdmVudExpc3RlbmVyIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./hooks/use-crash-detection.ts\n"));

/***/ })

});