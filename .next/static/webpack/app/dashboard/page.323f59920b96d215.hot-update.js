"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/dashboard/page",{

/***/ "(app-pages-browser)/./hooks/use-crash-detection.ts":
/*!**************************************!*\
  !*** ./hooks/use-crash-detection.ts ***!
  \**************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useCrashDetection: () => (/* binding */ useCrashDetection)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\nfunction useCrashDetection(isEnabled, currentSpeed, position, onCrashDetected) {\n    const [crashDetected, setCrashDetected] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const lastAcceleration = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        x: 0,\n        y: 0,\n        z: 0\n    });\n    const lastRotation = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        alpha: 0,\n        beta: 0,\n        gamma: 0\n    });\n    const lastTime = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(Date.now());\n    const previousSpeed = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const baselineOrientation = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        alpha: 0,\n        beta: 0,\n        gamma: 0\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useCrashDetection.useEffect\": ()=>{\n            previousSpeed.current = currentSpeed;\n        }\n    }[\"useCrashDetection.useEffect\"], [\n        currentSpeed\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useCrashDetection.useEffect\": ()=>{\n            if (!isEnabled || \"object\" === \"undefined\") return;\n            const handleMotion = {\n                \"useCrashDetection.useEffect.handleMotion\": (event)=>{\n                    const acc = event.accelerationIncludingGravity;\n                    if (!acc || acc.x === null || acc.y === null || acc.z === null) return;\n                    const now = Date.now();\n                    const timeDiff = (now - lastTime.current) / 1000 // seconds\n                    ;\n                    if (timeDiff < 0.1) return; // Ignore too frequent updates\n                    // Calculate jerk (rate of change of acceleration)\n                    const jerkX = Math.abs(acc.x - lastAcceleration.current.x) / timeDiff;\n                    const jerkY = Math.abs(acc.y - lastAcceleration.current.y) / timeDiff;\n                    const jerkZ = Math.abs(acc.z - lastAcceleration.current.z) / timeDiff;\n                    const totalJerk = Math.sqrt(jerkX ** 2 + jerkY ** 2 + jerkZ ** 2);\n                    // Total acceleration magnitude in G's\n                    const totalG = Math.sqrt(acc.x ** 2 + acc.y ** 2 + acc.z ** 2) / 9.8;\n                    // Crash detection criteria:\n                    // 1. High G-force (> 4g for definite crash, > 3g for possible)\n                    // 2. High jerk (sudden change > 40)\n                    // 3. Speed was > 20 km/h before impact (to avoid false positives from drops)\n                    const isHighImpact = totalG > 4 && totalJerk > 40 && previousSpeed.current > 20;\n                    const isMediumImpact = totalG > 3 && totalJerk > 30 && previousSpeed.current > 15;\n                    if (isHighImpact || isMediumImpact) {\n                        console.log(\"CRASH DETECTED!\", {\n                            totalG: totalG.toFixed(2),\n                            totalJerk: totalJerk.toFixed(2),\n                            speed: previousSpeed.current\n                        });\n                        setCrashDetected(true);\n                        onCrashDetected({\n                            gForce: totalG,\n                            timestamp: now,\n                            position,\n                            speed: previousSpeed.current\n                        });\n                    }\n                    lastAcceleration.current = {\n                        x: acc.x,\n                        y: acc.y,\n                        z: acc.z\n                    };\n                    lastTime.current = now;\n                }\n            }[\"useCrashDetection.useEffect.handleMotion\"];\n            // Request permission for motion sensors (iOS 13+)\n            if (typeof DeviceMotionEvent !== \"undefined\" && typeof DeviceMotionEvent.requestPermission === \"function\") {\n                ;\n                DeviceMotionEvent.requestPermission().then({\n                    \"useCrashDetection.useEffect\": (response)=>{\n                        if (response === \"granted\") {\n                            window.addEventListener(\"devicemotion\", handleMotion);\n                        }\n                    }\n                }[\"useCrashDetection.useEffect\"]).catch({\n                    \"useCrashDetection.useEffect\": (error)=>{\n                        console.error(\"Motion permission denied:\", error);\n                    }\n                }[\"useCrashDetection.useEffect\"]);\n            } else {\n                // Android or older iOS\n                window.addEventListener(\"devicemotion\", handleMotion);\n            }\n            return ({\n                \"useCrashDetection.useEffect\": ()=>{\n                    window.removeEventListener(\"devicemotion\", handleMotion);\n                }\n            })[\"useCrashDetection.useEffect\"];\n        }\n    }[\"useCrashDetection.useEffect\"], [\n        isEnabled,\n        position,\n        onCrashDetected\n    ]);\n    return {\n        crashDetected,\n        setCrashDetected\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2hvb2tzL3VzZS1jcmFzaC1kZXRlY3Rpb24udHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQW1EO0FBVzVDLFNBQVNHLGtCQUNkQyxTQUFrQixFQUNsQkMsWUFBb0IsRUFDcEJDLFFBQTZDLEVBQzdDQyxlQUEwQztJQUUxQyxNQUFNLENBQUNDLGVBQWVDLGlCQUFpQixHQUFHUCwrQ0FBUUEsQ0FBQztJQUNuRCxNQUFNUSxtQkFBbUJULDZDQUFNQSxDQUFDO1FBQUVVLEdBQUc7UUFBR0MsR0FBRztRQUFHQyxHQUFHO0lBQUU7SUFDbkQsTUFBTUMsZUFBZWIsNkNBQU1BLENBQUM7UUFBRWMsT0FBTztRQUFHQyxNQUFNO1FBQUdDLE9BQU87SUFBRTtJQUMxRCxNQUFNQyxXQUFXakIsNkNBQU1BLENBQUNrQixLQUFLQyxHQUFHO0lBQ2hDLE1BQU1DLGdCQUFnQnBCLDZDQUFNQSxDQUFDO0lBQzdCLE1BQU1xQixzQkFBc0JyQiw2Q0FBTUEsQ0FBQztRQUFFYyxPQUFPO1FBQUdDLE1BQU07UUFBR0MsT0FBTztJQUFFO0lBRWpFakIsZ0RBQVNBO3VDQUFDO1lBQ1JxQixjQUFjRSxPQUFPLEdBQUdsQjtRQUMxQjtzQ0FBRztRQUFDQTtLQUFhO0lBRWpCTCxnREFBU0E7dUNBQUM7WUFDUixJQUFJLENBQUNJLGFBQWEsYUFBa0IsYUFBYTtZQUVqRCxNQUFNb0I7NERBQWUsQ0FBQ0M7b0JBQ3BCLE1BQU1DLE1BQU1ELE1BQU1FLDRCQUE0QjtvQkFDOUMsSUFBSSxDQUFDRCxPQUFPQSxJQUFJZixDQUFDLEtBQUssUUFBUWUsSUFBSWQsQ0FBQyxLQUFLLFFBQVFjLElBQUliLENBQUMsS0FBSyxNQUFNO29CQUVoRSxNQUFNTyxNQUFNRCxLQUFLQyxHQUFHO29CQUNwQixNQUFNUSxXQUFXLENBQUNSLE1BQU1GLFNBQVNLLE9BQU8sSUFBSSxLQUFLLFVBQVU7O29CQUUzRCxJQUFJSyxXQUFXLEtBQUssUUFBTyw4QkFBOEI7b0JBRXpELGtEQUFrRDtvQkFDbEQsTUFBTUMsUUFBUUMsS0FBS0MsR0FBRyxDQUFDTCxJQUFJZixDQUFDLEdBQUdELGlCQUFpQmEsT0FBTyxDQUFDWixDQUFDLElBQUlpQjtvQkFDN0QsTUFBTUksUUFBUUYsS0FBS0MsR0FBRyxDQUFDTCxJQUFJZCxDQUFDLEdBQUdGLGlCQUFpQmEsT0FBTyxDQUFDWCxDQUFDLElBQUlnQjtvQkFDN0QsTUFBTUssUUFBUUgsS0FBS0MsR0FBRyxDQUFDTCxJQUFJYixDQUFDLEdBQUdILGlCQUFpQmEsT0FBTyxDQUFDVixDQUFDLElBQUllO29CQUU3RCxNQUFNTSxZQUFZSixLQUFLSyxJQUFJLENBQUNOLFNBQVMsSUFBSUcsU0FBUyxJQUFJQyxTQUFTO29CQUUvRCxzQ0FBc0M7b0JBQ3RDLE1BQU1HLFNBQVNOLEtBQUtLLElBQUksQ0FBQ1QsSUFBSWYsQ0FBQyxJQUFJLElBQUllLElBQUlkLENBQUMsSUFBSSxJQUFJYyxJQUFJYixDQUFDLElBQUksS0FBSztvQkFFakUsNEJBQTRCO29CQUM1QiwrREFBK0Q7b0JBQy9ELG9DQUFvQztvQkFDcEMsNkVBQTZFO29CQUU3RSxNQUFNd0IsZUFBZUQsU0FBUyxLQUFLRixZQUFZLE1BQU1iLGNBQWNFLE9BQU8sR0FBRztvQkFDN0UsTUFBTWUsaUJBQWlCRixTQUFTLEtBQUtGLFlBQVksTUFBTWIsY0FBY0UsT0FBTyxHQUFHO29CQUUvRSxJQUFJYyxnQkFBZ0JDLGdCQUFnQjt3QkFDbENDLFFBQVFDLEdBQUcsQ0FBQyxtQkFBbUI7NEJBQzdCSixRQUFRQSxPQUFPSyxPQUFPLENBQUM7NEJBQ3ZCUCxXQUFXQSxVQUFVTyxPQUFPLENBQUM7NEJBQzdCQyxPQUFPckIsY0FBY0UsT0FBTzt3QkFDOUI7d0JBRUFkLGlCQUFpQjt3QkFDakJGLGdCQUFnQjs0QkFDZG9DLFFBQVFQOzRCQUNSUSxXQUFXeEI7NEJBQ1hkOzRCQUNBb0MsT0FBT3JCLGNBQWNFLE9BQU87d0JBQzlCO29CQUNGO29CQUVBYixpQkFBaUJhLE9BQU8sR0FBRzt3QkFBRVosR0FBR2UsSUFBSWYsQ0FBQzt3QkFBRUMsR0FBR2MsSUFBSWQsQ0FBQzt3QkFBRUMsR0FBR2EsSUFBSWIsQ0FBQztvQkFBQztvQkFDMURLLFNBQVNLLE9BQU8sR0FBR0g7Z0JBQ3JCOztZQUVBLGtEQUFrRDtZQUNsRCxJQUNFLE9BQU95QixzQkFBc0IsZUFDN0IsT0FBTyxrQkFBMkJDLGlCQUFpQixLQUFLLFlBQ3hEOztnQkFDRUQsa0JBQ0NDLGlCQUFpQixHQUNqQkMsSUFBSTttREFBQyxDQUFDQzt3QkFDTCxJQUFJQSxhQUFhLFdBQVc7NEJBQzFCQyxPQUFPQyxnQkFBZ0IsQ0FBQyxnQkFBZ0IxQjt3QkFDMUM7b0JBQ0Y7a0RBQ0MyQixLQUFLO21EQUFDLENBQUNDO3dCQUNOYixRQUFRYSxLQUFLLENBQUMsNkJBQTZCQTtvQkFDN0M7O1lBQ0osT0FBTztnQkFDTCx1QkFBdUI7Z0JBQ3ZCSCxPQUFPQyxnQkFBZ0IsQ0FBQyxnQkFBZ0IxQjtZQUMxQztZQUVBOytDQUFPO29CQUNMeUIsT0FBT0ksbUJBQW1CLENBQUMsZ0JBQWdCN0I7Z0JBQzdDOztRQUNGO3NDQUFHO1FBQUNwQjtRQUFXRTtRQUFVQztLQUFnQjtJQUV6QyxPQUFPO1FBQUVDO1FBQWVDO0lBQWlCO0FBQzNDIiwic291cmNlcyI6WyJEOlxcc21hcnRzYWZlXFxzbWFydC1hY2NpZGVudC1zYWZldHlcXGhvb2tzXFx1c2UtY3Jhc2gtZGV0ZWN0aW9uLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiXHJcblxyXG5pbnRlcmZhY2UgQ3Jhc2hEYXRhIHtcclxuICBnRm9yY2U6IG51bWJlclxyXG4gIHRpbWVzdGFtcDogbnVtYmVyXHJcbiAgcG9zaXRpb246IHsgbGF0OiBudW1iZXI7IGxuZzogbnVtYmVyIH0gfCBudWxsXHJcbiAgc3BlZWQ6IG51bWJlclxyXG4gIGNyYXNoVHlwZT86IFwiZnJvbnRhbFwiIHwgXCJzaWRlXCIgfCBcInJlYXJcIiB8IFwicm9sbG92ZXJcIiB8IFwidW5rbm93blwiXHJcbiAgcm90YXRpb25SYXRlPzogbnVtYmVyXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VDcmFzaERldGVjdGlvbihcclxuICBpc0VuYWJsZWQ6IGJvb2xlYW4sXHJcbiAgY3VycmVudFNwZWVkOiBudW1iZXIsXHJcbiAgcG9zaXRpb246IHsgbGF0OiBudW1iZXI7IGxuZzogbnVtYmVyIH0gfCBudWxsLFxyXG4gIG9uQ3Jhc2hEZXRlY3RlZDogKGRhdGE6IENyYXNoRGF0YSkgPT4gdm9pZFxyXG4pIHtcclxuICBjb25zdCBbY3Jhc2hEZXRlY3RlZCwgc2V0Q3Jhc2hEZXRlY3RlZF0gPSB1c2VTdGF0ZShmYWxzZSlcclxuICBjb25zdCBsYXN0QWNjZWxlcmF0aW9uID0gdXNlUmVmKHsgeDogMCwgeTogMCwgejogMCB9KVxyXG4gIGNvbnN0IGxhc3RSb3RhdGlvbiA9IHVzZVJlZih7IGFscGhhOiAwLCBiZXRhOiAwLCBnYW1tYTogMCB9KVxyXG4gIGNvbnN0IGxhc3RUaW1lID0gdXNlUmVmKERhdGUubm93KCkpXHJcbiAgY29uc3QgcHJldmlvdXNTcGVlZCA9IHVzZVJlZigwKVxyXG4gIGNvbnN0IGJhc2VsaW5lT3JpZW50YXRpb24gPSB1c2VSZWYoeyBhbHBoYTogMCwgYmV0YTogMCwgZ2FtbWE6IDAgfSlcclxuXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIHByZXZpb3VzU3BlZWQuY3VycmVudCA9IGN1cnJlbnRTcGVlZFxyXG4gIH0sIFtjdXJyZW50U3BlZWRdKVxyXG5cclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgaWYgKCFpc0VuYWJsZWQgfHwgdHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuXHJcblxyXG4gICAgY29uc3QgaGFuZGxlTW90aW9uID0gKGV2ZW50OiBEZXZpY2VNb3Rpb25FdmVudCkgPT4ge1xyXG4gICAgICBjb25zdCBhY2MgPSBldmVudC5hY2NlbGVyYXRpb25JbmNsdWRpbmdHcmF2aXR5XHJcbiAgICAgIGlmICghYWNjIHx8IGFjYy54ID09PSBudWxsIHx8IGFjYy55ID09PSBudWxsIHx8IGFjYy56ID09PSBudWxsKSByZXR1cm5cclxuXHJcbiAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KClcclxuICAgICAgY29uc3QgdGltZURpZmYgPSAobm93IC0gbGFzdFRpbWUuY3VycmVudCkgLyAxMDAwIC8vIHNlY29uZHNcclxuXHJcbiAgICAgIGlmICh0aW1lRGlmZiA8IDAuMSkgcmV0dXJuIC8vIElnbm9yZSB0b28gZnJlcXVlbnQgdXBkYXRlc1xyXG5cclxuICAgICAgLy8gQ2FsY3VsYXRlIGplcmsgKHJhdGUgb2YgY2hhbmdlIG9mIGFjY2VsZXJhdGlvbilcclxuICAgICAgY29uc3QgamVya1ggPSBNYXRoLmFicyhhY2MueCAtIGxhc3RBY2NlbGVyYXRpb24uY3VycmVudC54KSAvIHRpbWVEaWZmXHJcbiAgICAgIGNvbnN0IGplcmtZID0gTWF0aC5hYnMoYWNjLnkgLSBsYXN0QWNjZWxlcmF0aW9uLmN1cnJlbnQueSkgLyB0aW1lRGlmZlxyXG4gICAgICBjb25zdCBqZXJrWiA9IE1hdGguYWJzKGFjYy56IC0gbGFzdEFjY2VsZXJhdGlvbi5jdXJyZW50LnopIC8gdGltZURpZmZcclxuXHJcbiAgICAgIGNvbnN0IHRvdGFsSmVyayA9IE1hdGguc3FydChqZXJrWCAqKiAyICsgamVya1kgKiogMiArIGplcmtaICoqIDIpXHJcblxyXG4gICAgICAvLyBUb3RhbCBhY2NlbGVyYXRpb24gbWFnbml0dWRlIGluIEcnc1xyXG4gICAgICBjb25zdCB0b3RhbEcgPSBNYXRoLnNxcnQoYWNjLnggKiogMiArIGFjYy55ICoqIDIgKyBhY2MueiAqKiAyKSAvIDkuOFxyXG5cclxuICAgICAgLy8gQ3Jhc2ggZGV0ZWN0aW9uIGNyaXRlcmlhOlxyXG4gICAgICAvLyAxLiBIaWdoIEctZm9yY2UgKD4gNGcgZm9yIGRlZmluaXRlIGNyYXNoLCA+IDNnIGZvciBwb3NzaWJsZSlcclxuICAgICAgLy8gMi4gSGlnaCBqZXJrIChzdWRkZW4gY2hhbmdlID4gNDApXHJcbiAgICAgIC8vIDMuIFNwZWVkIHdhcyA+IDIwIGttL2ggYmVmb3JlIGltcGFjdCAodG8gYXZvaWQgZmFsc2UgcG9zaXRpdmVzIGZyb20gZHJvcHMpXHJcblxyXG4gICAgICBjb25zdCBpc0hpZ2hJbXBhY3QgPSB0b3RhbEcgPiA0ICYmIHRvdGFsSmVyayA+IDQwICYmIHByZXZpb3VzU3BlZWQuY3VycmVudCA+IDIwXHJcbiAgICAgIGNvbnN0IGlzTWVkaXVtSW1wYWN0ID0gdG90YWxHID4gMyAmJiB0b3RhbEplcmsgPiAzMCAmJiBwcmV2aW91c1NwZWVkLmN1cnJlbnQgPiAxNVxyXG5cclxuICAgICAgaWYgKGlzSGlnaEltcGFjdCB8fCBpc01lZGl1bUltcGFjdCkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiQ1JBU0ggREVURUNURUQhXCIsIHtcclxuICAgICAgICAgIHRvdGFsRzogdG90YWxHLnRvRml4ZWQoMiksXHJcbiAgICAgICAgICB0b3RhbEplcms6IHRvdGFsSmVyay50b0ZpeGVkKDIpLFxyXG4gICAgICAgICAgc3BlZWQ6IHByZXZpb3VzU3BlZWQuY3VycmVudCxcclxuICAgICAgICB9KVxyXG5cclxuICAgICAgICBzZXRDcmFzaERldGVjdGVkKHRydWUpXHJcbiAgICAgICAgb25DcmFzaERldGVjdGVkKHtcclxuICAgICAgICAgIGdGb3JjZTogdG90YWxHLFxyXG4gICAgICAgICAgdGltZXN0YW1wOiBub3csXHJcbiAgICAgICAgICBwb3NpdGlvbixcclxuICAgICAgICAgIHNwZWVkOiBwcmV2aW91c1NwZWVkLmN1cnJlbnQsXHJcbiAgICAgICAgfSlcclxuICAgICAgfVxyXG5cclxuICAgICAgbGFzdEFjY2VsZXJhdGlvbi5jdXJyZW50ID0geyB4OiBhY2MueCwgeTogYWNjLnksIHo6IGFjYy56IH1cclxuICAgICAgbGFzdFRpbWUuY3VycmVudCA9IG5vd1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFJlcXVlc3QgcGVybWlzc2lvbiBmb3IgbW90aW9uIHNlbnNvcnMgKGlPUyAxMyspXHJcbiAgICBpZiAoXHJcbiAgICAgIHR5cGVvZiBEZXZpY2VNb3Rpb25FdmVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJlxyXG4gICAgICB0eXBlb2YgKERldmljZU1vdGlvbkV2ZW50IGFzIGFueSkucmVxdWVzdFBlcm1pc3Npb24gPT09IFwiZnVuY3Rpb25cIlxyXG4gICAgKSB7XHJcbiAgICAgIDsoRGV2aWNlTW90aW9uRXZlbnQgYXMgYW55KVxyXG4gICAgICAgIC5yZXF1ZXN0UGVybWlzc2lvbigpXHJcbiAgICAgICAgLnRoZW4oKHJlc3BvbnNlOiBzdHJpbmcpID0+IHtcclxuICAgICAgICAgIGlmIChyZXNwb25zZSA9PT0gXCJncmFudGVkXCIpIHtcclxuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJkZXZpY2Vtb3Rpb25cIiwgaGFuZGxlTW90aW9uKVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLmNhdGNoKChlcnJvcjogRXJyb3IpID0+IHtcclxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJNb3Rpb24gcGVybWlzc2lvbiBkZW5pZWQ6XCIsIGVycm9yKVxyXG4gICAgICAgIH0pXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBBbmRyb2lkIG9yIG9sZGVyIGlPU1xyXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImRldmljZW1vdGlvblwiLCBoYW5kbGVNb3Rpb24pXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJkZXZpY2Vtb3Rpb25cIiwgaGFuZGxlTW90aW9uKVxyXG4gICAgfVxyXG4gIH0sIFtpc0VuYWJsZWQsIHBvc2l0aW9uLCBvbkNyYXNoRGV0ZWN0ZWRdKVxyXG5cclxuICByZXR1cm4geyBjcmFzaERldGVjdGVkLCBzZXRDcmFzaERldGVjdGVkIH1cclxufVxyXG4iXSwibmFtZXMiOlsidXNlRWZmZWN0IiwidXNlUmVmIiwidXNlU3RhdGUiLCJ1c2VDcmFzaERldGVjdGlvbiIsImlzRW5hYmxlZCIsImN1cnJlbnRTcGVlZCIsInBvc2l0aW9uIiwib25DcmFzaERldGVjdGVkIiwiY3Jhc2hEZXRlY3RlZCIsInNldENyYXNoRGV0ZWN0ZWQiLCJsYXN0QWNjZWxlcmF0aW9uIiwieCIsInkiLCJ6IiwibGFzdFJvdGF0aW9uIiwiYWxwaGEiLCJiZXRhIiwiZ2FtbWEiLCJsYXN0VGltZSIsIkRhdGUiLCJub3ciLCJwcmV2aW91c1NwZWVkIiwiYmFzZWxpbmVPcmllbnRhdGlvbiIsImN1cnJlbnQiLCJoYW5kbGVNb3Rpb24iLCJldmVudCIsImFjYyIsImFjY2VsZXJhdGlvbkluY2x1ZGluZ0dyYXZpdHkiLCJ0aW1lRGlmZiIsImplcmtYIiwiTWF0aCIsImFicyIsImplcmtZIiwiamVya1oiLCJ0b3RhbEplcmsiLCJzcXJ0IiwidG90YWxHIiwiaXNIaWdoSW1wYWN0IiwiaXNNZWRpdW1JbXBhY3QiLCJjb25zb2xlIiwibG9nIiwidG9GaXhlZCIsInNwZWVkIiwiZ0ZvcmNlIiwidGltZXN0YW1wIiwiRGV2aWNlTW90aW9uRXZlbnQiLCJyZXF1ZXN0UGVybWlzc2lvbiIsInRoZW4iLCJyZXNwb25zZSIsIndpbmRvdyIsImFkZEV2ZW50TGlzdGVuZXIiLCJjYXRjaCIsImVycm9yIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./hooks/use-crash-detection.ts\n"));

/***/ })

});