"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/dashboard/page",{

/***/ "(app-pages-browser)/./hooks/use-crash-detection.ts":
/*!**************************************!*\
  !*** ./hooks/use-crash-detection.ts ***!
  \**************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useCrashDetection: () => (/* binding */ useCrashDetection)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\nfunction useCrashDetection(isEnabled, currentSpeed, position, onCrashDetected) {\n    const [crashDetected, setCrashDetected] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const lastAcceleration = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        x: 0,\n        y: 0,\n        z: 0\n    });\n    const lastRotation = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        alpha: 0,\n        beta: 0,\n        gamma: 0\n    });\n    const lastTime = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(Date.now());\n    const previousSpeed = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const baselineOrientation = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        alpha: 0,\n        beta: 0,\n        gamma: 0\n    });\n    const impactSamples = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    const audioContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const analyser = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const loudSoundDetected = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const speedHistory = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    const lastCrashTime = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const accelerationPattern = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    const normalDrivingBaseline = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        avgG: 1,\n        maxG: 2\n    });\n    const falsePositiveHistory = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    const userCancelCount = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useCrashDetection.useEffect\": ()=>{\n            previousSpeed.current = currentSpeed;\n            // Track speed history for sudden drop detection\n            speedHistory.current.push(currentSpeed);\n            if (speedHistory.current.length > 10) {\n                speedHistory.current.shift(); // Keep last 10 readings (2 seconds)\n            }\n        }\n    }[\"useCrashDetection.useEffect\"], [\n        currentSpeed\n    ]);\n    // Sound detection setup\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useCrashDetection.useEffect\": ()=>{\n            if (!isEnabled || \"object\" === \"undefined\") return;\n            // Establish normal driving baseline over first 2 minutes\n            const baselineTimer = setTimeout({\n                \"useCrashDetection.useEffect.baselineTimer\": ()=>{\n                    if (accelerationPattern.current.length > 0) {\n                        const avgG = accelerationPattern.current.reduce({\n                            \"useCrashDetection.useEffect.baselineTimer\": (sum, p)=>{\n                                const g = Math.sqrt(p.x ** 2 + p.y ** 2 + p.z ** 2) / 9.8;\n                                return sum + g;\n                            }\n                        }[\"useCrashDetection.useEffect.baselineTimer\"], 0) / accelerationPattern.current.length;\n                        const maxG = Math.max(...accelerationPattern.current.map({\n                            \"useCrashDetection.useEffect.baselineTimer.maxG\": (p)=>Math.sqrt(p.x ** 2 + p.y ** 2 + p.z ** 2) / 9.8\n                        }[\"useCrashDetection.useEffect.baselineTimer.maxG\"]));\n                        normalDrivingBaseline.current = {\n                            avgG,\n                            maxG\n                        };\n                        console.log(\"Baseline established:\", normalDrivingBaseline.current);\n                    }\n                }\n            }[\"useCrashDetection.useEffect.baselineTimer\"], 120000) // 2 minutes\n            ;\n            const setupAudioDetection = {\n                \"useCrashDetection.useEffect.setupAudioDetection\": async ()=>{\n                    try {\n                        const stream = await navigator.mediaDevices.getUserMedia({\n                            audio: true\n                        });\n                        audioContext.current = new (window.AudioContext || window.webkitAudioContext)();\n                        const source = audioContext.current.createMediaStreamSource(stream);\n                        analyser.current = audioContext.current.createAnalyser();\n                        analyser.current.fftSize = 2048;\n                        source.connect(analyser.current);\n                        // Monitor for loud sounds (crash/airbag)\n                        const checkSound = {\n                            \"useCrashDetection.useEffect.setupAudioDetection.checkSound\": ()=>{\n                                if (!analyser.current) return;\n                                const dataArray = new Uint8Array(analyser.current.frequencyBinCount);\n                                analyser.current.getByteFrequencyData(dataArray);\n                                // Calculate average volume\n                                const average = dataArray.reduce({\n                                    \"useCrashDetection.useEffect.setupAudioDetection.checkSound\": (a, b)=>a + b\n                                }[\"useCrashDetection.useEffect.setupAudioDetection.checkSound\"]) / dataArray.length;\n                                // Detect loud sudden sound (>150 threshold = crash/airbag)\n                                if (average > 150) {\n                                    console.log(\"LOUD SOUND DETECTED:\", average);\n                                    loudSoundDetected.current = true;\n                                    setTimeout({\n                                        \"useCrashDetection.useEffect.setupAudioDetection.checkSound\": ()=>{\n                                            loudSoundDetected.current = false;\n                                        }\n                                    }[\"useCrashDetection.useEffect.setupAudioDetection.checkSound\"], 2000); // Reset after 2 seconds\n                                }\n                            }\n                        }[\"useCrashDetection.useEffect.setupAudioDetection.checkSound\"];\n                        setInterval(checkSound, 100); // Check every 100ms\n                    } catch (error) {\n                        console.log(\"Audio detection not available:\", error);\n                    }\n                }\n            }[\"useCrashDetection.useEffect.setupAudioDetection\"];\n            setupAudioDetection();\n            return ({\n                \"useCrashDetection.useEffect\": ()=>{\n                    clearTimeout(baselineTimer);\n                    if (audioContext.current) {\n                        audioContext.current.close();\n                    }\n                }\n            })[\"useCrashDetection.useEffect\"];\n        }\n    }[\"useCrashDetection.useEffect\"], [\n        isEnabled\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useCrashDetection.useEffect\": ()=>{\n            if (!isEnabled || \"object\" === \"undefined\") return;\n            let rotationRate = 0;\n            let hasGyroscope = false;\n            // Handle gyroscope data for rollover detection\n            const handleOrientation = {\n                \"useCrashDetection.useEffect.handleOrientation\": (event)=>{\n                    if (event.alpha === null || event.beta === null || event.gamma === null) return;\n                    hasGyroscope = true;\n                    const now = Date.now();\n                    const timeDiff = (now - lastTime.current) / 1000;\n                    if (timeDiff < 0.1) return;\n                    // Calculate rotation rate (degrees per second)\n                    const alphaChange = Math.abs(event.alpha - lastRotation.current.alpha);\n                    const betaChange = Math.abs(event.beta - lastRotation.current.beta);\n                    const gammaChange = Math.abs(event.gamma - lastRotation.current.gamma);\n                    // Handle 360-degree wraparound for alpha\n                    const normalizedAlphaChange = alphaChange > 180 ? 360 - alphaChange : alphaChange;\n                    rotationRate = Math.sqrt(normalizedAlphaChange ** 2 + betaChange ** 2 + gammaChange ** 2) / timeDiff;\n                    // Detect rollover: extreme rotation (>90 degrees/sec) while moving\n                    if (rotationRate > 90 && previousSpeed.current > 15) {\n                        console.log(\"ROLLOVER DETECTED!\", {\n                            rotationRate: rotationRate.toFixed(2),\n                            speed: previousSpeed.current\n                        });\n                        setCrashDetected(true);\n                        onCrashDetected({\n                            gForce: 0,\n                            timestamp: now,\n                            position,\n                            speed: previousSpeed.current,\n                            crashType: \"rollover\",\n                            rotationRate\n                        });\n                    }\n                    lastRotation.current = {\n                        alpha: event.alpha,\n                        beta: event.beta,\n                        gamma: event.gamma\n                    };\n                }\n            }[\"useCrashDetection.useEffect.handleOrientation\"];\n            const handleMotion = {\n                \"useCrashDetection.useEffect.handleMotion\": (event)=>{\n                    const acc = event.accelerationIncludingGravity;\n                    const rotation = event.rotationRate;\n                    if (!acc || acc.x === null || acc.y === null || acc.z === null) return;\n                    const now = Date.now();\n                    const timeDiff = (now - lastTime.current) / 1000 // seconds\n                    ;\n                    if (timeDiff < 0.1) return; // Ignore too frequent updates\n                    // Calculate jerk (rate of change of acceleration)\n                    const jerkX = Math.abs(acc.x - lastAcceleration.current.x) / timeDiff;\n                    const jerkY = Math.abs(acc.y - lastAcceleration.current.y) / timeDiff;\n                    const jerkZ = Math.abs(acc.z - lastAcceleration.current.z) / timeDiff;\n                    const totalJerk = Math.sqrt(jerkX ** 2 + jerkY ** 2 + jerkZ ** 2);\n                    // Total acceleration magnitude in G's\n                    const totalG = Math.sqrt(acc.x ** 2 + acc.y ** 2 + acc.z ** 2) / 9.8;\n                    // Get gyroscope rotation rate if available\n                    let gyroRotationRate = 0;\n                    if (rotation && rotation.alpha !== null && rotation.beta !== null && rotation.gamma !== null) {\n                        gyroRotationRate = Math.sqrt(rotation.alpha ** 2 + rotation.beta ** 2 + rotation.gamma ** 2);\n                    }\n                    // Calculate speed drop (sudden deceleration)\n                    const speedDrop = speedHistory.current.length >= 2 ? speedHistory.current[0] - speedHistory.current[speedHistory.current.length - 1] : 0;\n                    // Multi-sample verification: Store last 5 impact readings\n                    impactSamples.current.push(totalG);\n                    if (impactSamples.current.length > 5) {\n                        impactSamples.current.shift();\n                    }\n                    // Store acceleration pattern for baseline learning\n                    accelerationPattern.current.push({\n                        x: acc.x,\n                        y: acc.y,\n                        z: acc.z,\n                        timestamp: now\n                    });\n                    if (accelerationPattern.current.length > 1200) {\n                        accelerationPattern.current.shift();\n                    }\n                    // Check if multiple samples show high G-force (reduces false positives)\n                    const highGSamples = impactSamples.current.filter({\n                        \"useCrashDetection.useEffect.handleMotion\": (g)=>g > 2.5\n                    }[\"useCrashDetection.useEffect.handleMotion\"]).length;\n                    const consistentImpact = highGSamples >= 3 // At least 3 out of 5 samples\n                    ;\n                    // Advanced false positive checks\n                    // 1. Baseline comparison: Is this G-force unusual for this user?\n                    const isUnusualForUser = totalG > normalDrivingBaseline.current.maxG * 1.5;\n                    // 2. Pattern analysis: Does acceleration pattern match crash signature?\n                    const recentPattern = accelerationPattern.current.slice(-10) // Last 1 second\n                    ;\n                    const patternVariance = recentPattern.length > 1 ? Math.sqrt(recentPattern.reduce({\n                        \"useCrashDetection.useEffect.handleMotion\": (sum, p, i)=>{\n                            if (i === 0) return 0;\n                            const prev = recentPattern[i - 1];\n                            const diff = Math.sqrt((p.x - prev.x) ** 2 + (p.y - prev.y) ** 2 + (p.z - prev.z) ** 2);\n                            return sum + diff ** 2;\n                        }\n                    }[\"useCrashDetection.useEffect.handleMotion\"], 0) / recentPattern.length) : 0;\n                    const hasErraticPattern = patternVariance > 50 // High variance = crash-like\n                    ;\n                    // 3. Phone orientation check: Is phone mounted or handheld?\n                    const isLikelyMounted = Math.abs(acc.z) > 8 && Math.abs(acc.z) < 12 // Z-axis ~9.8 (gravity)\n                    ;\n                    const phoneMountedBonus = isLikelyMounted ? 10 : 0;\n                    // 4. Time-of-day adjustment: More cautious at night\n                    const hour = new Date().getHours();\n                    const isNightTime = hour >= 22 || hour <= 6;\n                    const nightTimeAdjustment = isNightTime ? -5 : 0 // Slightly lower threshold at night\n                    ;\n                    // 5. Recent false positive learning\n                    const recentFalsePositives = falsePositiveHistory.current.filter({\n                        \"useCrashDetection.useEffect.handleMotion\": (fp)=>now - fp.timestamp < 3600000 // Last hour\n                    }[\"useCrashDetection.useEffect.handleMotion\"]).length;\n                    const falsePositivePenalty = recentFalsePositives * 5 // -5 points per recent FP\n                    ;\n                    // 6. GPS accuracy check: Is GPS reliable?\n                    const gpsAccuracyBonus = position && position.accuracy && position.accuracy < 20 ? 5 : 0;\n                    // Determine crash type based on acceleration direction\n                    let crashType = \"unknown\";\n                    const dominantAxis = Math.max(Math.abs(acc.x), Math.abs(acc.y), Math.abs(acc.z));\n                    if (Math.abs(acc.y) === dominantAxis) {\n                        crashType = acc.y > 0 ? \"frontal\" : \"rear\";\n                    } else if (Math.abs(acc.x) === dominantAxis) {\n                        crashType = \"side\";\n                    } else if (gyroRotationRate > 5 || rotationRate > 60) {\n                        crashType = \"rollover\";\n                    }\n                    // Calculate confidence score (0-100%)\n                    let confidence = 0;\n                    let confidenceFactors = 0;\n                    // Factor 1: G-force strength (max 25 points)\n                    if (totalG > 4) confidence += 25;\n                    else if (totalG > 3) confidence += 18;\n                    else if (totalG > 2.5) confidence += 10;\n                    confidenceFactors++;\n                    // Factor 2: Jerk magnitude (max 20 points)\n                    if (totalJerk > 40) confidence += 20;\n                    else if (totalJerk > 30) confidence += 12;\n                    else if (totalJerk > 20) confidence += 8;\n                    confidenceFactors++;\n                    // Factor 3: Speed check (max 15 points)\n                    if (previousSpeed.current > 30) confidence += 15;\n                    else if (previousSpeed.current > 20) confidence += 10;\n                    else if (previousSpeed.current > 15) confidence += 5;\n                    confidenceFactors++;\n                    // Factor 4: Sound detection (max 12 points)\n                    if (loudSoundDetected.current) confidence += 12;\n                    confidenceFactors++;\n                    // Factor 5: Speed drop (max 10 points)\n                    if (speedDrop > 20) confidence += 10;\n                    else if (speedDrop > 10) confidence += 5;\n                    confidenceFactors++;\n                    // Factor 6: Multi-sample consistency (max 8 points)\n                    if (consistentImpact) confidence += 8;\n                    confidenceFactors++;\n                    // Factor 7: Unusual for user baseline (max 5 points) ✨ NEW\n                    if (isUnusualForUser) confidence += 5;\n                    confidenceFactors++;\n                    // Factor 8: Erratic pattern (max 5 points) ✨ NEW\n                    if (hasErraticPattern) confidence += 5;\n                    confidenceFactors++;\n                    // Apply bonuses and penalties\n                    confidence += phoneMountedBonus; // +10 if phone mounted\n                    confidence += nightTimeAdjustment; // -5 at night (more cautious)\n                    confidence -= falsePositivePenalty; // -5 per recent false positive\n                    confidence += gpsAccuracyBonus; // +5 if GPS accurate\n                    // Cap at 100\n                    confidence = Math.min(100, Math.max(0, confidence));\n                    // Enhanced crash detection criteria with confidence scoring\n                    const isHighImpact = totalG > 4 && totalJerk > 40 && previousSpeed.current > 20;\n                    const isMediumImpact = totalG > 3 && totalJerk > 30 && previousSpeed.current > 15;\n                    const isRollover = (gyroRotationRate > 5 || rotationRate > 60) && previousSpeed.current > 15;\n                    const isConfidentCrash = confidence >= 65 && consistentImpact && previousSpeed.current > 15 // Raised from 60 to 65\n                    ;\n                    // Prevent duplicate detections (cooldown period)\n                    const timeSinceLastCrash = now - lastCrashTime.current;\n                    const cooldownPeriod = 10000 // 10 seconds\n                    ;\n                    if (timeSinceLastCrash < cooldownPeriod) {\n                        // Skip detection during cooldown\n                        lastAcceleration.current = {\n                            x: acc.x,\n                            y: acc.y,\n                            z: acc.z\n                        };\n                        lastTime.current = now;\n                        return;\n                    }\n                    if (isHighImpact || isMediumImpact || isRollover || isConfidentCrash) {\n                        console.log(\"CRASH DETECTED!\", {\n                            totalG: totalG.toFixed(2),\n                            totalJerk: totalJerk.toFixed(2),\n                            speed: previousSpeed.current,\n                            speedDrop: speedDrop.toFixed(1),\n                            crashType,\n                            rotationRate: (gyroRotationRate || rotationRate).toFixed(2),\n                            soundDetected: loudSoundDetected.current,\n                            confidence: confidence.toFixed(0) + \"%\",\n                            consistentImpact,\n                            isUnusualForUser,\n                            hasErraticPattern,\n                            phoneMounted: isLikelyMounted,\n                            gpsAccurate: position && position.accuracy < 20\n                        });\n                        lastCrashTime.current = now;\n                        setCrashDetected(true);\n                        onCrashDetected({\n                            gForce: totalG,\n                            timestamp: now,\n                            position,\n                            speed: previousSpeed.current,\n                            crashType,\n                            rotationRate: gyroRotationRate || rotationRate,\n                            speedDrop,\n                            soundDetected: loudSoundDetected.current,\n                            confidence\n                        });\n                    }\n                    lastAcceleration.current = {\n                        x: acc.x,\n                        y: acc.y,\n                        z: acc.z\n                    };\n                    lastTime.current = now;\n                }\n            }[\"useCrashDetection.useEffect.handleMotion\"];\n            // Function to record false positive (called when user cancels)\n            const recordFalsePositive = {\n                \"useCrashDetection.useEffect.recordFalsePositive\": (reason)=>{\n                    falsePositiveHistory.current.push({\n                        timestamp: Date.now(),\n                        reason\n                    });\n                    userCancelCount.current++;\n                    // Adjust thresholds if too many false positives\n                    if (userCancelCount.current >= 3) {\n                        console.log(\"Adjusting detection sensitivity due to false positives\");\n                    // Could dynamically adjust thresholds here\n                    }\n                }\n            }[\"useCrashDetection.useEffect.recordFalsePositive\"];\n            // Expose recordFalsePositive for external use\n            if (true) {\n                window.recordCrashFalsePositive = recordFalsePositive;\n            }\n            // Request permission for motion sensors (iOS 13+)\n            if (typeof DeviceMotionEvent !== \"undefined\" && typeof DeviceMotionEvent.requestPermission === \"function\") {\n                ;\n                DeviceMotionEvent.requestPermission().then({\n                    \"useCrashDetection.useEffect\": (response)=>{\n                        if (response === \"granted\") {\n                            window.addEventListener(\"devicemotion\", handleMotion);\n                            window.addEventListener(\"deviceorientation\", handleOrientation);\n                        }\n                    }\n                }[\"useCrashDetection.useEffect\"]).catch({\n                    \"useCrashDetection.useEffect\": (error)=>{\n                        console.error(\"Motion permission denied:\", error);\n                    }\n                }[\"useCrashDetection.useEffect\"]);\n            } else {\n                // Android or older iOS\n                window.addEventListener(\"devicemotion\", handleMotion);\n                window.addEventListener(\"deviceorientation\", handleOrientation);\n            }\n            return ({\n                \"useCrashDetection.useEffect\": ()=>{\n                    window.removeEventListener(\"devicemotion\", handleMotion);\n                    window.removeEventListener(\"deviceorientation\", handleOrientation);\n                }\n            })[\"useCrashDetection.useEffect\"];\n        }\n    }[\"useCrashDetection.useEffect\"], [\n        isEnabled,\n        position,\n        onCrashDetected\n    ]);\n    return {\n        crashDetected,\n        setCrashDetected\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2hvb2tzL3VzZS1jcmFzaC1kZXRlY3Rpb24udHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQW1EO0FBYzVDLFNBQVNHLGtCQUNkQyxTQUFrQixFQUNsQkMsWUFBb0IsRUFDcEJDLFFBQTZDLEVBQzdDQyxlQUEwQztJQUUxQyxNQUFNLENBQUNDLGVBQWVDLGlCQUFpQixHQUFHUCwrQ0FBUUEsQ0FBQztJQUNuRCxNQUFNUSxtQkFBbUJULDZDQUFNQSxDQUFDO1FBQUVVLEdBQUc7UUFBR0MsR0FBRztRQUFHQyxHQUFHO0lBQUU7SUFDbkQsTUFBTUMsZUFBZWIsNkNBQU1BLENBQUM7UUFBRWMsT0FBTztRQUFHQyxNQUFNO1FBQUdDLE9BQU87SUFBRTtJQUMxRCxNQUFNQyxXQUFXakIsNkNBQU1BLENBQUNrQixLQUFLQyxHQUFHO0lBQ2hDLE1BQU1DLGdCQUFnQnBCLDZDQUFNQSxDQUFDO0lBQzdCLE1BQU1xQixzQkFBc0JyQiw2Q0FBTUEsQ0FBQztRQUFFYyxPQUFPO1FBQUdDLE1BQU07UUFBR0MsT0FBTztJQUFFO0lBQ2pFLE1BQU1NLGdCQUFnQnRCLDZDQUFNQSxDQUFXLEVBQUU7SUFDekMsTUFBTXVCLGVBQWV2Qiw2Q0FBTUEsQ0FBc0I7SUFDakQsTUFBTXdCLFdBQVd4Qiw2Q0FBTUEsQ0FBc0I7SUFDN0MsTUFBTXlCLG9CQUFvQnpCLDZDQUFNQSxDQUFDO0lBQ2pDLE1BQU0wQixlQUFlMUIsNkNBQU1BLENBQVcsRUFBRTtJQUN4QyxNQUFNMkIsZ0JBQWdCM0IsNkNBQU1BLENBQUM7SUFDN0IsTUFBTTRCLHNCQUFzQjVCLDZDQUFNQSxDQUEyRCxFQUFFO0lBQy9GLE1BQU02Qix3QkFBd0I3Qiw2Q0FBTUEsQ0FBQztRQUFFOEIsTUFBTTtRQUFHQyxNQUFNO0lBQUU7SUFDeEQsTUFBTUMsdUJBQXVCaEMsNkNBQU1BLENBQTBDLEVBQUU7SUFDL0UsTUFBTWlDLGtCQUFrQmpDLDZDQUFNQSxDQUFDO0lBRS9CRCxnREFBU0E7dUNBQUM7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LENBQUN4RTt3QkFDTnpCLFFBQVF5QixLQUFLLENBQUMsNkJBQTZCQTtvQkFDN0M7O1lBQ0osT0FBTztnQkFDTCx1QkFBdUI7Z0JBQ3ZCakIsT0FBT3dGLGdCQUFnQixDQUFDLGdCQUFnQnJEO2dCQUN4Q25DLE9BQU93RixnQkFBZ0IsQ0FBQyxxQkFBcUJsRTtZQUMvQztZQUVBOytDQUFPO29CQUNMdEIsT0FBTzBGLG1CQUFtQixDQUFDLGdCQUFnQnZEO29CQUMzQ25DLE9BQU8wRixtQkFBbUIsQ0FBQyxxQkFBcUJwRTtnQkFDbEQ7O1FBQ0Y7c0NBQUc7UUFBQzNFO1FBQVdFO1FBQVVDO0tBQWdCO0lBRXpDLE9BQU87UUFBRUM7UUFBZUM7SUFBaUI7QUFDM0MiLCJzb3VyY2VzIjpbIkQ6XFxzbWFydHNhZmVcXHNtYXJ0LWFjY2lkZW50LXNhZmV0eVxcaG9va3NcXHVzZS1jcmFzaC1kZXRlY3Rpb24udHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZVN0YXRlIH0gZnJvbSBcInJlYWN0XCJcclxuXHJcbmludGVyZmFjZSBDcmFzaERhdGEge1xyXG4gIGdGb3JjZTogbnVtYmVyXHJcbiAgdGltZXN0YW1wOiBudW1iZXJcclxuICBwb3NpdGlvbjogeyBsYXQ6IG51bWJlcjsgbG5nOiBudW1iZXIgfSB8IG51bGxcclxuICBzcGVlZDogbnVtYmVyXHJcbiAgY3Jhc2hUeXBlPzogXCJmcm9udGFsXCIgfCBcInNpZGVcIiB8IFwicmVhclwiIHwgXCJyb2xsb3ZlclwiIHwgXCJ1bmtub3duXCJcclxuICByb3RhdGlvblJhdGU/OiBudW1iZXJcclxuICBzcGVlZERyb3A/OiBudW1iZXJcclxuICBzb3VuZERldGVjdGVkPzogYm9vbGVhblxyXG4gIGNvbmZpZGVuY2U/OiBudW1iZXJcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUNyYXNoRGV0ZWN0aW9uKFxyXG4gIGlzRW5hYmxlZDogYm9vbGVhbixcclxuICBjdXJyZW50U3BlZWQ6IG51bWJlcixcclxuICBwb3NpdGlvbjogeyBsYXQ6IG51bWJlcjsgbG5nOiBudW1iZXIgfSB8IG51bGwsXHJcbiAgb25DcmFzaERldGVjdGVkOiAoZGF0YTogQ3Jhc2hEYXRhKSA9PiB2b2lkXHJcbikge1xyXG4gIGNvbnN0IFtjcmFzaERldGVjdGVkLCBzZXRDcmFzaERldGVjdGVkXSA9IHVzZVN0YXRlKGZhbHNlKVxyXG4gIGNvbnN0IGxhc3RBY2NlbGVyYXRpb24gPSB1c2VSZWYoeyB4OiAwLCB5OiAwLCB6OiAwIH0pXHJcbiAgY29uc3QgbGFzdFJvdGF0aW9uID0gdXNlUmVmKHsgYWxwaGE6IDAsIGJldGE6IDAsIGdhbW1hOiAwIH0pXHJcbiAgY29uc3QgbGFzdFRpbWUgPSB1c2VSZWYoRGF0ZS5ub3coKSlcclxuICBjb25zdCBwcmV2aW91c1NwZWVkID0gdXNlUmVmKDApXHJcbiAgY29uc3QgYmFzZWxpbmVPcmllbnRhdGlvbiA9IHVzZVJlZih7IGFscGhhOiAwLCBiZXRhOiAwLCBnYW1tYTogMCB9KVxyXG4gIGNvbnN0IGltcGFjdFNhbXBsZXMgPSB1c2VSZWY8bnVtYmVyW10+KFtdKVxyXG4gIGNvbnN0IGF1ZGlvQ29udGV4dCA9IHVzZVJlZjxBdWRpb0NvbnRleHQgfCBudWxsPihudWxsKVxyXG4gIGNvbnN0IGFuYWx5c2VyID0gdXNlUmVmPEFuYWx5c2VyTm9kZSB8IG51bGw+KG51bGwpXHJcbiAgY29uc3QgbG91ZFNvdW5kRGV0ZWN0ZWQgPSB1c2VSZWYoZmFsc2UpXHJcbiAgY29uc3Qgc3BlZWRIaXN0b3J5ID0gdXNlUmVmPG51bWJlcltdPihbXSlcclxuICBjb25zdCBsYXN0Q3Jhc2hUaW1lID0gdXNlUmVmKDApXHJcbiAgY29uc3QgYWNjZWxlcmF0aW9uUGF0dGVybiA9IHVzZVJlZjx7IHg6IG51bWJlcjsgeTogbnVtYmVyOyB6OiBudW1iZXI7IHRpbWVzdGFtcDogbnVtYmVyIH1bXT4oW10pXHJcbiAgY29uc3Qgbm9ybWFsRHJpdmluZ0Jhc2VsaW5lID0gdXNlUmVmKHsgYXZnRzogMSwgbWF4RzogMiB9KVxyXG4gIGNvbnN0IGZhbHNlUG9zaXRpdmVIaXN0b3J5ID0gdXNlUmVmPHsgdGltZXN0YW1wOiBudW1iZXI7IHJlYXNvbjogc3RyaW5nIH1bXT4oW10pXHJcbiAgY29uc3QgdXNlckNhbmNlbENvdW50ID0gdXNlUmVmKDApXHJcblxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBwcmV2aW91c1NwZWVkLmN1cnJlbnQgPSBjdXJyZW50U3BlZWRcclxuICAgIFxyXG4gICAgLy8gVHJhY2sgc3BlZWQgaGlzdG9yeSBmb3Igc3VkZGVuIGRyb3AgZGV0ZWN0aW9uXHJcbiAgICBzcGVlZEhpc3RvcnkuY3VycmVudC5wdXNoKGN1cnJlbnRTcGVlZClcclxuICAgIGlmIChzcGVlZEhpc3RvcnkuY3VycmVudC5sZW5ndGggPiAxMCkge1xyXG4gICAgICBzcGVlZEhpc3RvcnkuY3VycmVudC5zaGlmdCgpIC8vIEtlZXAgbGFzdCAxMCByZWFkaW5ncyAoMiBzZWNvbmRzKVxyXG4gICAgfVxyXG4gIH0sIFtjdXJyZW50U3BlZWRdKVxyXG5cclxuICAvLyBTb3VuZCBkZXRlY3Rpb24gc2V0dXBcclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgaWYgKCFpc0VuYWJsZWQgfHwgdHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuXHJcblxyXG4gICAgLy8gRXN0YWJsaXNoIG5vcm1hbCBkcml2aW5nIGJhc2VsaW5lIG92ZXIgZmlyc3QgMiBtaW51dGVzXHJcbiAgICBjb25zdCBiYXNlbGluZVRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgIGlmIChhY2NlbGVyYXRpb25QYXR0ZXJuLmN1cnJlbnQubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIGNvbnN0IGF2Z0cgPSBhY2NlbGVyYXRpb25QYXR0ZXJuLmN1cnJlbnQucmVkdWNlKChzdW0sIHApID0+IHtcclxuICAgICAgICAgIGNvbnN0IGcgPSBNYXRoLnNxcnQocC54ICoqIDIgKyBwLnkgKiogMiArIHAueiAqKiAyKSAvIDkuOFxyXG4gICAgICAgICAgcmV0dXJuIHN1bSArIGdcclxuICAgICAgICB9LCAwKSAvIGFjY2VsZXJhdGlvblBhdHRlcm4uY3VycmVudC5sZW5ndGhcclxuXHJcbiAgICAgICAgY29uc3QgbWF4RyA9IE1hdGgubWF4KC4uLmFjY2VsZXJhdGlvblBhdHRlcm4uY3VycmVudC5tYXAocCA9PiBcclxuICAgICAgICAgIE1hdGguc3FydChwLnggKiogMiArIHAueSAqKiAyICsgcC56ICoqIDIpIC8gOS44XHJcbiAgICAgICAgKSlcclxuXHJcbiAgICAgICAgbm9ybWFsRHJpdmluZ0Jhc2VsaW5lLmN1cnJlbnQgPSB7IGF2Z0csIG1heEcgfVxyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiQmFzZWxpbmUgZXN0YWJsaXNoZWQ6XCIsIG5vcm1hbERyaXZpbmdCYXNlbGluZS5jdXJyZW50KVxyXG4gICAgICB9XHJcbiAgICB9LCAxMjAwMDApIC8vIDIgbWludXRlc1xyXG5cclxuICAgIGNvbnN0IHNldHVwQXVkaW9EZXRlY3Rpb24gPSBhc3luYyAoKSA9PiB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3Qgc3RyZWFtID0gYXdhaXQgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoeyBhdWRpbzogdHJ1ZSB9KVxyXG4gICAgICAgIGF1ZGlvQ29udGV4dC5jdXJyZW50ID0gbmV3ICh3aW5kb3cuQXVkaW9Db250ZXh0IHx8ICh3aW5kb3cgYXMgYW55KS53ZWJraXRBdWRpb0NvbnRleHQpKClcclxuICAgICAgICBjb25zdCBzb3VyY2UgPSBhdWRpb0NvbnRleHQuY3VycmVudC5jcmVhdGVNZWRpYVN0cmVhbVNvdXJjZShzdHJlYW0pXHJcbiAgICAgICAgYW5hbHlzZXIuY3VycmVudCA9IGF1ZGlvQ29udGV4dC5jdXJyZW50LmNyZWF0ZUFuYWx5c2VyKClcclxuICAgICAgICBhbmFseXNlci5jdXJyZW50LmZmdFNpemUgPSAyMDQ4XHJcbiAgICAgICAgc291cmNlLmNvbm5lY3QoYW5hbHlzZXIuY3VycmVudClcclxuXHJcbiAgICAgICAgLy8gTW9uaXRvciBmb3IgbG91ZCBzb3VuZHMgKGNyYXNoL2FpcmJhZylcclxuICAgICAgICBjb25zdCBjaGVja1NvdW5kID0gKCkgPT4ge1xyXG4gICAgICAgICAgaWYgKCFhbmFseXNlci5jdXJyZW50KSByZXR1cm5cclxuXHJcbiAgICAgICAgICBjb25zdCBkYXRhQXJyYXkgPSBuZXcgVWludDhBcnJheShhbmFseXNlci5jdXJyZW50LmZyZXF1ZW5jeUJpbkNvdW50KVxyXG4gICAgICAgICAgYW5hbHlzZXIuY3VycmVudC5nZXRCeXRlRnJlcXVlbmN5RGF0YShkYXRhQXJyYXkpXHJcblxyXG4gICAgICAgICAgLy8gQ2FsY3VsYXRlIGF2ZXJhZ2Ugdm9sdW1lXHJcbiAgICAgICAgICBjb25zdCBhdmVyYWdlID0gZGF0YUFycmF5LnJlZHVjZSgoYSwgYikgPT4gYSArIGIpIC8gZGF0YUFycmF5Lmxlbmd0aFxyXG5cclxuICAgICAgICAgIC8vIERldGVjdCBsb3VkIHN1ZGRlbiBzb3VuZCAoPjE1MCB0aHJlc2hvbGQgPSBjcmFzaC9haXJiYWcpXHJcbiAgICAgICAgICBpZiAoYXZlcmFnZSA+IDE1MCkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIkxPVUQgU09VTkQgREVURUNURUQ6XCIsIGF2ZXJhZ2UpXHJcbiAgICAgICAgICAgIGxvdWRTb3VuZERldGVjdGVkLmN1cnJlbnQgPSB0cnVlXHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgIGxvdWRTb3VuZERldGVjdGVkLmN1cnJlbnQgPSBmYWxzZVxyXG4gICAgICAgICAgICB9LCAyMDAwKSAvLyBSZXNldCBhZnRlciAyIHNlY29uZHNcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHNldEludGVydmFsKGNoZWNrU291bmQsIDEwMCkgLy8gQ2hlY2sgZXZlcnkgMTAwbXNcclxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhcIkF1ZGlvIGRldGVjdGlvbiBub3QgYXZhaWxhYmxlOlwiLCBlcnJvcilcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHNldHVwQXVkaW9EZXRlY3Rpb24oKVxyXG5cclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgIGNsZWFyVGltZW91dChiYXNlbGluZVRpbWVyKVxyXG4gICAgICBpZiAoYXVkaW9Db250ZXh0LmN1cnJlbnQpIHtcclxuICAgICAgICBhdWRpb0NvbnRleHQuY3VycmVudC5jbG9zZSgpXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9LCBbaXNFbmFibGVkXSlcclxuXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGlmICghaXNFbmFibGVkIHx8IHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHJldHVyblxyXG5cclxuICAgIGxldCByb3RhdGlvblJhdGUgPSAwXHJcbiAgICBsZXQgaGFzR3lyb3Njb3BlID0gZmFsc2VcclxuXHJcbiAgICAvLyBIYW5kbGUgZ3lyb3Njb3BlIGRhdGEgZm9yIHJvbGxvdmVyIGRldGVjdGlvblxyXG4gICAgY29uc3QgaGFuZGxlT3JpZW50YXRpb24gPSAoZXZlbnQ6IERldmljZU9yaWVudGF0aW9uRXZlbnQpID0+IHtcclxuICAgICAgaWYgKGV2ZW50LmFscGhhID09PSBudWxsIHx8IGV2ZW50LmJldGEgPT09IG51bGwgfHwgZXZlbnQuZ2FtbWEgPT09IG51bGwpIHJldHVyblxyXG4gICAgICBcclxuICAgICAgaGFzR3lyb3Njb3BlID0gdHJ1ZVxyXG4gICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpXHJcbiAgICAgIGNvbnN0IHRpbWVEaWZmID0gKG5vdyAtIGxhc3RUaW1lLmN1cnJlbnQpIC8gMTAwMFxyXG5cclxuICAgICAgaWYgKHRpbWVEaWZmIDwgMC4xKSByZXR1cm5cclxuXHJcbiAgICAgIC8vIENhbGN1bGF0ZSByb3RhdGlvbiByYXRlIChkZWdyZWVzIHBlciBzZWNvbmQpXHJcbiAgICAgIGNvbnN0IGFscGhhQ2hhbmdlID0gTWF0aC5hYnMoZXZlbnQuYWxwaGEgLSBsYXN0Um90YXRpb24uY3VycmVudC5hbHBoYSlcclxuICAgICAgY29uc3QgYmV0YUNoYW5nZSA9IE1hdGguYWJzKGV2ZW50LmJldGEgLSBsYXN0Um90YXRpb24uY3VycmVudC5iZXRhKVxyXG4gICAgICBjb25zdCBnYW1tYUNoYW5nZSA9IE1hdGguYWJzKGV2ZW50LmdhbW1hIC0gbGFzdFJvdGF0aW9uLmN1cnJlbnQuZ2FtbWEpXHJcblxyXG4gICAgICAvLyBIYW5kbGUgMzYwLWRlZ3JlZSB3cmFwYXJvdW5kIGZvciBhbHBoYVxyXG4gICAgICBjb25zdCBub3JtYWxpemVkQWxwaGFDaGFuZ2UgPSBhbHBoYUNoYW5nZSA+IDE4MCA/IDM2MCAtIGFscGhhQ2hhbmdlIDogYWxwaGFDaGFuZ2VcclxuXHJcbiAgICAgIHJvdGF0aW9uUmF0ZSA9IE1hdGguc3FydChcclxuICAgICAgICBub3JtYWxpemVkQWxwaGFDaGFuZ2UgKiogMiArIGJldGFDaGFuZ2UgKiogMiArIGdhbW1hQ2hhbmdlICoqIDJcclxuICAgICAgKSAvIHRpbWVEaWZmXHJcblxyXG4gICAgICAvLyBEZXRlY3Qgcm9sbG92ZXI6IGV4dHJlbWUgcm90YXRpb24gKD45MCBkZWdyZWVzL3NlYykgd2hpbGUgbW92aW5nXHJcbiAgICAgIGlmIChyb3RhdGlvblJhdGUgPiA5MCAmJiBwcmV2aW91c1NwZWVkLmN1cnJlbnQgPiAxNSkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiUk9MTE9WRVIgREVURUNURUQhXCIsIHtcclxuICAgICAgICAgIHJvdGF0aW9uUmF0ZTogcm90YXRpb25SYXRlLnRvRml4ZWQoMiksXHJcbiAgICAgICAgICBzcGVlZDogcHJldmlvdXNTcGVlZC5jdXJyZW50LFxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgICAgIHNldENyYXNoRGV0ZWN0ZWQodHJ1ZSlcclxuICAgICAgICBvbkNyYXNoRGV0ZWN0ZWQoe1xyXG4gICAgICAgICAgZ0ZvcmNlOiAwLFxyXG4gICAgICAgICAgdGltZXN0YW1wOiBub3csXHJcbiAgICAgICAgICBwb3NpdGlvbixcclxuICAgICAgICAgIHNwZWVkOiBwcmV2aW91c1NwZWVkLmN1cnJlbnQsXHJcbiAgICAgICAgICBjcmFzaFR5cGU6IFwicm9sbG92ZXJcIixcclxuICAgICAgICAgIHJvdGF0aW9uUmF0ZSxcclxuICAgICAgICB9KVxyXG4gICAgICB9XHJcblxyXG4gICAgICBsYXN0Um90YXRpb24uY3VycmVudCA9IHsgYWxwaGE6IGV2ZW50LmFscGhhLCBiZXRhOiBldmVudC5iZXRhLCBnYW1tYTogZXZlbnQuZ2FtbWEgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGhhbmRsZU1vdGlvbiA9IChldmVudDogRGV2aWNlTW90aW9uRXZlbnQpID0+IHtcclxuICAgICAgY29uc3QgYWNjID0gZXZlbnQuYWNjZWxlcmF0aW9uSW5jbHVkaW5nR3Jhdml0eVxyXG4gICAgICBjb25zdCByb3RhdGlvbiA9IGV2ZW50LnJvdGF0aW9uUmF0ZVxyXG4gICAgICBcclxuICAgICAgaWYgKCFhY2MgfHwgYWNjLnggPT09IG51bGwgfHwgYWNjLnkgPT09IG51bGwgfHwgYWNjLnogPT09IG51bGwpIHJldHVyblxyXG5cclxuICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKVxyXG4gICAgICBjb25zdCB0aW1lRGlmZiA9IChub3cgLSBsYXN0VGltZS5jdXJyZW50KSAvIDEwMDAgLy8gc2Vjb25kc1xyXG5cclxuICAgICAgaWYgKHRpbWVEaWZmIDwgMC4xKSByZXR1cm4gLy8gSWdub3JlIHRvbyBmcmVxdWVudCB1cGRhdGVzXHJcblxyXG4gICAgICAvLyBDYWxjdWxhdGUgamVyayAocmF0ZSBvZiBjaGFuZ2Ugb2YgYWNjZWxlcmF0aW9uKVxyXG4gICAgICBjb25zdCBqZXJrWCA9IE1hdGguYWJzKGFjYy54IC0gbGFzdEFjY2VsZXJhdGlvbi5jdXJyZW50LngpIC8gdGltZURpZmZcclxuICAgICAgY29uc3QgamVya1kgPSBNYXRoLmFicyhhY2MueSAtIGxhc3RBY2NlbGVyYXRpb24uY3VycmVudC55KSAvIHRpbWVEaWZmXHJcbiAgICAgIGNvbnN0IGplcmtaID0gTWF0aC5hYnMoYWNjLnogLSBsYXN0QWNjZWxlcmF0aW9uLmN1cnJlbnQueikgLyB0aW1lRGlmZlxyXG5cclxuICAgICAgY29uc3QgdG90YWxKZXJrID0gTWF0aC5zcXJ0KGplcmtYICoqIDIgKyBqZXJrWSAqKiAyICsgamVya1ogKiogMilcclxuXHJcbiAgICAgIC8vIFRvdGFsIGFjY2VsZXJhdGlvbiBtYWduaXR1ZGUgaW4gRydzXHJcbiAgICAgIGNvbnN0IHRvdGFsRyA9IE1hdGguc3FydChhY2MueCAqKiAyICsgYWNjLnkgKiogMiArIGFjYy56ICoqIDIpIC8gOS44XHJcblxyXG4gICAgICAvLyBHZXQgZ3lyb3Njb3BlIHJvdGF0aW9uIHJhdGUgaWYgYXZhaWxhYmxlXHJcbiAgICAgIGxldCBneXJvUm90YXRpb25SYXRlID0gMFxyXG4gICAgICBpZiAocm90YXRpb24gJiYgcm90YXRpb24uYWxwaGEgIT09IG51bGwgJiYgcm90YXRpb24uYmV0YSAhPT0gbnVsbCAmJiByb3RhdGlvbi5nYW1tYSAhPT0gbnVsbCkge1xyXG4gICAgICAgIGd5cm9Sb3RhdGlvblJhdGUgPSBNYXRoLnNxcnQoXHJcbiAgICAgICAgICByb3RhdGlvbi5hbHBoYSAqKiAyICsgcm90YXRpb24uYmV0YSAqKiAyICsgcm90YXRpb24uZ2FtbWEgKiogMlxyXG4gICAgICAgIClcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQ2FsY3VsYXRlIHNwZWVkIGRyb3AgKHN1ZGRlbiBkZWNlbGVyYXRpb24pXHJcbiAgICAgIGNvbnN0IHNwZWVkRHJvcCA9IHNwZWVkSGlzdG9yeS5jdXJyZW50Lmxlbmd0aCA+PSAyXHJcbiAgICAgICAgPyBzcGVlZEhpc3RvcnkuY3VycmVudFswXSAtIHNwZWVkSGlzdG9yeS5jdXJyZW50W3NwZWVkSGlzdG9yeS5jdXJyZW50Lmxlbmd0aCAtIDFdXHJcbiAgICAgICAgOiAwXHJcblxyXG4gICAgICAvLyBNdWx0aS1zYW1wbGUgdmVyaWZpY2F0aW9uOiBTdG9yZSBsYXN0IDUgaW1wYWN0IHJlYWRpbmdzXHJcbiAgICAgIGltcGFjdFNhbXBsZXMuY3VycmVudC5wdXNoKHRvdGFsRylcclxuICAgICAgaWYgKGltcGFjdFNhbXBsZXMuY3VycmVudC5sZW5ndGggPiA1KSB7XHJcbiAgICAgICAgaW1wYWN0U2FtcGxlcy5jdXJyZW50LnNoaWZ0KClcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gU3RvcmUgYWNjZWxlcmF0aW9uIHBhdHRlcm4gZm9yIGJhc2VsaW5lIGxlYXJuaW5nXHJcbiAgICAgIGFjY2VsZXJhdGlvblBhdHRlcm4uY3VycmVudC5wdXNoKHsgeDogYWNjLngsIHk6IGFjYy55LCB6OiBhY2MueiwgdGltZXN0YW1wOiBub3cgfSlcclxuICAgICAgaWYgKGFjY2VsZXJhdGlvblBhdHRlcm4uY3VycmVudC5sZW5ndGggPiAxMjAwKSB7IC8vIEtlZXAgbGFzdCAyIG1pbnV0ZXNcclxuICAgICAgICBhY2NlbGVyYXRpb25QYXR0ZXJuLmN1cnJlbnQuc2hpZnQoKVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBDaGVjayBpZiBtdWx0aXBsZSBzYW1wbGVzIHNob3cgaGlnaCBHLWZvcmNlIChyZWR1Y2VzIGZhbHNlIHBvc2l0aXZlcylcclxuICAgICAgY29uc3QgaGlnaEdTYW1wbGVzID0gaW1wYWN0U2FtcGxlcy5jdXJyZW50LmZpbHRlcihnID0+IGcgPiAyLjUpLmxlbmd0aFxyXG4gICAgICBjb25zdCBjb25zaXN0ZW50SW1wYWN0ID0gaGlnaEdTYW1wbGVzID49IDMgLy8gQXQgbGVhc3QgMyBvdXQgb2YgNSBzYW1wbGVzXHJcblxyXG4gICAgICAvLyBBZHZhbmNlZCBmYWxzZSBwb3NpdGl2ZSBjaGVja3NcclxuICAgICAgXHJcbiAgICAgIC8vIDEuIEJhc2VsaW5lIGNvbXBhcmlzb246IElzIHRoaXMgRy1mb3JjZSB1bnVzdWFsIGZvciB0aGlzIHVzZXI/XHJcbiAgICAgIGNvbnN0IGlzVW51c3VhbEZvclVzZXIgPSB0b3RhbEcgPiAobm9ybWFsRHJpdmluZ0Jhc2VsaW5lLmN1cnJlbnQubWF4RyAqIDEuNSlcclxuICAgICAgXHJcbiAgICAgIC8vIDIuIFBhdHRlcm4gYW5hbHlzaXM6IERvZXMgYWNjZWxlcmF0aW9uIHBhdHRlcm4gbWF0Y2ggY3Jhc2ggc2lnbmF0dXJlP1xyXG4gICAgICBjb25zdCByZWNlbnRQYXR0ZXJuID0gYWNjZWxlcmF0aW9uUGF0dGVybi5jdXJyZW50LnNsaWNlKC0xMCkgLy8gTGFzdCAxIHNlY29uZFxyXG4gICAgICBjb25zdCBwYXR0ZXJuVmFyaWFuY2UgPSByZWNlbnRQYXR0ZXJuLmxlbmd0aCA+IDEgPyBcclxuICAgICAgICBNYXRoLnNxcnQocmVjZW50UGF0dGVybi5yZWR1Y2UoKHN1bSwgcCwgaSkgPT4ge1xyXG4gICAgICAgICAgaWYgKGkgPT09IDApIHJldHVybiAwXHJcbiAgICAgICAgICBjb25zdCBwcmV2ID0gcmVjZW50UGF0dGVybltpIC0gMV1cclxuICAgICAgICAgIGNvbnN0IGRpZmYgPSBNYXRoLnNxcnQoXHJcbiAgICAgICAgICAgIChwLnggLSBwcmV2LngpICoqIDIgKyAocC55IC0gcHJldi55KSAqKiAyICsgKHAueiAtIHByZXYueikgKiogMlxyXG4gICAgICAgICAgKVxyXG4gICAgICAgICAgcmV0dXJuIHN1bSArIGRpZmYgKiogMlxyXG4gICAgICAgIH0sIDApIC8gcmVjZW50UGF0dGVybi5sZW5ndGgpIDogMFxyXG4gICAgICBcclxuICAgICAgY29uc3QgaGFzRXJyYXRpY1BhdHRlcm4gPSBwYXR0ZXJuVmFyaWFuY2UgPiA1MCAvLyBIaWdoIHZhcmlhbmNlID0gY3Jhc2gtbGlrZVxyXG4gICAgICBcclxuICAgICAgLy8gMy4gUGhvbmUgb3JpZW50YXRpb24gY2hlY2s6IElzIHBob25lIG1vdW50ZWQgb3IgaGFuZGhlbGQ/XHJcbiAgICAgIGNvbnN0IGlzTGlrZWx5TW91bnRlZCA9IE1hdGguYWJzKGFjYy56KSA+IDggJiYgTWF0aC5hYnMoYWNjLnopIDwgMTIgLy8gWi1heGlzIH45LjggKGdyYXZpdHkpXHJcbiAgICAgIGNvbnN0IHBob25lTW91bnRlZEJvbnVzID0gaXNMaWtlbHlNb3VudGVkID8gMTAgOiAwXHJcbiAgICAgIFxyXG4gICAgICAvLyA0LiBUaW1lLW9mLWRheSBhZGp1c3RtZW50OiBNb3JlIGNhdXRpb3VzIGF0IG5pZ2h0XHJcbiAgICAgIGNvbnN0IGhvdXIgPSBuZXcgRGF0ZSgpLmdldEhvdXJzKClcclxuICAgICAgY29uc3QgaXNOaWdodFRpbWUgPSBob3VyID49IDIyIHx8IGhvdXIgPD0gNlxyXG4gICAgICBjb25zdCBuaWdodFRpbWVBZGp1c3RtZW50ID0gaXNOaWdodFRpbWUgPyAtNSA6IDAgLy8gU2xpZ2h0bHkgbG93ZXIgdGhyZXNob2xkIGF0IG5pZ2h0XHJcbiAgICAgIFxyXG4gICAgICAvLyA1LiBSZWNlbnQgZmFsc2UgcG9zaXRpdmUgbGVhcm5pbmdcclxuICAgICAgY29uc3QgcmVjZW50RmFsc2VQb3NpdGl2ZXMgPSBmYWxzZVBvc2l0aXZlSGlzdG9yeS5jdXJyZW50LmZpbHRlcihcclxuICAgICAgICBmcCA9PiBub3cgLSBmcC50aW1lc3RhbXAgPCAzNjAwMDAwIC8vIExhc3QgaG91clxyXG4gICAgICApLmxlbmd0aFxyXG4gICAgICBjb25zdCBmYWxzZVBvc2l0aXZlUGVuYWx0eSA9IHJlY2VudEZhbHNlUG9zaXRpdmVzICogNSAvLyAtNSBwb2ludHMgcGVyIHJlY2VudCBGUFxyXG4gICAgICBcclxuICAgICAgLy8gNi4gR1BTIGFjY3VyYWN5IGNoZWNrOiBJcyBHUFMgcmVsaWFibGU/XHJcbiAgICAgIGNvbnN0IGdwc0FjY3VyYWN5Qm9udXMgPSBwb3NpdGlvbiAmJiAocG9zaXRpb24gYXMgYW55KS5hY2N1cmFjeSAmJiAocG9zaXRpb24gYXMgYW55KS5hY2N1cmFjeSA8IDIwID8gNSA6IDBcclxuXHJcbiAgICAgIC8vIERldGVybWluZSBjcmFzaCB0eXBlIGJhc2VkIG9uIGFjY2VsZXJhdGlvbiBkaXJlY3Rpb25cclxuICAgICAgbGV0IGNyYXNoVHlwZTogXCJmcm9udGFsXCIgfCBcInNpZGVcIiB8IFwicmVhclwiIHwgXCJyb2xsb3ZlclwiIHwgXCJ1bmtub3duXCIgPSBcInVua25vd25cIlxyXG4gICAgICBjb25zdCBkb21pbmFudEF4aXMgPSBNYXRoLm1heChNYXRoLmFicyhhY2MueCksIE1hdGguYWJzKGFjYy55KSwgTWF0aC5hYnMoYWNjLnopKVxyXG4gICAgICBcclxuICAgICAgaWYgKE1hdGguYWJzKGFjYy55KSA9PT0gZG9taW5hbnRBeGlzKSB7XHJcbiAgICAgICAgY3Jhc2hUeXBlID0gYWNjLnkgPiAwID8gXCJmcm9udGFsXCIgOiBcInJlYXJcIlxyXG4gICAgICB9IGVsc2UgaWYgKE1hdGguYWJzKGFjYy54KSA9PT0gZG9taW5hbnRBeGlzKSB7XHJcbiAgICAgICAgY3Jhc2hUeXBlID0gXCJzaWRlXCJcclxuICAgICAgfSBlbHNlIGlmIChneXJvUm90YXRpb25SYXRlID4gNSB8fCByb3RhdGlvblJhdGUgPiA2MCkge1xyXG4gICAgICAgIGNyYXNoVHlwZSA9IFwicm9sbG92ZXJcIlxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBDYWxjdWxhdGUgY29uZmlkZW5jZSBzY29yZSAoMC0xMDAlKVxyXG4gICAgICBsZXQgY29uZmlkZW5jZSA9IDBcclxuICAgICAgbGV0IGNvbmZpZGVuY2VGYWN0b3JzID0gMFxyXG5cclxuICAgICAgLy8gRmFjdG9yIDE6IEctZm9yY2Ugc3RyZW5ndGggKG1heCAyNSBwb2ludHMpXHJcbiAgICAgIGlmICh0b3RhbEcgPiA0KSBjb25maWRlbmNlICs9IDI1XHJcbiAgICAgIGVsc2UgaWYgKHRvdGFsRyA+IDMpIGNvbmZpZGVuY2UgKz0gMThcclxuICAgICAgZWxzZSBpZiAodG90YWxHID4gMi41KSBjb25maWRlbmNlICs9IDEwXHJcbiAgICAgIGNvbmZpZGVuY2VGYWN0b3JzKytcclxuXHJcbiAgICAgIC8vIEZhY3RvciAyOiBKZXJrIG1hZ25pdHVkZSAobWF4IDIwIHBvaW50cylcclxuICAgICAgaWYgKHRvdGFsSmVyayA+IDQwKSBjb25maWRlbmNlICs9IDIwXHJcbiAgICAgIGVsc2UgaWYgKHRvdGFsSmVyayA+IDMwKSBjb25maWRlbmNlICs9IDEyXHJcbiAgICAgIGVsc2UgaWYgKHRvdGFsSmVyayA+IDIwKSBjb25maWRlbmNlICs9IDhcclxuICAgICAgY29uZmlkZW5jZUZhY3RvcnMrK1xyXG5cclxuICAgICAgLy8gRmFjdG9yIDM6IFNwZWVkIGNoZWNrIChtYXggMTUgcG9pbnRzKVxyXG4gICAgICBpZiAocHJldmlvdXNTcGVlZC5jdXJyZW50ID4gMzApIGNvbmZpZGVuY2UgKz0gMTVcclxuICAgICAgZWxzZSBpZiAocHJldmlvdXNTcGVlZC5jdXJyZW50ID4gMjApIGNvbmZpZGVuY2UgKz0gMTBcclxuICAgICAgZWxzZSBpZiAocHJldmlvdXNTcGVlZC5jdXJyZW50ID4gMTUpIGNvbmZpZGVuY2UgKz0gNVxyXG4gICAgICBjb25maWRlbmNlRmFjdG9ycysrXHJcblxyXG4gICAgICAvLyBGYWN0b3IgNDogU291bmQgZGV0ZWN0aW9uIChtYXggMTIgcG9pbnRzKVxyXG4gICAgICBpZiAobG91ZFNvdW5kRGV0ZWN0ZWQuY3VycmVudCkgY29uZmlkZW5jZSArPSAxMlxyXG4gICAgICBjb25maWRlbmNlRmFjdG9ycysrXHJcblxyXG4gICAgICAvLyBGYWN0b3IgNTogU3BlZWQgZHJvcCAobWF4IDEwIHBvaW50cylcclxuICAgICAgaWYgKHNwZWVkRHJvcCA+IDIwKSBjb25maWRlbmNlICs9IDEwXHJcbiAgICAgIGVsc2UgaWYgKHNwZWVkRHJvcCA+IDEwKSBjb25maWRlbmNlICs9IDVcclxuICAgICAgY29uZmlkZW5jZUZhY3RvcnMrK1xyXG5cclxuICAgICAgLy8gRmFjdG9yIDY6IE11bHRpLXNhbXBsZSBjb25zaXN0ZW5jeSAobWF4IDggcG9pbnRzKVxyXG4gICAgICBpZiAoY29uc2lzdGVudEltcGFjdCkgY29uZmlkZW5jZSArPSA4XHJcbiAgICAgIGNvbmZpZGVuY2VGYWN0b3JzKytcclxuXHJcbiAgICAgIC8vIEZhY3RvciA3OiBVbnVzdWFsIGZvciB1c2VyIGJhc2VsaW5lIChtYXggNSBwb2ludHMpIOKcqCBORVdcclxuICAgICAgaWYgKGlzVW51c3VhbEZvclVzZXIpIGNvbmZpZGVuY2UgKz0gNVxyXG4gICAgICBjb25maWRlbmNlRmFjdG9ycysrXHJcblxyXG4gICAgICAvLyBGYWN0b3IgODogRXJyYXRpYyBwYXR0ZXJuIChtYXggNSBwb2ludHMpIOKcqCBORVdcclxuICAgICAgaWYgKGhhc0VycmF0aWNQYXR0ZXJuKSBjb25maWRlbmNlICs9IDVcclxuICAgICAgY29uZmlkZW5jZUZhY3RvcnMrK1xyXG5cclxuICAgICAgLy8gQXBwbHkgYm9udXNlcyBhbmQgcGVuYWx0aWVzXHJcbiAgICAgIGNvbmZpZGVuY2UgKz0gcGhvbmVNb3VudGVkQm9udXMgLy8gKzEwIGlmIHBob25lIG1vdW50ZWRcclxuICAgICAgY29uZmlkZW5jZSArPSBuaWdodFRpbWVBZGp1c3RtZW50IC8vIC01IGF0IG5pZ2h0IChtb3JlIGNhdXRpb3VzKVxyXG4gICAgICBjb25maWRlbmNlIC09IGZhbHNlUG9zaXRpdmVQZW5hbHR5IC8vIC01IHBlciByZWNlbnQgZmFsc2UgcG9zaXRpdmVcclxuICAgICAgY29uZmlkZW5jZSArPSBncHNBY2N1cmFjeUJvbnVzIC8vICs1IGlmIEdQUyBhY2N1cmF0ZVxyXG5cclxuICAgICAgLy8gQ2FwIGF0IDEwMFxyXG4gICAgICBjb25maWRlbmNlID0gTWF0aC5taW4oMTAwLCBNYXRoLm1heCgwLCBjb25maWRlbmNlKSlcclxuXHJcbiAgICAgIC8vIEVuaGFuY2VkIGNyYXNoIGRldGVjdGlvbiBjcml0ZXJpYSB3aXRoIGNvbmZpZGVuY2Ugc2NvcmluZ1xyXG4gICAgICBjb25zdCBpc0hpZ2hJbXBhY3QgPSB0b3RhbEcgPiA0ICYmIHRvdGFsSmVyayA+IDQwICYmIHByZXZpb3VzU3BlZWQuY3VycmVudCA+IDIwXHJcbiAgICAgIGNvbnN0IGlzTWVkaXVtSW1wYWN0ID0gdG90YWxHID4gMyAmJiB0b3RhbEplcmsgPiAzMCAmJiBwcmV2aW91c1NwZWVkLmN1cnJlbnQgPiAxNVxyXG4gICAgICBjb25zdCBpc1JvbGxvdmVyID0gKGd5cm9Sb3RhdGlvblJhdGUgPiA1IHx8IHJvdGF0aW9uUmF0ZSA+IDYwKSAmJiBwcmV2aW91c1NwZWVkLmN1cnJlbnQgPiAxNVxyXG4gICAgICBjb25zdCBpc0NvbmZpZGVudENyYXNoID0gY29uZmlkZW5jZSA+PSA2NSAmJiBjb25zaXN0ZW50SW1wYWN0ICYmIHByZXZpb3VzU3BlZWQuY3VycmVudCA+IDE1IC8vIFJhaXNlZCBmcm9tIDYwIHRvIDY1XHJcblxyXG4gICAgICAvLyBQcmV2ZW50IGR1cGxpY2F0ZSBkZXRlY3Rpb25zIChjb29sZG93biBwZXJpb2QpXHJcbiAgICAgIGNvbnN0IHRpbWVTaW5jZUxhc3RDcmFzaCA9IG5vdyAtIGxhc3RDcmFzaFRpbWUuY3VycmVudFxyXG4gICAgICBjb25zdCBjb29sZG93blBlcmlvZCA9IDEwMDAwIC8vIDEwIHNlY29uZHNcclxuXHJcbiAgICAgIGlmICh0aW1lU2luY2VMYXN0Q3Jhc2ggPCBjb29sZG93blBlcmlvZCkge1xyXG4gICAgICAgIC8vIFNraXAgZGV0ZWN0aW9uIGR1cmluZyBjb29sZG93blxyXG4gICAgICAgIGxhc3RBY2NlbGVyYXRpb24uY3VycmVudCA9IHsgeDogYWNjLngsIHk6IGFjYy55LCB6OiBhY2MueiB9XHJcbiAgICAgICAgbGFzdFRpbWUuY3VycmVudCA9IG5vd1xyXG4gICAgICAgIHJldHVyblxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoaXNIaWdoSW1wYWN0IHx8IGlzTWVkaXVtSW1wYWN0IHx8IGlzUm9sbG92ZXIgfHwgaXNDb25maWRlbnRDcmFzaCkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiQ1JBU0ggREVURUNURUQhXCIsIHtcclxuICAgICAgICAgIHRvdGFsRzogdG90YWxHLnRvRml4ZWQoMiksXHJcbiAgICAgICAgICB0b3RhbEplcms6IHRvdGFsSmVyay50b0ZpeGVkKDIpLFxyXG4gICAgICAgICAgc3BlZWQ6IHByZXZpb3VzU3BlZWQuY3VycmVudCxcclxuICAgICAgICAgIHNwZWVkRHJvcDogc3BlZWREcm9wLnRvRml4ZWQoMSksXHJcbiAgICAgICAgICBjcmFzaFR5cGUsXHJcbiAgICAgICAgICByb3RhdGlvblJhdGU6IChneXJvUm90YXRpb25SYXRlIHx8IHJvdGF0aW9uUmF0ZSkudG9GaXhlZCgyKSxcclxuICAgICAgICAgIHNvdW5kRGV0ZWN0ZWQ6IGxvdWRTb3VuZERldGVjdGVkLmN1cnJlbnQsXHJcbiAgICAgICAgICBjb25maWRlbmNlOiBjb25maWRlbmNlLnRvRml4ZWQoMCkgKyBcIiVcIixcclxuICAgICAgICAgIGNvbnNpc3RlbnRJbXBhY3QsXHJcbiAgICAgICAgICBpc1VudXN1YWxGb3JVc2VyLFxyXG4gICAgICAgICAgaGFzRXJyYXRpY1BhdHRlcm4sXHJcbiAgICAgICAgICBwaG9uZU1vdW50ZWQ6IGlzTGlrZWx5TW91bnRlZCxcclxuICAgICAgICAgIGdwc0FjY3VyYXRlOiBwb3NpdGlvbiAmJiBwb3NpdGlvbi5hY2N1cmFjeSA8IDIwLFxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgICAgIGxhc3RDcmFzaFRpbWUuY3VycmVudCA9IG5vd1xyXG4gICAgICAgIHNldENyYXNoRGV0ZWN0ZWQodHJ1ZSlcclxuICAgICAgICBvbkNyYXNoRGV0ZWN0ZWQoe1xyXG4gICAgICAgICAgZ0ZvcmNlOiB0b3RhbEcsXHJcbiAgICAgICAgICB0aW1lc3RhbXA6IG5vdyxcclxuICAgICAgICAgIHBvc2l0aW9uLFxyXG4gICAgICAgICAgc3BlZWQ6IHByZXZpb3VzU3BlZWQuY3VycmVudCxcclxuICAgICAgICAgIGNyYXNoVHlwZSxcclxuICAgICAgICAgIHJvdGF0aW9uUmF0ZTogZ3lyb1JvdGF0aW9uUmF0ZSB8fCByb3RhdGlvblJhdGUsXHJcbiAgICAgICAgICBzcGVlZERyb3AsXHJcbiAgICAgICAgICBzb3VuZERldGVjdGVkOiBsb3VkU291bmREZXRlY3RlZC5jdXJyZW50LFxyXG4gICAgICAgICAgY29uZmlkZW5jZSxcclxuICAgICAgICB9KVxyXG4gICAgICB9XHJcblxyXG4gICAgICBsYXN0QWNjZWxlcmF0aW9uLmN1cnJlbnQgPSB7IHg6IGFjYy54LCB5OiBhY2MueSwgejogYWNjLnogfVxyXG4gICAgICBsYXN0VGltZS5jdXJyZW50ID0gbm93XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRnVuY3Rpb24gdG8gcmVjb3JkIGZhbHNlIHBvc2l0aXZlIChjYWxsZWQgd2hlbiB1c2VyIGNhbmNlbHMpXHJcbiAgICBjb25zdCByZWNvcmRGYWxzZVBvc2l0aXZlID0gKHJlYXNvbjogc3RyaW5nKSA9PiB7XHJcbiAgICAgIGZhbHNlUG9zaXRpdmVIaXN0b3J5LmN1cnJlbnQucHVzaCh7IHRpbWVzdGFtcDogRGF0ZS5ub3coKSwgcmVhc29uIH0pXHJcbiAgICAgIHVzZXJDYW5jZWxDb3VudC5jdXJyZW50KytcclxuICAgICAgXHJcbiAgICAgIC8vIEFkanVzdCB0aHJlc2hvbGRzIGlmIHRvbyBtYW55IGZhbHNlIHBvc2l0aXZlc1xyXG4gICAgICBpZiAodXNlckNhbmNlbENvdW50LmN1cnJlbnQgPj0gMykge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiQWRqdXN0aW5nIGRldGVjdGlvbiBzZW5zaXRpdml0eSBkdWUgdG8gZmFsc2UgcG9zaXRpdmVzXCIpXHJcbiAgICAgICAgLy8gQ291bGQgZHluYW1pY2FsbHkgYWRqdXN0IHRocmVzaG9sZHMgaGVyZVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRXhwb3NlIHJlY29yZEZhbHNlUG9zaXRpdmUgZm9yIGV4dGVybmFsIHVzZVxyXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcclxuICAgICAgKHdpbmRvdyBhcyBhbnkpLnJlY29yZENyYXNoRmFsc2VQb3NpdGl2ZSA9IHJlY29yZEZhbHNlUG9zaXRpdmVcclxuICAgIH1cclxuXHJcbiAgICAvLyBSZXF1ZXN0IHBlcm1pc3Npb24gZm9yIG1vdGlvbiBzZW5zb3JzIChpT1MgMTMrKVxyXG4gICAgaWYgKFxyXG4gICAgICB0eXBlb2YgRGV2aWNlTW90aW9uRXZlbnQgIT09IFwidW5kZWZpbmVkXCIgJiZcclxuICAgICAgdHlwZW9mIChEZXZpY2VNb3Rpb25FdmVudCBhcyBhbnkpLnJlcXVlc3RQZXJtaXNzaW9uID09PSBcImZ1bmN0aW9uXCJcclxuICAgICkge1xyXG4gICAgICA7KERldmljZU1vdGlvbkV2ZW50IGFzIGFueSlcclxuICAgICAgICAucmVxdWVzdFBlcm1pc3Npb24oKVxyXG4gICAgICAgIC50aGVuKChyZXNwb25zZTogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgICBpZiAocmVzcG9uc2UgPT09IFwiZ3JhbnRlZFwiKSB7XHJcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiZGV2aWNlbW90aW9uXCIsIGhhbmRsZU1vdGlvbilcclxuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJkZXZpY2VvcmllbnRhdGlvblwiLCBoYW5kbGVPcmllbnRhdGlvbilcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgICAgIC5jYXRjaCgoZXJyb3I6IEVycm9yKSA9PiB7XHJcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiTW90aW9uIHBlcm1pc3Npb24gZGVuaWVkOlwiLCBlcnJvcilcclxuICAgICAgICB9KVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gQW5kcm9pZCBvciBvbGRlciBpT1NcclxuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJkZXZpY2Vtb3Rpb25cIiwgaGFuZGxlTW90aW9uKVxyXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImRldmljZW9yaWVudGF0aW9uXCIsIGhhbmRsZU9yaWVudGF0aW9uKVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiZGV2aWNlbW90aW9uXCIsIGhhbmRsZU1vdGlvbilcclxuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJkZXZpY2VvcmllbnRhdGlvblwiLCBoYW5kbGVPcmllbnRhdGlvbilcclxuICAgIH1cclxuICB9LCBbaXNFbmFibGVkLCBwb3NpdGlvbiwgb25DcmFzaERldGVjdGVkXSlcclxuXHJcbiAgcmV0dXJuIHsgY3Jhc2hEZXRlY3RlZCwgc2V0Q3Jhc2hEZXRlY3RlZCB9XHJcbn1cclxuIl0sIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZVJlZiIsInVzZVN0YXRlIiwidXNlQ3Jhc2hEZXRlY3Rpb24iLCJpc0VuYWJsZWQiLCJjdXJyZW50U3BlZWQiLCJwb3NpdGlvbiIsIm9uQ3Jhc2hEZXRlY3RlZCIsImNyYXNoRGV0ZWN0ZWQiLCJzZXRDcmFzaERldGVjdGVkIiwibGFzdEFjY2VsZXJhdGlvbiIsIngiLCJ5IiwieiIsImxhc3RSb3RhdGlvbiIsImFscGhhIiwiYmV0YSIsImdhbW1hIiwibGFzdFRpbWUiLCJEYXRlIiwibm93IiwicHJldmlvdXNTcGVlZCIsImJhc2VsaW5lT3JpZW50YXRpb24iLCJpbXBhY3RTYW1wbGVzIiwiYXVkaW9Db250ZXh0IiwiYW5hbHlzZXIiLCJsb3VkU291bmREZXRlY3RlZCIsInNwZWVkSGlzdG9yeSIsImxhc3RDcmFzaFRpbWUiLCJhY2NlbGVyYXRpb25QYXR0ZXJuIiwibm9ybWFsRHJpdmluZ0Jhc2VsaW5lIiwiYXZnRyIsIm1heEciLCJmYWxzZVBvc2l0aXZlSGlzdG9yeSIsInVzZXJDYW5jZWxDb3VudCIsImN1cnJlbnQiLCJwdXNoIiwibGVuZ3RoIiwic2hpZnQiLCJiYXNlbGluZVRpbWVyIiwic2V0VGltZW91dCIsInJlZHVjZSIsInN1bSIsInAiLCJnIiwiTWF0aCIsInNxcnQiLCJtYXgiLCJtYXAiLCJjb25zb2xlIiwibG9nIiwic2V0dXBBdWRpb0RldGVjdGlvbiIsInN0cmVhbSIsIm5hdmlnYXRvciIsIm1lZGlhRGV2aWNlcyIsImdldFVzZXJNZWRpYSIsImF1ZGlvIiwid2luZG93IiwiQXVkaW9Db250ZXh0Iiwid2Via2l0QXVkaW9Db250ZXh0Iiwic291cmNlIiwiY3JlYXRlTWVkaWFTdHJlYW1Tb3VyY2UiLCJjcmVhdGVBbmFseXNlciIsImZmdFNpemUiLCJjb25uZWN0IiwiY2hlY2tTb3VuZCIsImRhdGFBcnJheSIsIlVpbnQ4QXJyYXkiLCJmcmVxdWVuY3lCaW5Db3VudCIsImdldEJ5dGVGcmVxdWVuY3lEYXRhIiwiYXZlcmFnZSIsImEiLCJiIiwic2V0SW50ZXJ2YWwiLCJlcnJvciIsImNsZWFyVGltZW91dCIsImNsb3NlIiwicm90YXRpb25SYXRlIiwiaGFzR3lyb3Njb3BlIiwiaGFuZGxlT3JpZW50YXRpb24iLCJldmVudCIsInRpbWVEaWZmIiwiYWxwaGFDaGFuZ2UiLCJhYnMiLCJiZXRhQ2hhbmdlIiwiZ2FtbWFDaGFuZ2UiLCJub3JtYWxpemVkQWxwaGFDaGFuZ2UiLCJ0b0ZpeGVkIiwic3BlZWQiLCJnRm9yY2UiLCJ0aW1lc3RhbXAiLCJjcmFzaFR5cGUiLCJoYW5kbGVNb3Rpb24iLCJhY2MiLCJhY2NlbGVyYXRpb25JbmNsdWRpbmdHcmF2aXR5Iiwicm90YXRpb24iLCJqZXJrWCIsImplcmtZIiwiamVya1oiLCJ0b3RhbEplcmsiLCJ0b3RhbEciLCJneXJvUm90YXRpb25SYXRlIiwic3BlZWREcm9wIiwiaGlnaEdTYW1wbGVzIiwiZmlsdGVyIiwiY29uc2lzdGVudEltcGFjdCIsImlzVW51c3VhbEZvclVzZXIiLCJyZWNlbnRQYXR0ZXJuIiwic2xpY2UiLCJwYXR0ZXJuVmFyaWFuY2UiLCJpIiwicHJldiIsImRpZmYiLCJoYXNFcnJhdGljUGF0dGVybiIsImlzTGlrZWx5TW91bnRlZCIsInBob25lTW91bnRlZEJvbnVzIiwiaG91ciIsImdldEhvdXJzIiwiaXNOaWdodFRpbWUiLCJuaWdodFRpbWVBZGp1c3RtZW50IiwicmVjZW50RmFsc2VQb3NpdGl2ZXMiLCJmcCIsImZhbHNlUG9zaXRpdmVQZW5hbHR5IiwiZ3BzQWNjdXJhY3lCb251cyIsImFjY3VyYWN5IiwiZG9taW5hbnRBeGlzIiwiY29uZmlkZW5jZSIsImNvbmZpZGVuY2VGYWN0b3JzIiwibWluIiwiaXNIaWdoSW1wYWN0IiwiaXNNZWRpdW1JbXBhY3QiLCJpc1JvbGxvdmVyIiwiaXNDb25maWRlbnRDcmFzaCIsInRpbWVTaW5jZUxhc3RDcmFzaCIsImNvb2xkb3duUGVyaW9kIiwic291bmREZXRlY3RlZCIsInBob25lTW91bnRlZCIsImdwc0FjY3VyYXRlIiwicmVjb3JkRmFsc2VQb3NpdGl2ZSIsInJlYXNvbiIsInJlY29yZENyYXNoRmFsc2VQb3NpdGl2ZSIsIkRldmljZU1vdGlvbkV2ZW50IiwicmVxdWVzdFBlcm1pc3Npb24iLCJ0aGVuIiwicmVzcG9uc2UiLCJhZGRFdmVudExpc3RlbmVyIiwiY2F0Y2giLCJyZW1vdmVFdmVudExpc3RlbmVyIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./hooks/use-crash-detection.ts\n"));

/***/ })

});