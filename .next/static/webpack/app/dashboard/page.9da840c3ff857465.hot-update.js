"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/dashboard/page",{

/***/ "(app-pages-browser)/./hooks/use-crash-detection.ts":
/*!**************************************!*\
  !*** ./hooks/use-crash-detection.ts ***!
  \**************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useCrashDetection: () => (/* binding */ useCrashDetection)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\nfunction useCrashDetection(isEnabled, currentSpeed, position, onCrashDetected) {\n    const [crashDetected, setCrashDetected] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const lastAcceleration = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        x: 0,\n        y: 0,\n        z: 0\n    });\n    const lastRotation = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        alpha: 0,\n        beta: 0,\n        gamma: 0\n    });\n    const lastTime = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(Date.now());\n    const previousSpeed = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const baselineOrientation = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        alpha: 0,\n        beta: 0,\n        gamma: 0\n    });\n    const impactSamples = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    const audioContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const analyser = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const loudSoundDetected = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const speedHistory = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    const lastCrashTime = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const accelerationPattern = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    const normalDrivingBaseline = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        avgG: 1,\n        maxG: 2\n    });\n    const falsePositiveHistory = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    const userCancelCount = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useCrashDetection.useEffect\": ()=>{\n            previousSpeed.current = currentSpeed;\n            // Track speed history for sudden drop detection\n            speedHistory.current.push(currentSpeed);\n            if (speedHistory.current.length > 10) {\n                speedHistory.current.shift(); // Keep last 10 readings (2 seconds)\n            }\n        }\n    }[\"useCrashDetection.useEffect\"], [\n        currentSpeed\n    ]);\n    // Sound detection setup\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useCrashDetection.useEffect\": ()=>{\n            if (!isEnabled || \"object\" === \"undefined\") return;\n            // Establish normal driving baseline over first 2 minutes\n            const baselineTimer = setTimeout({\n                \"useCrashDetection.useEffect.baselineTimer\": ()=>{\n                    if (accelerationPattern.current.length > 0) {\n                        const avgG = accelerationPattern.current.reduce({\n                            \"useCrashDetection.useEffect.baselineTimer\": (sum, p)=>{\n                                const g = Math.sqrt(p.x ** 2 + p.y ** 2 + p.z ** 2) / 9.8;\n                                return sum + g;\n                            }\n                        }[\"useCrashDetection.useEffect.baselineTimer\"], 0) / accelerationPattern.current.length;\n                        const maxG = Math.max(...accelerationPattern.current.map({\n                            \"useCrashDetection.useEffect.baselineTimer.maxG\": (p)=>Math.sqrt(p.x ** 2 + p.y ** 2 + p.z ** 2) / 9.8\n                        }[\"useCrashDetection.useEffect.baselineTimer.maxG\"]));\n                        normalDrivingBaseline.current = {\n                            avgG,\n                            maxG\n                        };\n                        console.log(\"Baseline established:\", normalDrivingBaseline.current);\n                    }\n                }\n            }[\"useCrashDetection.useEffect.baselineTimer\"], 120000) // 2 minutes\n            ;\n            const setupAudioDetection = {\n                \"useCrashDetection.useEffect.setupAudioDetection\": async ()=>{\n                    try {\n                        const stream = await navigator.mediaDevices.getUserMedia({\n                            audio: true\n                        });\n                        audioContext.current = new (window.AudioContext || window.webkitAudioContext)();\n                        const source = audioContext.current.createMediaStreamSource(stream);\n                        analyser.current = audioContext.current.createAnalyser();\n                        analyser.current.fftSize = 2048;\n                        source.connect(analyser.current);\n                        // Monitor for loud sounds (crash/airbag)\n                        const checkSound = {\n                            \"useCrashDetection.useEffect.setupAudioDetection.checkSound\": ()=>{\n                                if (!analyser.current) return;\n                                const dataArray = new Uint8Array(analyser.current.frequencyBinCount);\n                                analyser.current.getByteFrequencyData(dataArray);\n                                // Calculate average volume\n                                const average = dataArray.reduce({\n                                    \"useCrashDetection.useEffect.setupAudioDetection.checkSound\": (a, b)=>a + b\n                                }[\"useCrashDetection.useEffect.setupAudioDetection.checkSound\"]) / dataArray.length;\n                                // Detect loud sudden sound (>150 threshold = crash/airbag)\n                                if (average > 150) {\n                                    console.log(\"LOUD SOUND DETECTED:\", average);\n                                    loudSoundDetected.current = true;\n                                    setTimeout({\n                                        \"useCrashDetection.useEffect.setupAudioDetection.checkSound\": ()=>{\n                                            loudSoundDetected.current = false;\n                                        }\n                                    }[\"useCrashDetection.useEffect.setupAudioDetection.checkSound\"], 2000); // Reset after 2 seconds\n                                }\n                            }\n                        }[\"useCrashDetection.useEffect.setupAudioDetection.checkSound\"];\n                        setInterval(checkSound, 100); // Check every 100ms\n                    } catch (error) {\n                        console.log(\"Audio detection not available:\", error);\n                    }\n                }\n            }[\"useCrashDetection.useEffect.setupAudioDetection\"];\n            setupAudioDetection();\n            return ({\n                \"useCrashDetection.useEffect\": ()=>{\n                    clearTimeout(baselineTimer);\n                    if (audioContext.current) {\n                        audioContext.current.close();\n                    }\n                }\n            })[\"useCrashDetection.useEffect\"];\n        }\n    }[\"useCrashDetection.useEffect\"], [\n        isEnabled\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useCrashDetection.useEffect\": ()=>{\n            if (!isEnabled || \"object\" === \"undefined\") return;\n            let rotationRate = 0;\n            let hasGyroscope = false;\n            // Handle gyroscope data for rollover detection\n            const handleOrientation = {\n                \"useCrashDetection.useEffect.handleOrientation\": (event)=>{\n                    if (event.alpha === null || event.beta === null || event.gamma === null) return;\n                    hasGyroscope = true;\n                    const now = Date.now();\n                    const timeDiff = (now - lastTime.current) / 1000;\n                    if (timeDiff < 0.1) return;\n                    // Calculate rotation rate (degrees per second)\n                    const alphaChange = Math.abs(event.alpha - lastRotation.current.alpha);\n                    const betaChange = Math.abs(event.beta - lastRotation.current.beta);\n                    const gammaChange = Math.abs(event.gamma - lastRotation.current.gamma);\n                    // Handle 360-degree wraparound for alpha\n                    const normalizedAlphaChange = alphaChange > 180 ? 360 - alphaChange : alphaChange;\n                    rotationRate = Math.sqrt(normalizedAlphaChange ** 2 + betaChange ** 2 + gammaChange ** 2) / timeDiff;\n                    // Detect rollover: extreme rotation (>90 degrees/sec) while moving\n                    if (rotationRate > 90 && previousSpeed.current > 15) {\n                        console.log(\"ROLLOVER DETECTED!\", {\n                            rotationRate: rotationRate.toFixed(2),\n                            speed: previousSpeed.current\n                        });\n                        setCrashDetected(true);\n                        onCrashDetected({\n                            gForce: 0,\n                            timestamp: now,\n                            position,\n                            speed: previousSpeed.current,\n                            crashType: \"rollover\",\n                            rotationRate\n                        });\n                    }\n                    lastRotation.current = {\n                        alpha: event.alpha,\n                        beta: event.beta,\n                        gamma: event.gamma\n                    };\n                }\n            }[\"useCrashDetection.useEffect.handleOrientation\"];\n            const handleMotion = {\n                \"useCrashDetection.useEffect.handleMotion\": (event)=>{\n                    const acc = event.accelerationIncludingGravity;\n                    const rotation = event.rotationRate;\n                    if (!acc || acc.x === null || acc.y === null || acc.z === null) return;\n                    const now = Date.now();\n                    const timeDiff = (now - lastTime.current) / 1000 // seconds\n                    ;\n                    if (timeDiff < 0.1) return; // Ignore too frequent updates\n                    // Calculate jerk (rate of change of acceleration)\n                    const jerkX = Math.abs(acc.x - lastAcceleration.current.x) / timeDiff;\n                    const jerkY = Math.abs(acc.y - lastAcceleration.current.y) / timeDiff;\n                    const jerkZ = Math.abs(acc.z - lastAcceleration.current.z) / timeDiff;\n                    const totalJerk = Math.sqrt(jerkX ** 2 + jerkY ** 2 + jerkZ ** 2);\n                    // Total acceleration magnitude in G's\n                    const totalG = Math.sqrt(acc.x ** 2 + acc.y ** 2 + acc.z ** 2) / 9.8;\n                    // Get gyroscope rotation rate if available\n                    let gyroRotationRate = 0;\n                    if (rotation && rotation.alpha !== null && rotation.beta !== null && rotation.gamma !== null) {\n                        gyroRotationRate = Math.sqrt(rotation.alpha ** 2 + rotation.beta ** 2 + rotation.gamma ** 2);\n                    }\n                    // Calculate speed drop (sudden deceleration)\n                    const speedDrop = speedHistory.current.length >= 2 ? speedHistory.current[0] - speedHistory.current[speedHistory.current.length - 1] : 0;\n                    // Multi-sample verification: Store last 5 impact readings\n                    impactSamples.current.push(totalG);\n                    if (impactSamples.current.length > 5) {\n                        impactSamples.current.shift();\n                    }\n                    // Store acceleration pattern for baseline learning\n                    accelerationPattern.current.push({\n                        x: acc.x,\n                        y: acc.y,\n                        z: acc.z,\n                        timestamp: now\n                    });\n                    if (accelerationPattern.current.length > 1200) {\n                        accelerationPattern.current.shift();\n                    }\n                    // Check if multiple samples show high G-force (reduces false positives)\n                    const highGSamples = impactSamples.current.filter({\n                        \"useCrashDetection.useEffect.handleMotion\": (g)=>g > 2.5\n                    }[\"useCrashDetection.useEffect.handleMotion\"]).length;\n                    const consistentImpact = highGSamples >= 3 // At least 3 out of 5 samples\n                    ;\n                    // Advanced false positive checks\n                    // 1. Baseline comparison: Is this G-force unusual for this user?\n                    const isUnusualForUser = totalG > normalDrivingBaseline.current.maxG * 1.5;\n                    // 2. Pattern analysis: Does acceleration pattern match crash signature?\n                    const recentPattern = accelerationPattern.current.slice(-10) // Last 1 second\n                    ;\n                    const patternVariance = recentPattern.length > 1 ? Math.sqrt(recentPattern.reduce({\n                        \"useCrashDetection.useEffect.handleMotion\": (sum, p, i)=>{\n                            if (i === 0) return 0;\n                            const prev = recentPattern[i - 1];\n                            const diff = Math.sqrt((p.x - prev.x) ** 2 + (p.y - prev.y) ** 2 + (p.z - prev.z) ** 2);\n                            return sum + diff ** 2;\n                        }\n                    }[\"useCrashDetection.useEffect.handleMotion\"], 0) / recentPattern.length) : 0;\n                    const hasErraticPattern = patternVariance > 50 // High variance = crash-like\n                    ;\n                    // 3. Phone orientation check: Is phone mounted or handheld?\n                    const isLikelyMounted = Math.abs(acc.z) > 8 && Math.abs(acc.z) < 12 // Z-axis ~9.8 (gravity)\n                    ;\n                    const phoneMountedBonus = isLikelyMounted ? 10 : 0;\n                    // 4. Time-of-day adjustment: More cautious at night\n                    const hour = new Date().getHours();\n                    const isNightTime = hour >= 22 || hour <= 6;\n                    const nightTimeAdjustment = isNightTime ? -5 : 0 // Slightly lower threshold at night\n                    ;\n                    // 5. Recent false positive learning\n                    const recentFalsePositives = falsePositiveHistory.current.filter({\n                        \"useCrashDetection.useEffect.handleMotion\": (fp)=>now - fp.timestamp < 3600000 // Last hour\n                    }[\"useCrashDetection.useEffect.handleMotion\"]).length;\n                    const falsePositivePenalty = recentFalsePositives * 5 // -5 points per recent FP\n                    ;\n                    // 6. GPS accuracy check: Is GPS reliable?\n                    const gpsAccuracyBonus = position && position.accuracy && position.accuracy < 20 ? 5 : 0;\n                    // Determine crash type based on acceleration direction\n                    let crashType = \"unknown\";\n                    const dominantAxis = Math.max(Math.abs(acc.x), Math.abs(acc.y), Math.abs(acc.z));\n                    if (Math.abs(acc.y) === dominantAxis) {\n                        crashType = acc.y > 0 ? \"frontal\" : \"rear\";\n                    } else if (Math.abs(acc.x) === dominantAxis) {\n                        crashType = \"side\";\n                    } else if (gyroRotationRate > 5 || rotationRate > 60) {\n                        crashType = \"rollover\";\n                    }\n                    // Calculate confidence score (0-100%)\n                    let confidence = 0;\n                    let confidenceFactors = 0;\n                    // Factor 1: G-force strength (max 25 points)\n                    if (totalG > 4) confidence += 25;\n                    else if (totalG > 3) confidence += 18;\n                    else if (totalG > 2.5) confidence += 10;\n                    confidenceFactors++;\n                    // Factor 2: Jerk magnitude (max 20 points)\n                    if (totalJerk > 40) confidence += 20;\n                    else if (totalJerk > 30) confidence += 12;\n                    else if (totalJerk > 20) confidence += 8;\n                    confidenceFactors++;\n                    // Factor 3: Speed check (max 15 points)\n                    if (previousSpeed.current > 30) confidence += 15;\n                    else if (previousSpeed.current > 20) confidence += 10;\n                    else if (previousSpeed.current > 15) confidence += 5;\n                    confidenceFactors++;\n                    // Factor 4: Sound detection (max 12 points)\n                    if (loudSoundDetected.current) confidence += 12;\n                    confidenceFactors++;\n                    // Factor 5: Speed drop (max 10 points)\n                    if (speedDrop > 20) confidence += 10;\n                    else if (speedDrop > 10) confidence += 5;\n                    confidenceFactors++;\n                    // Factor 6: Multi-sample consistency (max 8 points)\n                    if (consistentImpact) confidence += 8;\n                    confidenceFactors++;\n                    // Factor 7: Unusual for user baseline (max 5 points) ✨ NEW\n                    if (isUnusualForUser) confidence += 5;\n                    confidenceFactors++;\n                    // Factor 8: Erratic pattern (max 5 points) ✨ NEW\n                    if (hasErraticPattern) confidence += 5;\n                    confidenceFactors++;\n                    // Apply bonuses and penalties\n                    confidence += phoneMountedBonus; // +10 if phone mounted\n                    confidence += nightTimeAdjustment; // -5 at night (more cautious)\n                    confidence -= falsePositivePenalty; // -5 per recent false positive\n                    confidence += gpsAccuracyBonus; // +5 if GPS accurate\n                    // Cap at 100\n                    confidence = Math.min(100, Math.max(0, confidence));\n                    // Enhanced crash detection criteria with confidence scoring\n                    const isHighImpact = totalG > 4 && totalJerk > 40 && previousSpeed.current > 20;\n                    const isMediumImpact = totalG > 3 && totalJerk > 30 && previousSpeed.current > 15;\n                    const isRollover = (gyroRotationRate > 5 || rotationRate > 60) && previousSpeed.current > 15;\n                    const isConfidentCrash = confidence >= 65 && consistentImpact && previousSpeed.current > 15 // Raised from 60 to 65\n                    ;\n                    // Prevent duplicate detections (cooldown period)\n                    const timeSinceLastCrash = now - lastCrashTime.current;\n                    const cooldownPeriod = 10000 // 10 seconds\n                    ;\n                    if (timeSinceLastCrash < cooldownPeriod) {\n                        // Skip detection during cooldown\n                        lastAcceleration.current = {\n                            x: acc.x,\n                            y: acc.y,\n                            z: acc.z\n                        };\n                        lastTime.current = now;\n                        return;\n                    }\n                    if (isHighImpact || isMediumImpact || isRollover || isConfidentCrash) {\n                        console.log(\"CRASH DETECTED!\", {\n                            totalG: totalG.toFixed(2),\n                            totalJerk: totalJerk.toFixed(2),\n                            speed: previousSpeed.current,\n                            speedDrop: speedDrop.toFixed(1),\n                            crashType,\n                            rotationRate: (gyroRotationRate || rotationRate).toFixed(2),\n                            soundDetected: loudSoundDetected.current,\n                            confidence: confidence.toFixed(0) + \"%\",\n                            consistentImpact,\n                            isUnusualForUser,\n                            hasErraticPattern,\n                            phoneMounted: isLikelyMounted,\n                            gpsAccurate: position && position.accuracy && position.accuracy < 20\n                        });\n                        lastCrashTime.current = now;\n                        setCrashDetected(true);\n                        onCrashDetected({\n                            gForce: totalG,\n                            timestamp: now,\n                            position,\n                            speed: previousSpeed.current,\n                            crashType,\n                            rotationRate: gyroRotationRate || rotationRate,\n                            speedDrop,\n                            soundDetected: loudSoundDetected.current,\n                            confidence\n                        });\n                    }\n                    lastAcceleration.current = {\n                        x: acc.x,\n                        y: acc.y,\n                        z: acc.z\n                    };\n                    lastTime.current = now;\n                }\n            }[\"useCrashDetection.useEffect.handleMotion\"];\n            // Function to record false positive (called when user cancels)\n            const recordFalsePositive = {\n                \"useCrashDetection.useEffect.recordFalsePositive\": (reason)=>{\n                    falsePositiveHistory.current.push({\n                        timestamp: Date.now(),\n                        reason\n                    });\n                    userCancelCount.current++;\n                    // Adjust thresholds if too many false positives\n                    if (userCancelCount.current >= 3) {\n                        console.log(\"Adjusting detection sensitivity due to false positives\");\n                    // Could dynamically adjust thresholds here\n                    }\n                }\n            }[\"useCrashDetection.useEffect.recordFalsePositive\"];\n            // Expose recordFalsePositive for external use\n            if (true) {\n                window.recordCrashFalsePositive = recordFalsePositive;\n            }\n            // Request permission for motion sensors (iOS 13+)\n            if (typeof DeviceMotionEvent !== \"undefined\" && typeof DeviceMotionEvent.requestPermission === \"function\") {\n                ;\n                DeviceMotionEvent.requestPermission().then({\n                    \"useCrashDetection.useEffect\": (response)=>{\n                        if (response === \"granted\") {\n                            window.addEventListener(\"devicemotion\", handleMotion);\n                            window.addEventListener(\"deviceorientation\", handleOrientation);\n                        }\n                    }\n                }[\"useCrashDetection.useEffect\"]).catch({\n                    \"useCrashDetection.useEffect\": (error)=>{\n                        console.error(\"Motion permission denied:\", error);\n                    }\n                }[\"useCrashDetection.useEffect\"]);\n            } else {\n                // Android or older iOS\n                window.addEventListener(\"devicemotion\", handleMotion);\n                window.addEventListener(\"deviceorientation\", handleOrientation);\n            }\n            return ({\n                \"useCrashDetection.useEffect\": ()=>{\n                    window.removeEventListener(\"devicemotion\", handleMotion);\n                    window.removeEventListener(\"deviceorientation\", handleOrientation);\n                }\n            })[\"useCrashDetection.useEffect\"];\n        }\n    }[\"useCrashDetection.useEffect\"], [\n        isEnabled,\n        position,\n        onCrashDetected\n    ]);\n    return {\n        crashDetected,\n        setCrashDetected\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2hvb2tzL3VzZS1jcmFzaC1kZXRlY3Rpb24udHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQW1EO0FBYzVDLFNBQVNHLGtCQUNkQyxTQUFrQixFQUNsQkMsWUFBb0IsRUFDcEJDLFFBQTZDLEVBQzdDQyxlQUEwQztJQUUxQyxNQUFNLENBQUNDLGVBQWVDLGlCQUFpQixHQUFHUCwrQ0FBUUEsQ0FBQztJQUNuRCxNQUFNUSxtQkFBbUJULDZDQUFNQSxDQUFDO1FBQUVVLEdBQUc7UUFBR0MsR0FBRztRQUFHQyxHQUFHO0lBQUU7SUFDbkQsTUFBTUMsZUFBZWIsNkNBQU1BLENBQUM7UUFBRWMsT0FBTztRQUFHQyxNQUFNO1FBQUdDLE9BQU87SUFBRTtJQUMxRCxNQUFNQyxXQUFXakIsNkNBQU1BLENBQUNrQixLQUFLQyxHQUFHO0lBQ2hDLE1BQU1DLGdCQUFnQnBCLDZDQUFNQSxDQUFDO0lBQzdCLE1BQU1xQixzQkFBc0JyQiw2Q0FBTUEsQ0FBQztRQUFFYyxPQUFPO1FBQUdDLE1BQU07UUFBR0MsT0FBTztJQUFFO0lBQ2pFLE1BQU1NLGdCQUFnQnRCLDZDQUFNQSxDQUFXLEVBQUU7SUFDekMsTUFBTXVCLGVBQWV2Qiw2Q0FBTUEsQ0FBc0I7SUFDakQsTUFBTXdCLFdBQVd4Qiw2Q0FBTUEsQ0FBc0I7SUFDN0MsTUFBTXlCLG9CQUFvQnpCLDZDQUFNQSxDQUFDO0lBQ2pDLE1BQU0wQixlQUFlMUIsNkNBQU1BLENBQVcsRUFBRTtJQUN4QyxNQUFNMkIsZ0JBQWdCM0IsNkNBQU1BLENBQUM7SUFDN0IsTUFBTTRCLHNCQUFzQjVCLDZDQUFNQSxDQUEyRCxFQUFFO0lBQy9GLE1BQU02Qix3QkFBd0I3Qiw2Q0FBTUEsQ0FBQztRQUFFOEIsTUFBTTtRQUFHQyxNQUFNO0lBQUU7SUFDeEQsTUFBTUMsdUJBQXVCaEMsNkNBQU1BLENBQTBDLEVBQUU7SUFDL0UsTUFBTWlDLGtCQUFrQmpDLDZDQUFNQSxDQUFDO0lBRS9CRCxnREFBU0E7dUNBQUM7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REFDQ21FLEtBQUs7bURBQUMsQ0FBQ3hFO3dCQUNOekIsUUFBUXlCLEtBQUssQ0FBQyw2QkFBNkJBO29CQUM3Qzs7WUFDSixPQUFPO2dCQUNMLHVCQUF1QjtnQkFDdkJqQixPQUFPd0YsZ0JBQWdCLENBQUMsZ0JBQWdCckQ7Z0JBQ3hDbkMsT0FBT3dGLGdCQUFnQixDQUFDLHFCQUFxQmxFO1lBQy9DO1lBRUE7K0NBQU87b0JBQ0x0QixPQUFPMEYsbUJBQW1CLENBQUMsZ0JBQWdCdkQ7b0JBQzNDbkMsT0FBTzBGLG1CQUFtQixDQUFDLHFCQUFxQnBFO2dCQUNsRDs7UUFDRjtzQ0FBRztRQUFDM0U7UUFBV0U7UUFBVUM7S0FBZ0I7SUFFekMsT0FBTztRQUFFQztRQUFlQztJQUFpQjtBQUMzQyIsInNvdXJjZXMiOlsiRDpcXHNtYXJ0c2FmZVxcc21hcnQtYWNjaWRlbnQtc2FmZXR5XFxob29rc1xcdXNlLWNyYXNoLWRldGVjdGlvbi50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVJlZiwgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIlxyXG5cclxuaW50ZXJmYWNlIENyYXNoRGF0YSB7XHJcbiAgZ0ZvcmNlOiBudW1iZXJcclxuICB0aW1lc3RhbXA6IG51bWJlclxyXG4gIHBvc2l0aW9uOiB7IGxhdDogbnVtYmVyOyBsbmc6IG51bWJlciB9IHwgbnVsbFxyXG4gIHNwZWVkOiBudW1iZXJcclxuICBjcmFzaFR5cGU/OiBcImZyb250YWxcIiB8IFwic2lkZVwiIHwgXCJyZWFyXCIgfCBcInJvbGxvdmVyXCIgfCBcInVua25vd25cIlxyXG4gIHJvdGF0aW9uUmF0ZT86IG51bWJlclxyXG4gIHNwZWVkRHJvcD86IG51bWJlclxyXG4gIHNvdW5kRGV0ZWN0ZWQ/OiBib29sZWFuXHJcbiAgY29uZmlkZW5jZT86IG51bWJlclxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdXNlQ3Jhc2hEZXRlY3Rpb24oXHJcbiAgaXNFbmFibGVkOiBib29sZWFuLFxyXG4gIGN1cnJlbnRTcGVlZDogbnVtYmVyLFxyXG4gIHBvc2l0aW9uOiB7IGxhdDogbnVtYmVyOyBsbmc6IG51bWJlciB9IHwgbnVsbCxcclxuICBvbkNyYXNoRGV0ZWN0ZWQ6IChkYXRhOiBDcmFzaERhdGEpID0+IHZvaWRcclxuKSB7XHJcbiAgY29uc3QgW2NyYXNoRGV0ZWN0ZWQsIHNldENyYXNoRGV0ZWN0ZWRdID0gdXNlU3RhdGUoZmFsc2UpXHJcbiAgY29uc3QgbGFzdEFjY2VsZXJhdGlvbiA9IHVzZVJlZih7IHg6IDAsIHk6IDAsIHo6IDAgfSlcclxuICBjb25zdCBsYXN0Um90YXRpb24gPSB1c2VSZWYoeyBhbHBoYTogMCwgYmV0YTogMCwgZ2FtbWE6IDAgfSlcclxuICBjb25zdCBsYXN0VGltZSA9IHVzZVJlZihEYXRlLm5vdygpKVxyXG4gIGNvbnN0IHByZXZpb3VzU3BlZWQgPSB1c2VSZWYoMClcclxuICBjb25zdCBiYXNlbGluZU9yaWVudGF0aW9uID0gdXNlUmVmKHsgYWxwaGE6IDAsIGJldGE6IDAsIGdhbW1hOiAwIH0pXHJcbiAgY29uc3QgaW1wYWN0U2FtcGxlcyA9IHVzZVJlZjxudW1iZXJbXT4oW10pXHJcbiAgY29uc3QgYXVkaW9Db250ZXh0ID0gdXNlUmVmPEF1ZGlvQ29udGV4dCB8IG51bGw+KG51bGwpXHJcbiAgY29uc3QgYW5hbHlzZXIgPSB1c2VSZWY8QW5hbHlzZXJOb2RlIHwgbnVsbD4obnVsbClcclxuICBjb25zdCBsb3VkU291bmREZXRlY3RlZCA9IHVzZVJlZihmYWxzZSlcclxuICBjb25zdCBzcGVlZEhpc3RvcnkgPSB1c2VSZWY8bnVtYmVyW10+KFtdKVxyXG4gIGNvbnN0IGxhc3RDcmFzaFRpbWUgPSB1c2VSZWYoMClcclxuICBjb25zdCBhY2NlbGVyYXRpb25QYXR0ZXJuID0gdXNlUmVmPHsgeDogbnVtYmVyOyB5OiBudW1iZXI7IHo6IG51bWJlcjsgdGltZXN0YW1wOiBudW1iZXIgfVtdPihbXSlcclxuICBjb25zdCBub3JtYWxEcml2aW5nQmFzZWxpbmUgPSB1c2VSZWYoeyBhdmdHOiAxLCBtYXhHOiAyIH0pXHJcbiAgY29uc3QgZmFsc2VQb3NpdGl2ZUhpc3RvcnkgPSB1c2VSZWY8eyB0aW1lc3RhbXA6IG51bWJlcjsgcmVhc29uOiBzdHJpbmcgfVtdPihbXSlcclxuICBjb25zdCB1c2VyQ2FuY2VsQ291bnQgPSB1c2VSZWYoMClcclxuXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIHByZXZpb3VzU3BlZWQuY3VycmVudCA9IGN1cnJlbnRTcGVlZFxyXG4gICAgXHJcbiAgICAvLyBUcmFjayBzcGVlZCBoaXN0b3J5IGZvciBzdWRkZW4gZHJvcCBkZXRlY3Rpb25cclxuICAgIHNwZWVkSGlzdG9yeS5jdXJyZW50LnB1c2goY3VycmVudFNwZWVkKVxyXG4gICAgaWYgKHNwZWVkSGlzdG9yeS5jdXJyZW50Lmxlbmd0aCA+IDEwKSB7XHJcbiAgICAgIHNwZWVkSGlzdG9yeS5jdXJyZW50LnNoaWZ0KCkgLy8gS2VlcCBsYXN0IDEwIHJlYWRpbmdzICgyIHNlY29uZHMpXHJcbiAgICB9XHJcbiAgfSwgW2N1cnJlbnRTcGVlZF0pXHJcblxyXG4gIC8vIFNvdW5kIGRldGVjdGlvbiBzZXR1cFxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBpZiAoIWlzRW5hYmxlZCB8fCB0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSByZXR1cm5cclxuXHJcbiAgICAvLyBFc3RhYmxpc2ggbm9ybWFsIGRyaXZpbmcgYmFzZWxpbmUgb3ZlciBmaXJzdCAyIG1pbnV0ZXNcclxuICAgIGNvbnN0IGJhc2VsaW5lVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgaWYgKGFjY2VsZXJhdGlvblBhdHRlcm4uY3VycmVudC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgY29uc3QgYXZnRyA9IGFjY2VsZXJhdGlvblBhdHRlcm4uY3VycmVudC5yZWR1Y2UoKHN1bSwgcCkgPT4ge1xyXG4gICAgICAgICAgY29uc3QgZyA9IE1hdGguc3FydChwLnggKiogMiArIHAueSAqKiAyICsgcC56ICoqIDIpIC8gOS44XHJcbiAgICAgICAgICByZXR1cm4gc3VtICsgZ1xyXG4gICAgICAgIH0sIDApIC8gYWNjZWxlcmF0aW9uUGF0dGVybi5jdXJyZW50Lmxlbmd0aFxyXG5cclxuICAgICAgICBjb25zdCBtYXhHID0gTWF0aC5tYXgoLi4uYWNjZWxlcmF0aW9uUGF0dGVybi5jdXJyZW50Lm1hcChwID0+IFxyXG4gICAgICAgICAgTWF0aC5zcXJ0KHAueCAqKiAyICsgcC55ICoqIDIgKyBwLnogKiogMikgLyA5LjhcclxuICAgICAgICApKVxyXG5cclxuICAgICAgICBub3JtYWxEcml2aW5nQmFzZWxpbmUuY3VycmVudCA9IHsgYXZnRywgbWF4RyB9XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJCYXNlbGluZSBlc3RhYmxpc2hlZDpcIiwgbm9ybWFsRHJpdmluZ0Jhc2VsaW5lLmN1cnJlbnQpXHJcbiAgICAgIH1cclxuICAgIH0sIDEyMDAwMCkgLy8gMiBtaW51dGVzXHJcblxyXG4gICAgY29uc3Qgc2V0dXBBdWRpb0RldGVjdGlvbiA9IGFzeW5jICgpID0+IHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBzdHJlYW0gPSBhd2FpdCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSh7IGF1ZGlvOiB0cnVlIH0pXHJcbiAgICAgICAgYXVkaW9Db250ZXh0LmN1cnJlbnQgPSBuZXcgKHdpbmRvdy5BdWRpb0NvbnRleHQgfHwgKHdpbmRvdyBhcyBhbnkpLndlYmtpdEF1ZGlvQ29udGV4dCkoKVxyXG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IGF1ZGlvQ29udGV4dC5jdXJyZW50LmNyZWF0ZU1lZGlhU3RyZWFtU291cmNlKHN0cmVhbSlcclxuICAgICAgICBhbmFseXNlci5jdXJyZW50ID0gYXVkaW9Db250ZXh0LmN1cnJlbnQuY3JlYXRlQW5hbHlzZXIoKVxyXG4gICAgICAgIGFuYWx5c2VyLmN1cnJlbnQuZmZ0U2l6ZSA9IDIwNDhcclxuICAgICAgICBzb3VyY2UuY29ubmVjdChhbmFseXNlci5jdXJyZW50KVxyXG5cclxuICAgICAgICAvLyBNb25pdG9yIGZvciBsb3VkIHNvdW5kcyAoY3Jhc2gvYWlyYmFnKVxyXG4gICAgICAgIGNvbnN0IGNoZWNrU291bmQgPSAoKSA9PiB7XHJcbiAgICAgICAgICBpZiAoIWFuYWx5c2VyLmN1cnJlbnQpIHJldHVyblxyXG5cclxuICAgICAgICAgIGNvbnN0IGRhdGFBcnJheSA9IG5ldyBVaW50OEFycmF5KGFuYWx5c2VyLmN1cnJlbnQuZnJlcXVlbmN5QmluQ291bnQpXHJcbiAgICAgICAgICBhbmFseXNlci5jdXJyZW50LmdldEJ5dGVGcmVxdWVuY3lEYXRhKGRhdGFBcnJheSlcclxuXHJcbiAgICAgICAgICAvLyBDYWxjdWxhdGUgYXZlcmFnZSB2b2x1bWVcclxuICAgICAgICAgIGNvbnN0IGF2ZXJhZ2UgPSBkYXRhQXJyYXkucmVkdWNlKChhLCBiKSA9PiBhICsgYikgLyBkYXRhQXJyYXkubGVuZ3RoXHJcblxyXG4gICAgICAgICAgLy8gRGV0ZWN0IGxvdWQgc3VkZGVuIHNvdW5kICg+MTUwIHRocmVzaG9sZCA9IGNyYXNoL2FpcmJhZylcclxuICAgICAgICAgIGlmIChhdmVyYWdlID4gMTUwKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiTE9VRCBTT1VORCBERVRFQ1RFRDpcIiwgYXZlcmFnZSlcclxuICAgICAgICAgICAgbG91ZFNvdW5kRGV0ZWN0ZWQuY3VycmVudCA9IHRydWVcclxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgbG91ZFNvdW5kRGV0ZWN0ZWQuY3VycmVudCA9IGZhbHNlXHJcbiAgICAgICAgICAgIH0sIDIwMDApIC8vIFJlc2V0IGFmdGVyIDIgc2Vjb25kc1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc2V0SW50ZXJ2YWwoY2hlY2tTb3VuZCwgMTAwKSAvLyBDaGVjayBldmVyeSAxMDBtc1xyXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiQXVkaW8gZGV0ZWN0aW9uIG5vdCBhdmFpbGFibGU6XCIsIGVycm9yKVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgc2V0dXBBdWRpb0RldGVjdGlvbigpXHJcblxyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgY2xlYXJUaW1lb3V0KGJhc2VsaW5lVGltZXIpXHJcbiAgICAgIGlmIChhdWRpb0NvbnRleHQuY3VycmVudCkge1xyXG4gICAgICAgIGF1ZGlvQ29udGV4dC5jdXJyZW50LmNsb3NlKClcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0sIFtpc0VuYWJsZWRdKVxyXG5cclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgaWYgKCFpc0VuYWJsZWQgfHwgdHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuXHJcblxyXG4gICAgbGV0IHJvdGF0aW9uUmF0ZSA9IDBcclxuICAgIGxldCBoYXNHeXJvc2NvcGUgPSBmYWxzZVxyXG5cclxuICAgIC8vIEhhbmRsZSBneXJvc2NvcGUgZGF0YSBmb3Igcm9sbG92ZXIgZGV0ZWN0aW9uXHJcbiAgICBjb25zdCBoYW5kbGVPcmllbnRhdGlvbiA9IChldmVudDogRGV2aWNlT3JpZW50YXRpb25FdmVudCkgPT4ge1xyXG4gICAgICBpZiAoZXZlbnQuYWxwaGEgPT09IG51bGwgfHwgZXZlbnQuYmV0YSA9PT0gbnVsbCB8fCBldmVudC5nYW1tYSA9PT0gbnVsbCkgcmV0dXJuXHJcbiAgICAgIFxyXG4gICAgICBoYXNHeXJvc2NvcGUgPSB0cnVlXHJcbiAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KClcclxuICAgICAgY29uc3QgdGltZURpZmYgPSAobm93IC0gbGFzdFRpbWUuY3VycmVudCkgLyAxMDAwXHJcblxyXG4gICAgICBpZiAodGltZURpZmYgPCAwLjEpIHJldHVyblxyXG5cclxuICAgICAgLy8gQ2FsY3VsYXRlIHJvdGF0aW9uIHJhdGUgKGRlZ3JlZXMgcGVyIHNlY29uZClcclxuICAgICAgY29uc3QgYWxwaGFDaGFuZ2UgPSBNYXRoLmFicyhldmVudC5hbHBoYSAtIGxhc3RSb3RhdGlvbi5jdXJyZW50LmFscGhhKVxyXG4gICAgICBjb25zdCBiZXRhQ2hhbmdlID0gTWF0aC5hYnMoZXZlbnQuYmV0YSAtIGxhc3RSb3RhdGlvbi5jdXJyZW50LmJldGEpXHJcbiAgICAgIGNvbnN0IGdhbW1hQ2hhbmdlID0gTWF0aC5hYnMoZXZlbnQuZ2FtbWEgLSBsYXN0Um90YXRpb24uY3VycmVudC5nYW1tYSlcclxuXHJcbiAgICAgIC8vIEhhbmRsZSAzNjAtZGVncmVlIHdyYXBhcm91bmQgZm9yIGFscGhhXHJcbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWRBbHBoYUNoYW5nZSA9IGFscGhhQ2hhbmdlID4gMTgwID8gMzYwIC0gYWxwaGFDaGFuZ2UgOiBhbHBoYUNoYW5nZVxyXG5cclxuICAgICAgcm90YXRpb25SYXRlID0gTWF0aC5zcXJ0KFxyXG4gICAgICAgIG5vcm1hbGl6ZWRBbHBoYUNoYW5nZSAqKiAyICsgYmV0YUNoYW5nZSAqKiAyICsgZ2FtbWFDaGFuZ2UgKiogMlxyXG4gICAgICApIC8gdGltZURpZmZcclxuXHJcbiAgICAgIC8vIERldGVjdCByb2xsb3ZlcjogZXh0cmVtZSByb3RhdGlvbiAoPjkwIGRlZ3JlZXMvc2VjKSB3aGlsZSBtb3ZpbmdcclxuICAgICAgaWYgKHJvdGF0aW9uUmF0ZSA+IDkwICYmIHByZXZpb3VzU3BlZWQuY3VycmVudCA+IDE1KSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJST0xMT1ZFUiBERVRFQ1RFRCFcIiwge1xyXG4gICAgICAgICAgcm90YXRpb25SYXRlOiByb3RhdGlvblJhdGUudG9GaXhlZCgyKSxcclxuICAgICAgICAgIHNwZWVkOiBwcmV2aW91c1NwZWVkLmN1cnJlbnQsXHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAgICAgc2V0Q3Jhc2hEZXRlY3RlZCh0cnVlKVxyXG4gICAgICAgIG9uQ3Jhc2hEZXRlY3RlZCh7XHJcbiAgICAgICAgICBnRm9yY2U6IDAsXHJcbiAgICAgICAgICB0aW1lc3RhbXA6IG5vdyxcclxuICAgICAgICAgIHBvc2l0aW9uLFxyXG4gICAgICAgICAgc3BlZWQ6IHByZXZpb3VzU3BlZWQuY3VycmVudCxcclxuICAgICAgICAgIGNyYXNoVHlwZTogXCJyb2xsb3ZlclwiLFxyXG4gICAgICAgICAgcm90YXRpb25SYXRlLFxyXG4gICAgICAgIH0pXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGxhc3RSb3RhdGlvbi5jdXJyZW50ID0geyBhbHBoYTogZXZlbnQuYWxwaGEsIGJldGE6IGV2ZW50LmJldGEsIGdhbW1hOiBldmVudC5nYW1tYSB9XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgaGFuZGxlTW90aW9uID0gKGV2ZW50OiBEZXZpY2VNb3Rpb25FdmVudCkgPT4ge1xyXG4gICAgICBjb25zdCBhY2MgPSBldmVudC5hY2NlbGVyYXRpb25JbmNsdWRpbmdHcmF2aXR5XHJcbiAgICAgIGNvbnN0IHJvdGF0aW9uID0gZXZlbnQucm90YXRpb25SYXRlXHJcbiAgICAgIFxyXG4gICAgICBpZiAoIWFjYyB8fCBhY2MueCA9PT0gbnVsbCB8fCBhY2MueSA9PT0gbnVsbCB8fCBhY2MueiA9PT0gbnVsbCkgcmV0dXJuXHJcblxyXG4gICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpXHJcbiAgICAgIGNvbnN0IHRpbWVEaWZmID0gKG5vdyAtIGxhc3RUaW1lLmN1cnJlbnQpIC8gMTAwMCAvLyBzZWNvbmRzXHJcblxyXG4gICAgICBpZiAodGltZURpZmYgPCAwLjEpIHJldHVybiAvLyBJZ25vcmUgdG9vIGZyZXF1ZW50IHVwZGF0ZXNcclxuXHJcbiAgICAgIC8vIENhbGN1bGF0ZSBqZXJrIChyYXRlIG9mIGNoYW5nZSBvZiBhY2NlbGVyYXRpb24pXHJcbiAgICAgIGNvbnN0IGplcmtYID0gTWF0aC5hYnMoYWNjLnggLSBsYXN0QWNjZWxlcmF0aW9uLmN1cnJlbnQueCkgLyB0aW1lRGlmZlxyXG4gICAgICBjb25zdCBqZXJrWSA9IE1hdGguYWJzKGFjYy55IC0gbGFzdEFjY2VsZXJhdGlvbi5jdXJyZW50LnkpIC8gdGltZURpZmZcclxuICAgICAgY29uc3QgamVya1ogPSBNYXRoLmFicyhhY2MueiAtIGxhc3RBY2NlbGVyYXRpb24uY3VycmVudC56KSAvIHRpbWVEaWZmXHJcblxyXG4gICAgICBjb25zdCB0b3RhbEplcmsgPSBNYXRoLnNxcnQoamVya1ggKiogMiArIGplcmtZICoqIDIgKyBqZXJrWiAqKiAyKVxyXG5cclxuICAgICAgLy8gVG90YWwgYWNjZWxlcmF0aW9uIG1hZ25pdHVkZSBpbiBHJ3NcclxuICAgICAgY29uc3QgdG90YWxHID0gTWF0aC5zcXJ0KGFjYy54ICoqIDIgKyBhY2MueSAqKiAyICsgYWNjLnogKiogMikgLyA5LjhcclxuXHJcbiAgICAgIC8vIEdldCBneXJvc2NvcGUgcm90YXRpb24gcmF0ZSBpZiBhdmFpbGFibGVcclxuICAgICAgbGV0IGd5cm9Sb3RhdGlvblJhdGUgPSAwXHJcbiAgICAgIGlmIChyb3RhdGlvbiAmJiByb3RhdGlvbi5hbHBoYSAhPT0gbnVsbCAmJiByb3RhdGlvbi5iZXRhICE9PSBudWxsICYmIHJvdGF0aW9uLmdhbW1hICE9PSBudWxsKSB7XHJcbiAgICAgICAgZ3lyb1JvdGF0aW9uUmF0ZSA9IE1hdGguc3FydChcclxuICAgICAgICAgIHJvdGF0aW9uLmFscGhhICoqIDIgKyByb3RhdGlvbi5iZXRhICoqIDIgKyByb3RhdGlvbi5nYW1tYSAqKiAyXHJcbiAgICAgICAgKVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBDYWxjdWxhdGUgc3BlZWQgZHJvcCAoc3VkZGVuIGRlY2VsZXJhdGlvbilcclxuICAgICAgY29uc3Qgc3BlZWREcm9wID0gc3BlZWRIaXN0b3J5LmN1cnJlbnQubGVuZ3RoID49IDJcclxuICAgICAgICA/IHNwZWVkSGlzdG9yeS5jdXJyZW50WzBdIC0gc3BlZWRIaXN0b3J5LmN1cnJlbnRbc3BlZWRIaXN0b3J5LmN1cnJlbnQubGVuZ3RoIC0gMV1cclxuICAgICAgICA6IDBcclxuXHJcbiAgICAgIC8vIE11bHRpLXNhbXBsZSB2ZXJpZmljYXRpb246IFN0b3JlIGxhc3QgNSBpbXBhY3QgcmVhZGluZ3NcclxuICAgICAgaW1wYWN0U2FtcGxlcy5jdXJyZW50LnB1c2godG90YWxHKVxyXG4gICAgICBpZiAoaW1wYWN0U2FtcGxlcy5jdXJyZW50Lmxlbmd0aCA+IDUpIHtcclxuICAgICAgICBpbXBhY3RTYW1wbGVzLmN1cnJlbnQuc2hpZnQoKVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBTdG9yZSBhY2NlbGVyYXRpb24gcGF0dGVybiBmb3IgYmFzZWxpbmUgbGVhcm5pbmdcclxuICAgICAgYWNjZWxlcmF0aW9uUGF0dGVybi5jdXJyZW50LnB1c2goeyB4OiBhY2MueCwgeTogYWNjLnksIHo6IGFjYy56LCB0aW1lc3RhbXA6IG5vdyB9KVxyXG4gICAgICBpZiAoYWNjZWxlcmF0aW9uUGF0dGVybi5jdXJyZW50Lmxlbmd0aCA+IDEyMDApIHsgLy8gS2VlcCBsYXN0IDIgbWludXRlc1xyXG4gICAgICAgIGFjY2VsZXJhdGlvblBhdHRlcm4uY3VycmVudC5zaGlmdCgpXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIENoZWNrIGlmIG11bHRpcGxlIHNhbXBsZXMgc2hvdyBoaWdoIEctZm9yY2UgKHJlZHVjZXMgZmFsc2UgcG9zaXRpdmVzKVxyXG4gICAgICBjb25zdCBoaWdoR1NhbXBsZXMgPSBpbXBhY3RTYW1wbGVzLmN1cnJlbnQuZmlsdGVyKGcgPT4gZyA+IDIuNSkubGVuZ3RoXHJcbiAgICAgIGNvbnN0IGNvbnNpc3RlbnRJbXBhY3QgPSBoaWdoR1NhbXBsZXMgPj0gMyAvLyBBdCBsZWFzdCAzIG91dCBvZiA1IHNhbXBsZXNcclxuXHJcbiAgICAgIC8vIEFkdmFuY2VkIGZhbHNlIHBvc2l0aXZlIGNoZWNrc1xyXG4gICAgICBcclxuICAgICAgLy8gMS4gQmFzZWxpbmUgY29tcGFyaXNvbjogSXMgdGhpcyBHLWZvcmNlIHVudXN1YWwgZm9yIHRoaXMgdXNlcj9cclxuICAgICAgY29uc3QgaXNVbnVzdWFsRm9yVXNlciA9IHRvdGFsRyA+IChub3JtYWxEcml2aW5nQmFzZWxpbmUuY3VycmVudC5tYXhHICogMS41KVxyXG4gICAgICBcclxuICAgICAgLy8gMi4gUGF0dGVybiBhbmFseXNpczogRG9lcyBhY2NlbGVyYXRpb24gcGF0dGVybiBtYXRjaCBjcmFzaCBzaWduYXR1cmU/XHJcbiAgICAgIGNvbnN0IHJlY2VudFBhdHRlcm4gPSBhY2NlbGVyYXRpb25QYXR0ZXJuLmN1cnJlbnQuc2xpY2UoLTEwKSAvLyBMYXN0IDEgc2Vjb25kXHJcbiAgICAgIGNvbnN0IHBhdHRlcm5WYXJpYW5jZSA9IHJlY2VudFBhdHRlcm4ubGVuZ3RoID4gMSA/IFxyXG4gICAgICAgIE1hdGguc3FydChyZWNlbnRQYXR0ZXJuLnJlZHVjZSgoc3VtLCBwLCBpKSA9PiB7XHJcbiAgICAgICAgICBpZiAoaSA9PT0gMCkgcmV0dXJuIDBcclxuICAgICAgICAgIGNvbnN0IHByZXYgPSByZWNlbnRQYXR0ZXJuW2kgLSAxXVxyXG4gICAgICAgICAgY29uc3QgZGlmZiA9IE1hdGguc3FydChcclxuICAgICAgICAgICAgKHAueCAtIHByZXYueCkgKiogMiArIChwLnkgLSBwcmV2LnkpICoqIDIgKyAocC56IC0gcHJldi56KSAqKiAyXHJcbiAgICAgICAgICApXHJcbiAgICAgICAgICByZXR1cm4gc3VtICsgZGlmZiAqKiAyXHJcbiAgICAgICAgfSwgMCkgLyByZWNlbnRQYXR0ZXJuLmxlbmd0aCkgOiAwXHJcbiAgICAgIFxyXG4gICAgICBjb25zdCBoYXNFcnJhdGljUGF0dGVybiA9IHBhdHRlcm5WYXJpYW5jZSA+IDUwIC8vIEhpZ2ggdmFyaWFuY2UgPSBjcmFzaC1saWtlXHJcbiAgICAgIFxyXG4gICAgICAvLyAzLiBQaG9uZSBvcmllbnRhdGlvbiBjaGVjazogSXMgcGhvbmUgbW91bnRlZCBvciBoYW5kaGVsZD9cclxuICAgICAgY29uc3QgaXNMaWtlbHlNb3VudGVkID0gTWF0aC5hYnMoYWNjLnopID4gOCAmJiBNYXRoLmFicyhhY2MueikgPCAxMiAvLyBaLWF4aXMgfjkuOCAoZ3Jhdml0eSlcclxuICAgICAgY29uc3QgcGhvbmVNb3VudGVkQm9udXMgPSBpc0xpa2VseU1vdW50ZWQgPyAxMCA6IDBcclxuICAgICAgXHJcbiAgICAgIC8vIDQuIFRpbWUtb2YtZGF5IGFkanVzdG1lbnQ6IE1vcmUgY2F1dGlvdXMgYXQgbmlnaHRcclxuICAgICAgY29uc3QgaG91ciA9IG5ldyBEYXRlKCkuZ2V0SG91cnMoKVxyXG4gICAgICBjb25zdCBpc05pZ2h0VGltZSA9IGhvdXIgPj0gMjIgfHwgaG91ciA8PSA2XHJcbiAgICAgIGNvbnN0IG5pZ2h0VGltZUFkanVzdG1lbnQgPSBpc05pZ2h0VGltZSA/IC01IDogMCAvLyBTbGlnaHRseSBsb3dlciB0aHJlc2hvbGQgYXQgbmlnaHRcclxuICAgICAgXHJcbiAgICAgIC8vIDUuIFJlY2VudCBmYWxzZSBwb3NpdGl2ZSBsZWFybmluZ1xyXG4gICAgICBjb25zdCByZWNlbnRGYWxzZVBvc2l0aXZlcyA9IGZhbHNlUG9zaXRpdmVIaXN0b3J5LmN1cnJlbnQuZmlsdGVyKFxyXG4gICAgICAgIGZwID0+IG5vdyAtIGZwLnRpbWVzdGFtcCA8IDM2MDAwMDAgLy8gTGFzdCBob3VyXHJcbiAgICAgICkubGVuZ3RoXHJcbiAgICAgIGNvbnN0IGZhbHNlUG9zaXRpdmVQZW5hbHR5ID0gcmVjZW50RmFsc2VQb3NpdGl2ZXMgKiA1IC8vIC01IHBvaW50cyBwZXIgcmVjZW50IEZQXHJcbiAgICAgIFxyXG4gICAgICAvLyA2LiBHUFMgYWNjdXJhY3kgY2hlY2s6IElzIEdQUyByZWxpYWJsZT9cclxuICAgICAgY29uc3QgZ3BzQWNjdXJhY3lCb251cyA9IHBvc2l0aW9uICYmIChwb3NpdGlvbiBhcyBhbnkpLmFjY3VyYWN5ICYmIChwb3NpdGlvbiBhcyBhbnkpLmFjY3VyYWN5IDwgMjAgPyA1IDogMFxyXG5cclxuICAgICAgLy8gRGV0ZXJtaW5lIGNyYXNoIHR5cGUgYmFzZWQgb24gYWNjZWxlcmF0aW9uIGRpcmVjdGlvblxyXG4gICAgICBsZXQgY3Jhc2hUeXBlOiBcImZyb250YWxcIiB8IFwic2lkZVwiIHwgXCJyZWFyXCIgfCBcInJvbGxvdmVyXCIgfCBcInVua25vd25cIiA9IFwidW5rbm93blwiXHJcbiAgICAgIGNvbnN0IGRvbWluYW50QXhpcyA9IE1hdGgubWF4KE1hdGguYWJzKGFjYy54KSwgTWF0aC5hYnMoYWNjLnkpLCBNYXRoLmFicyhhY2MueikpXHJcbiAgICAgIFxyXG4gICAgICBpZiAoTWF0aC5hYnMoYWNjLnkpID09PSBkb21pbmFudEF4aXMpIHtcclxuICAgICAgICBjcmFzaFR5cGUgPSBhY2MueSA+IDAgPyBcImZyb250YWxcIiA6IFwicmVhclwiXHJcbiAgICAgIH0gZWxzZSBpZiAoTWF0aC5hYnMoYWNjLngpID09PSBkb21pbmFudEF4aXMpIHtcclxuICAgICAgICBjcmFzaFR5cGUgPSBcInNpZGVcIlxyXG4gICAgICB9IGVsc2UgaWYgKGd5cm9Sb3RhdGlvblJhdGUgPiA1IHx8IHJvdGF0aW9uUmF0ZSA+IDYwKSB7XHJcbiAgICAgICAgY3Jhc2hUeXBlID0gXCJyb2xsb3ZlclwiXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIENhbGN1bGF0ZSBjb25maWRlbmNlIHNjb3JlICgwLTEwMCUpXHJcbiAgICAgIGxldCBjb25maWRlbmNlID0gMFxyXG4gICAgICBsZXQgY29uZmlkZW5jZUZhY3RvcnMgPSAwXHJcblxyXG4gICAgICAvLyBGYWN0b3IgMTogRy1mb3JjZSBzdHJlbmd0aCAobWF4IDI1IHBvaW50cylcclxuICAgICAgaWYgKHRvdGFsRyA+IDQpIGNvbmZpZGVuY2UgKz0gMjVcclxuICAgICAgZWxzZSBpZiAodG90YWxHID4gMykgY29uZmlkZW5jZSArPSAxOFxyXG4gICAgICBlbHNlIGlmICh0b3RhbEcgPiAyLjUpIGNvbmZpZGVuY2UgKz0gMTBcclxuICAgICAgY29uZmlkZW5jZUZhY3RvcnMrK1xyXG5cclxuICAgICAgLy8gRmFjdG9yIDI6IEplcmsgbWFnbml0dWRlIChtYXggMjAgcG9pbnRzKVxyXG4gICAgICBpZiAodG90YWxKZXJrID4gNDApIGNvbmZpZGVuY2UgKz0gMjBcclxuICAgICAgZWxzZSBpZiAodG90YWxKZXJrID4gMzApIGNvbmZpZGVuY2UgKz0gMTJcclxuICAgICAgZWxzZSBpZiAodG90YWxKZXJrID4gMjApIGNvbmZpZGVuY2UgKz0gOFxyXG4gICAgICBjb25maWRlbmNlRmFjdG9ycysrXHJcblxyXG4gICAgICAvLyBGYWN0b3IgMzogU3BlZWQgY2hlY2sgKG1heCAxNSBwb2ludHMpXHJcbiAgICAgIGlmIChwcmV2aW91c1NwZWVkLmN1cnJlbnQgPiAzMCkgY29uZmlkZW5jZSArPSAxNVxyXG4gICAgICBlbHNlIGlmIChwcmV2aW91c1NwZWVkLmN1cnJlbnQgPiAyMCkgY29uZmlkZW5jZSArPSAxMFxyXG4gICAgICBlbHNlIGlmIChwcmV2aW91c1NwZWVkLmN1cnJlbnQgPiAxNSkgY29uZmlkZW5jZSArPSA1XHJcbiAgICAgIGNvbmZpZGVuY2VGYWN0b3JzKytcclxuXHJcbiAgICAgIC8vIEZhY3RvciA0OiBTb3VuZCBkZXRlY3Rpb24gKG1heCAxMiBwb2ludHMpXHJcbiAgICAgIGlmIChsb3VkU291bmREZXRlY3RlZC5jdXJyZW50KSBjb25maWRlbmNlICs9IDEyXHJcbiAgICAgIGNvbmZpZGVuY2VGYWN0b3JzKytcclxuXHJcbiAgICAgIC8vIEZhY3RvciA1OiBTcGVlZCBkcm9wIChtYXggMTAgcG9pbnRzKVxyXG4gICAgICBpZiAoc3BlZWREcm9wID4gMjApIGNvbmZpZGVuY2UgKz0gMTBcclxuICAgICAgZWxzZSBpZiAoc3BlZWREcm9wID4gMTApIGNvbmZpZGVuY2UgKz0gNVxyXG4gICAgICBjb25maWRlbmNlRmFjdG9ycysrXHJcblxyXG4gICAgICAvLyBGYWN0b3IgNjogTXVsdGktc2FtcGxlIGNvbnNpc3RlbmN5IChtYXggOCBwb2ludHMpXHJcbiAgICAgIGlmIChjb25zaXN0ZW50SW1wYWN0KSBjb25maWRlbmNlICs9IDhcclxuICAgICAgY29uZmlkZW5jZUZhY3RvcnMrK1xyXG5cclxuICAgICAgLy8gRmFjdG9yIDc6IFVudXN1YWwgZm9yIHVzZXIgYmFzZWxpbmUgKG1heCA1IHBvaW50cykg4pyoIE5FV1xyXG4gICAgICBpZiAoaXNVbnVzdWFsRm9yVXNlcikgY29uZmlkZW5jZSArPSA1XHJcbiAgICAgIGNvbmZpZGVuY2VGYWN0b3JzKytcclxuXHJcbiAgICAgIC8vIEZhY3RvciA4OiBFcnJhdGljIHBhdHRlcm4gKG1heCA1IHBvaW50cykg4pyoIE5FV1xyXG4gICAgICBpZiAoaGFzRXJyYXRpY1BhdHRlcm4pIGNvbmZpZGVuY2UgKz0gNVxyXG4gICAgICBjb25maWRlbmNlRmFjdG9ycysrXHJcblxyXG4gICAgICAvLyBBcHBseSBib251c2VzIGFuZCBwZW5hbHRpZXNcclxuICAgICAgY29uZmlkZW5jZSArPSBwaG9uZU1vdW50ZWRCb251cyAvLyArMTAgaWYgcGhvbmUgbW91bnRlZFxyXG4gICAgICBjb25maWRlbmNlICs9IG5pZ2h0VGltZUFkanVzdG1lbnQgLy8gLTUgYXQgbmlnaHQgKG1vcmUgY2F1dGlvdXMpXHJcbiAgICAgIGNvbmZpZGVuY2UgLT0gZmFsc2VQb3NpdGl2ZVBlbmFsdHkgLy8gLTUgcGVyIHJlY2VudCBmYWxzZSBwb3NpdGl2ZVxyXG4gICAgICBjb25maWRlbmNlICs9IGdwc0FjY3VyYWN5Qm9udXMgLy8gKzUgaWYgR1BTIGFjY3VyYXRlXHJcblxyXG4gICAgICAvLyBDYXAgYXQgMTAwXHJcbiAgICAgIGNvbmZpZGVuY2UgPSBNYXRoLm1pbigxMDAsIE1hdGgubWF4KDAsIGNvbmZpZGVuY2UpKVxyXG5cclxuICAgICAgLy8gRW5oYW5jZWQgY3Jhc2ggZGV0ZWN0aW9uIGNyaXRlcmlhIHdpdGggY29uZmlkZW5jZSBzY29yaW5nXHJcbiAgICAgIGNvbnN0IGlzSGlnaEltcGFjdCA9IHRvdGFsRyA+IDQgJiYgdG90YWxKZXJrID4gNDAgJiYgcHJldmlvdXNTcGVlZC5jdXJyZW50ID4gMjBcclxuICAgICAgY29uc3QgaXNNZWRpdW1JbXBhY3QgPSB0b3RhbEcgPiAzICYmIHRvdGFsSmVyayA+IDMwICYmIHByZXZpb3VzU3BlZWQuY3VycmVudCA+IDE1XHJcbiAgICAgIGNvbnN0IGlzUm9sbG92ZXIgPSAoZ3lyb1JvdGF0aW9uUmF0ZSA+IDUgfHwgcm90YXRpb25SYXRlID4gNjApICYmIHByZXZpb3VzU3BlZWQuY3VycmVudCA+IDE1XHJcbiAgICAgIGNvbnN0IGlzQ29uZmlkZW50Q3Jhc2ggPSBjb25maWRlbmNlID49IDY1ICYmIGNvbnNpc3RlbnRJbXBhY3QgJiYgcHJldmlvdXNTcGVlZC5jdXJyZW50ID4gMTUgLy8gUmFpc2VkIGZyb20gNjAgdG8gNjVcclxuXHJcbiAgICAgIC8vIFByZXZlbnQgZHVwbGljYXRlIGRldGVjdGlvbnMgKGNvb2xkb3duIHBlcmlvZClcclxuICAgICAgY29uc3QgdGltZVNpbmNlTGFzdENyYXNoID0gbm93IC0gbGFzdENyYXNoVGltZS5jdXJyZW50XHJcbiAgICAgIGNvbnN0IGNvb2xkb3duUGVyaW9kID0gMTAwMDAgLy8gMTAgc2Vjb25kc1xyXG5cclxuICAgICAgaWYgKHRpbWVTaW5jZUxhc3RDcmFzaCA8IGNvb2xkb3duUGVyaW9kKSB7XHJcbiAgICAgICAgLy8gU2tpcCBkZXRlY3Rpb24gZHVyaW5nIGNvb2xkb3duXHJcbiAgICAgICAgbGFzdEFjY2VsZXJhdGlvbi5jdXJyZW50ID0geyB4OiBhY2MueCwgeTogYWNjLnksIHo6IGFjYy56IH1cclxuICAgICAgICBsYXN0VGltZS5jdXJyZW50ID0gbm93XHJcbiAgICAgICAgcmV0dXJuXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChpc0hpZ2hJbXBhY3QgfHwgaXNNZWRpdW1JbXBhY3QgfHwgaXNSb2xsb3ZlciB8fCBpc0NvbmZpZGVudENyYXNoKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJDUkFTSCBERVRFQ1RFRCFcIiwge1xyXG4gICAgICAgICAgdG90YWxHOiB0b3RhbEcudG9GaXhlZCgyKSxcclxuICAgICAgICAgIHRvdGFsSmVyazogdG90YWxKZXJrLnRvRml4ZWQoMiksXHJcbiAgICAgICAgICBzcGVlZDogcHJldmlvdXNTcGVlZC5jdXJyZW50LFxyXG4gICAgICAgICAgc3BlZWREcm9wOiBzcGVlZERyb3AudG9GaXhlZCgxKSxcclxuICAgICAgICAgIGNyYXNoVHlwZSxcclxuICAgICAgICAgIHJvdGF0aW9uUmF0ZTogKGd5cm9Sb3RhdGlvblJhdGUgfHwgcm90YXRpb25SYXRlKS50b0ZpeGVkKDIpLFxyXG4gICAgICAgICAgc291bmREZXRlY3RlZDogbG91ZFNvdW5kRGV0ZWN0ZWQuY3VycmVudCxcclxuICAgICAgICAgIGNvbmZpZGVuY2U6IGNvbmZpZGVuY2UudG9GaXhlZCgwKSArIFwiJVwiLFxyXG4gICAgICAgICAgY29uc2lzdGVudEltcGFjdCxcclxuICAgICAgICAgIGlzVW51c3VhbEZvclVzZXIsXHJcbiAgICAgICAgICBoYXNFcnJhdGljUGF0dGVybixcclxuICAgICAgICAgIHBob25lTW91bnRlZDogaXNMaWtlbHlNb3VudGVkLFxyXG4gICAgICAgICAgZ3BzQWNjdXJhdGU6IHBvc2l0aW9uICYmIChwb3NpdGlvbiBhcyBhbnkpLmFjY3VyYWN5ICYmIChwb3NpdGlvbiBhcyBhbnkpLmFjY3VyYWN5IDwgMjAsXHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAgICAgbGFzdENyYXNoVGltZS5jdXJyZW50ID0gbm93XHJcbiAgICAgICAgc2V0Q3Jhc2hEZXRlY3RlZCh0cnVlKVxyXG4gICAgICAgIG9uQ3Jhc2hEZXRlY3RlZCh7XHJcbiAgICAgICAgICBnRm9yY2U6IHRvdGFsRyxcclxuICAgICAgICAgIHRpbWVzdGFtcDogbm93LFxyXG4gICAgICAgICAgcG9zaXRpb24sXHJcbiAgICAgICAgICBzcGVlZDogcHJldmlvdXNTcGVlZC5jdXJyZW50LFxyXG4gICAgICAgICAgY3Jhc2hUeXBlLFxyXG4gICAgICAgICAgcm90YXRpb25SYXRlOiBneXJvUm90YXRpb25SYXRlIHx8IHJvdGF0aW9uUmF0ZSxcclxuICAgICAgICAgIHNwZWVkRHJvcCxcclxuICAgICAgICAgIHNvdW5kRGV0ZWN0ZWQ6IGxvdWRTb3VuZERldGVjdGVkLmN1cnJlbnQsXHJcbiAgICAgICAgICBjb25maWRlbmNlLFxyXG4gICAgICAgIH0pXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGxhc3RBY2NlbGVyYXRpb24uY3VycmVudCA9IHsgeDogYWNjLngsIHk6IGFjYy55LCB6OiBhY2MueiB9XHJcbiAgICAgIGxhc3RUaW1lLmN1cnJlbnQgPSBub3dcclxuICAgIH1cclxuXHJcbiAgICAvLyBGdW5jdGlvbiB0byByZWNvcmQgZmFsc2UgcG9zaXRpdmUgKGNhbGxlZCB3aGVuIHVzZXIgY2FuY2VscylcclxuICAgIGNvbnN0IHJlY29yZEZhbHNlUG9zaXRpdmUgPSAocmVhc29uOiBzdHJpbmcpID0+IHtcclxuICAgICAgZmFsc2VQb3NpdGl2ZUhpc3RvcnkuY3VycmVudC5wdXNoKHsgdGltZXN0YW1wOiBEYXRlLm5vdygpLCByZWFzb24gfSlcclxuICAgICAgdXNlckNhbmNlbENvdW50LmN1cnJlbnQrK1xyXG4gICAgICBcclxuICAgICAgLy8gQWRqdXN0IHRocmVzaG9sZHMgaWYgdG9vIG1hbnkgZmFsc2UgcG9zaXRpdmVzXHJcbiAgICAgIGlmICh1c2VyQ2FuY2VsQ291bnQuY3VycmVudCA+PSAzKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJBZGp1c3RpbmcgZGV0ZWN0aW9uIHNlbnNpdGl2aXR5IGR1ZSB0byBmYWxzZSBwb3NpdGl2ZXNcIilcclxuICAgICAgICAvLyBDb3VsZCBkeW5hbWljYWxseSBhZGp1c3QgdGhyZXNob2xkcyBoZXJlXHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBFeHBvc2UgcmVjb3JkRmFsc2VQb3NpdGl2ZSBmb3IgZXh0ZXJuYWwgdXNlXHJcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgICAod2luZG93IGFzIGFueSkucmVjb3JkQ3Jhc2hGYWxzZVBvc2l0aXZlID0gcmVjb3JkRmFsc2VQb3NpdGl2ZVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFJlcXVlc3QgcGVybWlzc2lvbiBmb3IgbW90aW9uIHNlbnNvcnMgKGlPUyAxMyspXHJcbiAgICBpZiAoXHJcbiAgICAgIHR5cGVvZiBEZXZpY2VNb3Rpb25FdmVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJlxyXG4gICAgICB0eXBlb2YgKERldmljZU1vdGlvbkV2ZW50IGFzIGFueSkucmVxdWVzdFBlcm1pc3Npb24gPT09IFwiZnVuY3Rpb25cIlxyXG4gICAgKSB7XHJcbiAgICAgIDsoRGV2aWNlTW90aW9uRXZlbnQgYXMgYW55KVxyXG4gICAgICAgIC5yZXF1ZXN0UGVybWlzc2lvbigpXHJcbiAgICAgICAgLnRoZW4oKHJlc3BvbnNlOiBzdHJpbmcpID0+IHtcclxuICAgICAgICAgIGlmIChyZXNwb25zZSA9PT0gXCJncmFudGVkXCIpIHtcclxuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJkZXZpY2Vtb3Rpb25cIiwgaGFuZGxlTW90aW9uKVxyXG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImRldmljZW9yaWVudGF0aW9uXCIsIGhhbmRsZU9yaWVudGF0aW9uKVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLmNhdGNoKChlcnJvcjogRXJyb3IpID0+IHtcclxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJNb3Rpb24gcGVybWlzc2lvbiBkZW5pZWQ6XCIsIGVycm9yKVxyXG4gICAgICAgIH0pXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBBbmRyb2lkIG9yIG9sZGVyIGlPU1xyXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImRldmljZW1vdGlvblwiLCBoYW5kbGVNb3Rpb24pXHJcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiZGV2aWNlb3JpZW50YXRpb25cIiwgaGFuZGxlT3JpZW50YXRpb24pXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJkZXZpY2Vtb3Rpb25cIiwgaGFuZGxlTW90aW9uKVxyXG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImRldmljZW9yaWVudGF0aW9uXCIsIGhhbmRsZU9yaWVudGF0aW9uKVxyXG4gICAgfVxyXG4gIH0sIFtpc0VuYWJsZWQsIHBvc2l0aW9uLCBvbkNyYXNoRGV0ZWN0ZWRdKVxyXG5cclxuICByZXR1cm4geyBjcmFzaERldGVjdGVkLCBzZXRDcmFzaERldGVjdGVkIH1cclxufVxyXG4iXSwibmFtZXMiOlsidXNlRWZmZWN0IiwidXNlUmVmIiwidXNlU3RhdGUiLCJ1c2VDcmFzaERldGVjdGlvbiIsImlzRW5hYmxlZCIsImN1cnJlbnRTcGVlZCIsInBvc2l0aW9uIiwib25DcmFzaERldGVjdGVkIiwiY3Jhc2hEZXRlY3RlZCIsInNldENyYXNoRGV0ZWN0ZWQiLCJsYXN0QWNjZWxlcmF0aW9uIiwieCIsInkiLCJ6IiwibGFzdFJvdGF0aW9uIiwiYWxwaGEiLCJiZXRhIiwiZ2FtbWEiLCJsYXN0VGltZSIsIkRhdGUiLCJub3ciLCJwcmV2aW91c1NwZWVkIiwiYmFzZWxpbmVPcmllbnRhdGlvbiIsImltcGFjdFNhbXBsZXMiLCJhdWRpb0NvbnRleHQiLCJhbmFseXNlciIsImxvdWRTb3VuZERldGVjdGVkIiwic3BlZWRIaXN0b3J5IiwibGFzdENyYXNoVGltZSIsImFjY2VsZXJhdGlvblBhdHRlcm4iLCJub3JtYWxEcml2aW5nQmFzZWxpbmUiLCJhdmdHIiwibWF4RyIsImZhbHNlUG9zaXRpdmVIaXN0b3J5IiwidXNlckNhbmNlbENvdW50IiwiY3VycmVudCIsInB1c2giLCJsZW5ndGgiLCJzaGlmdCIsImJhc2VsaW5lVGltZXIiLCJzZXRUaW1lb3V0IiwicmVkdWNlIiwic3VtIiwicCIsImciLCJNYXRoIiwic3FydCIsIm1heCIsIm1hcCIsImNvbnNvbGUiLCJsb2ciLCJzZXR1cEF1ZGlvRGV0ZWN0aW9uIiwic3RyZWFtIiwibmF2aWdhdG9yIiwibWVkaWFEZXZpY2VzIiwiZ2V0VXNlck1lZGlhIiwiYXVkaW8iLCJ3aW5kb3ciLCJBdWRpb0NvbnRleHQiLCJ3ZWJraXRBdWRpb0NvbnRleHQiLCJzb3VyY2UiLCJjcmVhdGVNZWRpYVN0cmVhbVNvdXJjZSIsImNyZWF0ZUFuYWx5c2VyIiwiZmZ0U2l6ZSIsImNvbm5lY3QiLCJjaGVja1NvdW5kIiwiZGF0YUFycmF5IiwiVWludDhBcnJheSIsImZyZXF1ZW5jeUJpbkNvdW50IiwiZ2V0Qnl0ZUZyZXF1ZW5jeURhdGEiLCJhdmVyYWdlIiwiYSIsImIiLCJzZXRJbnRlcnZhbCIsImVycm9yIiwiY2xlYXJUaW1lb3V0IiwiY2xvc2UiLCJyb3RhdGlvblJhdGUiLCJoYXNHeXJvc2NvcGUiLCJoYW5kbGVPcmllbnRhdGlvbiIsImV2ZW50IiwidGltZURpZmYiLCJhbHBoYUNoYW5nZSIsImFicyIsImJldGFDaGFuZ2UiLCJnYW1tYUNoYW5nZSIsIm5vcm1hbGl6ZWRBbHBoYUNoYW5nZSIsInRvRml4ZWQiLCJzcGVlZCIsImdGb3JjZSIsInRpbWVzdGFtcCIsImNyYXNoVHlwZSIsImhhbmRsZU1vdGlvbiIsImFjYyIsImFjY2VsZXJhdGlvbkluY2x1ZGluZ0dyYXZpdHkiLCJyb3RhdGlvbiIsImplcmtYIiwiamVya1kiLCJqZXJrWiIsInRvdGFsSmVyayIsInRvdGFsRyIsImd5cm9Sb3RhdGlvblJhdGUiLCJzcGVlZERyb3AiLCJoaWdoR1NhbXBsZXMiLCJmaWx0ZXIiLCJjb25zaXN0ZW50SW1wYWN0IiwiaXNVbnVzdWFsRm9yVXNlciIsInJlY2VudFBhdHRlcm4iLCJzbGljZSIsInBhdHRlcm5WYXJpYW5jZSIsImkiLCJwcmV2IiwiZGlmZiIsImhhc0VycmF0aWNQYXR0ZXJuIiwiaXNMaWtlbHlNb3VudGVkIiwicGhvbmVNb3VudGVkQm9udXMiLCJob3VyIiwiZ2V0SG91cnMiLCJpc05pZ2h0VGltZSIsIm5pZ2h0VGltZUFkanVzdG1lbnQiLCJyZWNlbnRGYWxzZVBvc2l0aXZlcyIsImZwIiwiZmFsc2VQb3NpdGl2ZVBlbmFsdHkiLCJncHNBY2N1cmFjeUJvbnVzIiwiYWNjdXJhY3kiLCJkb21pbmFudEF4aXMiLCJjb25maWRlbmNlIiwiY29uZmlkZW5jZUZhY3RvcnMiLCJtaW4iLCJpc0hpZ2hJbXBhY3QiLCJpc01lZGl1bUltcGFjdCIsImlzUm9sbG92ZXIiLCJpc0NvbmZpZGVudENyYXNoIiwidGltZVNpbmNlTGFzdENyYXNoIiwiY29vbGRvd25QZXJpb2QiLCJzb3VuZERldGVjdGVkIiwicGhvbmVNb3VudGVkIiwiZ3BzQWNjdXJhdGUiLCJyZWNvcmRGYWxzZVBvc2l0aXZlIiwicmVhc29uIiwicmVjb3JkQ3Jhc2hGYWxzZVBvc2l0aXZlIiwiRGV2aWNlTW90aW9uRXZlbnQiLCJyZXF1ZXN0UGVybWlzc2lvbiIsInRoZW4iLCJyZXNwb25zZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJjYXRjaCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./hooks/use-crash-detection.ts\n"));

/***/ })

});