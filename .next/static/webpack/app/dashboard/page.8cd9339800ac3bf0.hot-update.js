"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/dashboard/page",{

/***/ "(app-pages-browser)/./hooks/use-crash-detection.ts":
/*!**************************************!*\
  !*** ./hooks/use-crash-detection.ts ***!
  \**************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useCrashDetection: () => (/* binding */ useCrashDetection)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\nfunction useCrashDetection(isEnabled, currentSpeed, position, onCrashDetected) {\n    const [crashDetected, setCrashDetected] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const lastAcceleration = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        x: 0,\n        y: 0,\n        z: 0\n    });\n    const lastRotation = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        alpha: 0,\n        beta: 0,\n        gamma: 0\n    });\n    const lastTime = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(Date.now());\n    const previousSpeed = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const baselineOrientation = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        alpha: 0,\n        beta: 0,\n        gamma: 0\n    });\n    const impactSamples = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    const audioContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const analyser = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const loudSoundDetected = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const speedHistory = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    const lastCrashTime = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useCrashDetection.useEffect\": ()=>{\n            previousSpeed.current = currentSpeed;\n            // Track speed history for sudden drop detection\n            speedHistory.current.push(currentSpeed);\n            if (speedHistory.current.length > 10) {\n                speedHistory.current.shift(); // Keep last 10 readings (2 seconds)\n            }\n        }\n    }[\"useCrashDetection.useEffect\"], [\n        currentSpeed\n    ]);\n    // Sound detection setup\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useCrashDetection.useEffect\": ()=>{\n            if (!isEnabled || \"object\" === \"undefined\") return;\n            const setupAudioDetection = {\n                \"useCrashDetection.useEffect.setupAudioDetection\": async ()=>{\n                    try {\n                        const stream = await navigator.mediaDevices.getUserMedia({\n                            audio: true\n                        });\n                        audioContext.current = new (window.AudioContext || window.webkitAudioContext)();\n                        const source = audioContext.current.createMediaStreamSource(stream);\n                        analyser.current = audioContext.current.createAnalyser();\n                        analyser.current.fftSize = 2048;\n                        source.connect(analyser.current);\n                        // Monitor for loud sounds (crash/airbag)\n                        const checkSound = {\n                            \"useCrashDetection.useEffect.setupAudioDetection.checkSound\": ()=>{\n                                if (!analyser.current) return;\n                                const dataArray = new Uint8Array(analyser.current.frequencyBinCount);\n                                analyser.current.getByteFrequencyData(dataArray);\n                                // Calculate average volume\n                                const average = dataArray.reduce({\n                                    \"useCrashDetection.useEffect.setupAudioDetection.checkSound\": (a, b)=>a + b\n                                }[\"useCrashDetection.useEffect.setupAudioDetection.checkSound\"]) / dataArray.length;\n                                // Detect loud sudden sound (>150 threshold = crash/airbag)\n                                if (average > 150) {\n                                    console.log(\"LOUD SOUND DETECTED:\", average);\n                                    loudSoundDetected.current = true;\n                                    setTimeout({\n                                        \"useCrashDetection.useEffect.setupAudioDetection.checkSound\": ()=>{\n                                            loudSoundDetected.current = false;\n                                        }\n                                    }[\"useCrashDetection.useEffect.setupAudioDetection.checkSound\"], 2000); // Reset after 2 seconds\n                                }\n                            }\n                        }[\"useCrashDetection.useEffect.setupAudioDetection.checkSound\"];\n                        setInterval(checkSound, 100); // Check every 100ms\n                    } catch (error) {\n                        console.log(\"Audio detection not available:\", error);\n                    }\n                }\n            }[\"useCrashDetection.useEffect.setupAudioDetection\"];\n            setupAudioDetection();\n            return ({\n                \"useCrashDetection.useEffect\": ()=>{\n                    if (audioContext.current) {\n                        audioContext.current.close();\n                    }\n                }\n            })[\"useCrashDetection.useEffect\"];\n        }\n    }[\"useCrashDetection.useEffect\"], [\n        isEnabled\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useCrashDetection.useEffect\": ()=>{\n            if (!isEnabled || \"object\" === \"undefined\") return;\n            let rotationRate = 0;\n            let hasGyroscope = false;\n            // Handle gyroscope data for rollover detection\n            const handleOrientation = {\n                \"useCrashDetection.useEffect.handleOrientation\": (event)=>{\n                    if (event.alpha === null || event.beta === null || event.gamma === null) return;\n                    hasGyroscope = true;\n                    const now = Date.now();\n                    const timeDiff = (now - lastTime.current) / 1000;\n                    if (timeDiff < 0.1) return;\n                    // Calculate rotation rate (degrees per second)\n                    const alphaChange = Math.abs(event.alpha - lastRotation.current.alpha);\n                    const betaChange = Math.abs(event.beta - lastRotation.current.beta);\n                    const gammaChange = Math.abs(event.gamma - lastRotation.current.gamma);\n                    // Handle 360-degree wraparound for alpha\n                    const normalizedAlphaChange = alphaChange > 180 ? 360 - alphaChange : alphaChange;\n                    rotationRate = Math.sqrt(normalizedAlphaChange ** 2 + betaChange ** 2 + gammaChange ** 2) / timeDiff;\n                    // Detect rollover: extreme rotation (>90 degrees/sec) while moving\n                    if (rotationRate > 90 && previousSpeed.current > 15) {\n                        console.log(\"ROLLOVER DETECTED!\", {\n                            rotationRate: rotationRate.toFixed(2),\n                            speed: previousSpeed.current\n                        });\n                        setCrashDetected(true);\n                        onCrashDetected({\n                            gForce: 0,\n                            timestamp: now,\n                            position,\n                            speed: previousSpeed.current,\n                            crashType: \"rollover\",\n                            rotationRate\n                        });\n                    }\n                    lastRotation.current = {\n                        alpha: event.alpha,\n                        beta: event.beta,\n                        gamma: event.gamma\n                    };\n                }\n            }[\"useCrashDetection.useEffect.handleOrientation\"];\n            const handleMotion = {\n                \"useCrashDetection.useEffect.handleMotion\": (event)=>{\n                    const acc = event.accelerationIncludingGravity;\n                    const rotation = event.rotationRate;\n                    if (!acc || acc.x === null || acc.y === null || acc.z === null) return;\n                    const now = Date.now();\n                    const timeDiff = (now - lastTime.current) / 1000 // seconds\n                    ;\n                    if (timeDiff < 0.1) return; // Ignore too frequent updates\n                    // Calculate jerk (rate of change of acceleration)\n                    const jerkX = Math.abs(acc.x - lastAcceleration.current.x) / timeDiff;\n                    const jerkY = Math.abs(acc.y - lastAcceleration.current.y) / timeDiff;\n                    const jerkZ = Math.abs(acc.z - lastAcceleration.current.z) / timeDiff;\n                    const totalJerk = Math.sqrt(jerkX ** 2 + jerkY ** 2 + jerkZ ** 2);\n                    // Total acceleration magnitude in G's\n                    const totalG = Math.sqrt(acc.x ** 2 + acc.y ** 2 + acc.z ** 2) / 9.8;\n                    // Get gyroscope rotation rate if available\n                    let gyroRotationRate = 0;\n                    if (rotation && rotation.alpha !== null && rotation.beta !== null && rotation.gamma !== null) {\n                        gyroRotationRate = Math.sqrt(rotation.alpha ** 2 + rotation.beta ** 2 + rotation.gamma ** 2);\n                    }\n                    // Determine crash type based on acceleration direction\n                    let crashType = \"unknown\";\n                    const dominantAxis = Math.max(Math.abs(acc.x), Math.abs(acc.y), Math.abs(acc.z));\n                    if (Math.abs(acc.y) === dominantAxis) {\n                        crashType = acc.y > 0 ? \"frontal\" : \"rear\";\n                    } else if (Math.abs(acc.x) === dominantAxis) {\n                        crashType = \"side\";\n                    } else if (gyroRotationRate > 5 || rotationRate > 60) {\n                        crashType = \"rollover\";\n                    }\n                    // Enhanced crash detection criteria:\n                    // 1. High G-force (> 4g for definite crash, > 3g for possible)\n                    // 2. High jerk (sudden change > 40)\n                    // 3. Speed was > 20 km/h before impact (to avoid false positives from drops)\n                    // 4. Gyroscope rotation rate check for rollover\n                    const isHighImpact = totalG > 4 && totalJerk > 40 && previousSpeed.current > 20;\n                    const isMediumImpact = totalG > 3 && totalJerk > 30 && previousSpeed.current > 15;\n                    const isRollover = (gyroRotationRate > 5 || rotationRate > 60) && previousSpeed.current > 15;\n                    if (isHighImpact || isMediumImpact || isRollover) {\n                        console.log(\"CRASH DETECTED!\", {\n                            totalG: totalG.toFixed(2),\n                            totalJerk: totalJerk.toFixed(2),\n                            speed: previousSpeed.current,\n                            crashType,\n                            rotationRate: (gyroRotationRate || rotationRate).toFixed(2)\n                        });\n                        setCrashDetected(true);\n                        onCrashDetected({\n                            gForce: totalG,\n                            timestamp: now,\n                            position,\n                            speed: previousSpeed.current,\n                            crashType,\n                            rotationRate: gyroRotationRate || rotationRate\n                        });\n                    }\n                    lastAcceleration.current = {\n                        x: acc.x,\n                        y: acc.y,\n                        z: acc.z\n                    };\n                    lastTime.current = now;\n                }\n            }[\"useCrashDetection.useEffect.handleMotion\"];\n            // Request permission for motion sensors (iOS 13+)\n            if (typeof DeviceMotionEvent !== \"undefined\" && typeof DeviceMotionEvent.requestPermission === \"function\") {\n                ;\n                DeviceMotionEvent.requestPermission().then({\n                    \"useCrashDetection.useEffect\": (response)=>{\n                        if (response === \"granted\") {\n                            window.addEventListener(\"devicemotion\", handleMotion);\n                            window.addEventListener(\"deviceorientation\", handleOrientation);\n                        }\n                    }\n                }[\"useCrashDetection.useEffect\"]).catch({\n                    \"useCrashDetection.useEffect\": (error)=>{\n                        console.error(\"Motion permission denied:\", error);\n                    }\n                }[\"useCrashDetection.useEffect\"]);\n            } else {\n                // Android or older iOS\n                window.addEventListener(\"devicemotion\", handleMotion);\n                window.addEventListener(\"deviceorientation\", handleOrientation);\n            }\n            return ({\n                \"useCrashDetection.useEffect\": ()=>{\n                    window.removeEventListener(\"devicemotion\", handleMotion);\n                    window.removeEventListener(\"deviceorientation\", handleOrientation);\n                }\n            })[\"useCrashDetection.useEffect\"];\n        }\n    }[\"useCrashDetection.useEffect\"], [\n        isEnabled,\n        position,\n        onCrashDetected\n    ]);\n    return {\n        crashDetected,\n        setCrashDetected\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2hvb2tzL3VzZS1jcmFzaC1kZXRlY3Rpb24udHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQW1EO0FBYzVDLFNBQVNHLGtCQUNkQyxTQUFrQixFQUNsQkMsWUFBb0IsRUFDcEJDLFFBQTZDLEVBQzdDQyxlQUEwQztJQUUxQyxNQUFNLENBQUNDLGVBQWVDLGlCQUFpQixHQUFHUCwrQ0FBUUEsQ0FBQztJQUNuRCxNQUFNUSxtQkFBbUJULDZDQUFNQSxDQUFDO1FBQUVVLEdBQUc7UUFBR0MsR0FBRztRQUFHQyxHQUFHO0lBQUU7SUFDbkQsTUFBTUMsZUFBZWIsNkNBQU1BLENBQUM7UUFBRWMsT0FBTztRQUFHQyxNQUFNO1FBQUdDLE9BQU87SUFBRTtJQUMxRCxNQUFNQyxXQUFXakIsNkNBQU1BLENBQUNrQixLQUFLQyxHQUFHO0lBQ2hDLE1BQU1DLGdCQUFnQnBCLDZDQUFNQSxDQUFDO0lBQzdCLE1BQU1xQixzQkFBc0JyQiw2Q0FBTUEsQ0FBQztRQUFFYyxPQUFPO1FBQUdDLE1BQU07UUFBR0MsT0FBTztJQUFFO0lBQ2pFLE1BQU1NLGdCQUFnQnRCLDZDQUFNQSxDQUFXLEVBQUU7SUFDekMsTUFBTXVCLGVBQWV2Qiw2Q0FBTUEsQ0FBc0I7SUFDakQsTUFBTXdCLFdBQVd4Qiw2Q0FBTUEsQ0FBc0I7SUFDN0MsTUFBTXlCLG9CQUFvQnpCLDZDQUFNQSxDQUFDO0lBQ2pDLE1BQU0wQixlQUFlMUIsNkNBQU1BLENBQVcsRUFBRTtJQUN4QyxNQUFNMkIsZ0JBQWdCM0IsNkNBQU1BLENBQUM7SUFFN0JELGdEQUFTQTt1Q0FBQztZQUNScUIsY0FBY1EsT0FBTyxHQUFHeEI7WUFFeEIsZ0RBQWdEO1lBQ2hEc0IsYUFBYUUsT0FBTyxDQUFDQyxJQUFJLENBQUN6QjtZQUMxQixJQUFJc0IsYUFBYUUsT0FBTyxDQUFDRSxNQUFNLEdBQUcsSUFBSTtnQkFDcENKLGFBQWFFLE9BQU8sQ0FBQ0csS0FBSyxJQUFHLG9DQUFvQztZQUNuRTtRQUNGO3ND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Qm5COzRCQUN4Q3hDLE9BQU8yRCxnQkFBZ0IsQ0FBQyxxQkFBcUJsQzt3QkFDL0M7b0JBQ0Y7a0RBQ0NtQyxLQUFLO21EQUFDLENBQUN2Qzt3QkFDTkosUUFBUUksS0FBSyxDQUFDLDZCQUE2QkE7b0JBQzdDOztZQUNKLE9BQU87Z0JBQ0wsdUJBQXVCO2dCQUN2QnJCLE9BQU8yRCxnQkFBZ0IsQ0FBQyxnQkFBZ0JuQjtnQkFDeEN4QyxPQUFPMkQsZ0JBQWdCLENBQUMscUJBQXFCbEM7WUFDL0M7WUFFQTsrQ0FBTztvQkFDTHpCLE9BQU82RCxtQkFBbUIsQ0FBQyxnQkFBZ0JyQjtvQkFDM0N4QyxPQUFPNkQsbUJBQW1CLENBQUMscUJBQXFCcEM7Z0JBQ2xEOztRQUNGO3NDQUFHO1FBQUM1RDtRQUFXRTtRQUFVQztLQUFnQjtJQUV6QyxPQUFPO1FBQUVDO1FBQWVDO0lBQWlCO0FBQzNDIiwic291cmNlcyI6WyJEOlxcc21hcnRzYWZlXFxzbWFydC1hY2NpZGVudC1zYWZldHlcXGhvb2tzXFx1c2UtY3Jhc2gtZGV0ZWN0aW9uLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiXHJcblxyXG5pbnRlcmZhY2UgQ3Jhc2hEYXRhIHtcclxuICBnRm9yY2U6IG51bWJlclxyXG4gIHRpbWVzdGFtcDogbnVtYmVyXHJcbiAgcG9zaXRpb246IHsgbGF0OiBudW1iZXI7IGxuZzogbnVtYmVyIH0gfCBudWxsXHJcbiAgc3BlZWQ6IG51bWJlclxyXG4gIGNyYXNoVHlwZT86IFwiZnJvbnRhbFwiIHwgXCJzaWRlXCIgfCBcInJlYXJcIiB8IFwicm9sbG92ZXJcIiB8IFwidW5rbm93blwiXHJcbiAgcm90YXRpb25SYXRlPzogbnVtYmVyXHJcbiAgc3BlZWREcm9wPzogbnVtYmVyXHJcbiAgc291bmREZXRlY3RlZD86IGJvb2xlYW5cclxuICBjb25maWRlbmNlPzogbnVtYmVyXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VDcmFzaERldGVjdGlvbihcclxuICBpc0VuYWJsZWQ6IGJvb2xlYW4sXHJcbiAgY3VycmVudFNwZWVkOiBudW1iZXIsXHJcbiAgcG9zaXRpb246IHsgbGF0OiBudW1iZXI7IGxuZzogbnVtYmVyIH0gfCBudWxsLFxyXG4gIG9uQ3Jhc2hEZXRlY3RlZDogKGRhdGE6IENyYXNoRGF0YSkgPT4gdm9pZFxyXG4pIHtcclxuICBjb25zdCBbY3Jhc2hEZXRlY3RlZCwgc2V0Q3Jhc2hEZXRlY3RlZF0gPSB1c2VTdGF0ZShmYWxzZSlcclxuICBjb25zdCBsYXN0QWNjZWxlcmF0aW9uID0gdXNlUmVmKHsgeDogMCwgeTogMCwgejogMCB9KVxyXG4gIGNvbnN0IGxhc3RSb3RhdGlvbiA9IHVzZVJlZih7IGFscGhhOiAwLCBiZXRhOiAwLCBnYW1tYTogMCB9KVxyXG4gIGNvbnN0IGxhc3RUaW1lID0gdXNlUmVmKERhdGUubm93KCkpXHJcbiAgY29uc3QgcHJldmlvdXNTcGVlZCA9IHVzZVJlZigwKVxyXG4gIGNvbnN0IGJhc2VsaW5lT3JpZW50YXRpb24gPSB1c2VSZWYoeyBhbHBoYTogMCwgYmV0YTogMCwgZ2FtbWE6IDAgfSlcclxuICBjb25zdCBpbXBhY3RTYW1wbGVzID0gdXNlUmVmPG51bWJlcltdPihbXSlcclxuICBjb25zdCBhdWRpb0NvbnRleHQgPSB1c2VSZWY8QXVkaW9Db250ZXh0IHwgbnVsbD4obnVsbClcclxuICBjb25zdCBhbmFseXNlciA9IHVzZVJlZjxBbmFseXNlck5vZGUgfCBudWxsPihudWxsKVxyXG4gIGNvbnN0IGxvdWRTb3VuZERldGVjdGVkID0gdXNlUmVmKGZhbHNlKVxyXG4gIGNvbnN0IHNwZWVkSGlzdG9yeSA9IHVzZVJlZjxudW1iZXJbXT4oW10pXHJcbiAgY29uc3QgbGFzdENyYXNoVGltZSA9IHVzZVJlZigwKVxyXG5cclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgcHJldmlvdXNTcGVlZC5jdXJyZW50ID0gY3VycmVudFNwZWVkXHJcbiAgICBcclxuICAgIC8vIFRyYWNrIHNwZWVkIGhpc3RvcnkgZm9yIHN1ZGRlbiBkcm9wIGRldGVjdGlvblxyXG4gICAgc3BlZWRIaXN0b3J5LmN1cnJlbnQucHVzaChjdXJyZW50U3BlZWQpXHJcbiAgICBpZiAoc3BlZWRIaXN0b3J5LmN1cnJlbnQubGVuZ3RoID4gMTApIHtcclxuICAgICAgc3BlZWRIaXN0b3J5LmN1cnJlbnQuc2hpZnQoKSAvLyBLZWVwIGxhc3QgMTAgcmVhZGluZ3MgKDIgc2Vjb25kcylcclxuICAgIH1cclxuICB9LCBbY3VycmVudFNwZWVkXSlcclxuXHJcbiAgLy8gU291bmQgZGV0ZWN0aW9uIHNldHVwXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGlmICghaXNFbmFibGVkIHx8IHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHJldHVyblxyXG5cclxuICAgIGNvbnN0IHNldHVwQXVkaW9EZXRlY3Rpb24gPSBhc3luYyAoKSA9PiB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3Qgc3RyZWFtID0gYXdhaXQgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoeyBhdWRpbzogdHJ1ZSB9KVxyXG4gICAgICAgIGF1ZGlvQ29udGV4dC5jdXJyZW50ID0gbmV3ICh3aW5kb3cuQXVkaW9Db250ZXh0IHx8ICh3aW5kb3cgYXMgYW55KS53ZWJraXRBdWRpb0NvbnRleHQpKClcclxuICAgICAgICBjb25zdCBzb3VyY2UgPSBhdWRpb0NvbnRleHQuY3VycmVudC5jcmVhdGVNZWRpYVN0cmVhbVNvdXJjZShzdHJlYW0pXHJcbiAgICAgICAgYW5hbHlzZXIuY3VycmVudCA9IGF1ZGlvQ29udGV4dC5jdXJyZW50LmNyZWF0ZUFuYWx5c2VyKClcclxuICAgICAgICBhbmFseXNlci5jdXJyZW50LmZmdFNpemUgPSAyMDQ4XHJcbiAgICAgICAgc291cmNlLmNvbm5lY3QoYW5hbHlzZXIuY3VycmVudClcclxuXHJcbiAgICAgICAgLy8gTW9uaXRvciBmb3IgbG91ZCBzb3VuZHMgKGNyYXNoL2FpcmJhZylcclxuICAgICAgICBjb25zdCBjaGVja1NvdW5kID0gKCkgPT4ge1xyXG4gICAgICAgICAgaWYgKCFhbmFseXNlci5jdXJyZW50KSByZXR1cm5cclxuXHJcbiAgICAgICAgICBjb25zdCBkYXRhQXJyYXkgPSBuZXcgVWludDhBcnJheShhbmFseXNlci5jdXJyZW50LmZyZXF1ZW5jeUJpbkNvdW50KVxyXG4gICAgICAgICAgYW5hbHlzZXIuY3VycmVudC5nZXRCeXRlRnJlcXVlbmN5RGF0YShkYXRhQXJyYXkpXHJcblxyXG4gICAgICAgICAgLy8gQ2FsY3VsYXRlIGF2ZXJhZ2Ugdm9sdW1lXHJcbiAgICAgICAgICBjb25zdCBhdmVyYWdlID0gZGF0YUFycmF5LnJlZHVjZSgoYSwgYikgPT4gYSArIGIpIC8gZGF0YUFycmF5Lmxlbmd0aFxyXG5cclxuICAgICAgICAgIC8vIERldGVjdCBsb3VkIHN1ZGRlbiBzb3VuZCAoPjE1MCB0aHJlc2hvbGQgPSBjcmFzaC9haXJiYWcpXHJcbiAgICAgICAgICBpZiAoYXZlcmFnZSA+IDE1MCkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIkxPVUQgU09VTkQgREVURUNURUQ6XCIsIGF2ZXJhZ2UpXHJcbiAgICAgICAgICAgIGxvdWRTb3VuZERldGVjdGVkLmN1cnJlbnQgPSB0cnVlXHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgIGxvdWRTb3VuZERldGVjdGVkLmN1cnJlbnQgPSBmYWxzZVxyXG4gICAgICAgICAgICB9LCAyMDAwKSAvLyBSZXNldCBhZnRlciAyIHNlY29uZHNcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHNldEludGVydmFsKGNoZWNrU291bmQsIDEwMCkgLy8gQ2hlY2sgZXZlcnkgMTAwbXNcclxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhcIkF1ZGlvIGRldGVjdGlvbiBub3QgYXZhaWxhYmxlOlwiLCBlcnJvcilcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHNldHVwQXVkaW9EZXRlY3Rpb24oKVxyXG5cclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgIGlmIChhdWRpb0NvbnRleHQuY3VycmVudCkge1xyXG4gICAgICAgIGF1ZGlvQ29udGV4dC5jdXJyZW50LmNsb3NlKClcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0sIFtpc0VuYWJsZWRdKVxyXG5cclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgaWYgKCFpc0VuYWJsZWQgfHwgdHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuXHJcblxyXG4gICAgbGV0IHJvdGF0aW9uUmF0ZSA9IDBcclxuICAgIGxldCBoYXNHeXJvc2NvcGUgPSBmYWxzZVxyXG5cclxuICAgIC8vIEhhbmRsZSBneXJvc2NvcGUgZGF0YSBmb3Igcm9sbG92ZXIgZGV0ZWN0aW9uXHJcbiAgICBjb25zdCBoYW5kbGVPcmllbnRhdGlvbiA9IChldmVudDogRGV2aWNlT3JpZW50YXRpb25FdmVudCkgPT4ge1xyXG4gICAgICBpZiAoZXZlbnQuYWxwaGEgPT09IG51bGwgfHwgZXZlbnQuYmV0YSA9PT0gbnVsbCB8fCBldmVudC5nYW1tYSA9PT0gbnVsbCkgcmV0dXJuXHJcbiAgICAgIFxyXG4gICAgICBoYXNHeXJvc2NvcGUgPSB0cnVlXHJcbiAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KClcclxuICAgICAgY29uc3QgdGltZURpZmYgPSAobm93IC0gbGFzdFRpbWUuY3VycmVudCkgLyAxMDAwXHJcblxyXG4gICAgICBpZiAodGltZURpZmYgPCAwLjEpIHJldHVyblxyXG5cclxuICAgICAgLy8gQ2FsY3VsYXRlIHJvdGF0aW9uIHJhdGUgKGRlZ3JlZXMgcGVyIHNlY29uZClcclxuICAgICAgY29uc3QgYWxwaGFDaGFuZ2UgPSBNYXRoLmFicyhldmVudC5hbHBoYSAtIGxhc3RSb3RhdGlvbi5jdXJyZW50LmFscGhhKVxyXG4gICAgICBjb25zdCBiZXRhQ2hhbmdlID0gTWF0aC5hYnMoZXZlbnQuYmV0YSAtIGxhc3RSb3RhdGlvbi5jdXJyZW50LmJldGEpXHJcbiAgICAgIGNvbnN0IGdhbW1hQ2hhbmdlID0gTWF0aC5hYnMoZXZlbnQuZ2FtbWEgLSBsYXN0Um90YXRpb24uY3VycmVudC5nYW1tYSlcclxuXHJcbiAgICAgIC8vIEhhbmRsZSAzNjAtZGVncmVlIHdyYXBhcm91bmQgZm9yIGFscGhhXHJcbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWRBbHBoYUNoYW5nZSA9IGFscGhhQ2hhbmdlID4gMTgwID8gMzYwIC0gYWxwaGFDaGFuZ2UgOiBhbHBoYUNoYW5nZVxyXG5cclxuICAgICAgcm90YXRpb25SYXRlID0gTWF0aC5zcXJ0KFxyXG4gICAgICAgIG5vcm1hbGl6ZWRBbHBoYUNoYW5nZSAqKiAyICsgYmV0YUNoYW5nZSAqKiAyICsgZ2FtbWFDaGFuZ2UgKiogMlxyXG4gICAgICApIC8gdGltZURpZmZcclxuXHJcbiAgICAgIC8vIERldGVjdCByb2xsb3ZlcjogZXh0cmVtZSByb3RhdGlvbiAoPjkwIGRlZ3JlZXMvc2VjKSB3aGlsZSBtb3ZpbmdcclxuICAgICAgaWYgKHJvdGF0aW9uUmF0ZSA+IDkwICYmIHByZXZpb3VzU3BlZWQuY3VycmVudCA+IDE1KSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJST0xMT1ZFUiBERVRFQ1RFRCFcIiwge1xyXG4gICAgICAgICAgcm90YXRpb25SYXRlOiByb3RhdGlvblJhdGUudG9GaXhlZCgyKSxcclxuICAgICAgICAgIHNwZWVkOiBwcmV2aW91c1NwZWVkLmN1cnJlbnQsXHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAgICAgc2V0Q3Jhc2hEZXRlY3RlZCh0cnVlKVxyXG4gICAgICAgIG9uQ3Jhc2hEZXRlY3RlZCh7XHJcbiAgICAgICAgICBnRm9yY2U6IDAsXHJcbiAgICAgICAgICB0aW1lc3RhbXA6IG5vdyxcclxuICAgICAgICAgIHBvc2l0aW9uLFxyXG4gICAgICAgICAgc3BlZWQ6IHByZXZpb3VzU3BlZWQuY3VycmVudCxcclxuICAgICAgICAgIGNyYXNoVHlwZTogXCJyb2xsb3ZlclwiLFxyXG4gICAgICAgICAgcm90YXRpb25SYXRlLFxyXG4gICAgICAgIH0pXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGxhc3RSb3RhdGlvbi5jdXJyZW50ID0geyBhbHBoYTogZXZlbnQuYWxwaGEsIGJldGE6IGV2ZW50LmJldGEsIGdhbW1hOiBldmVudC5nYW1tYSB9XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgaGFuZGxlTW90aW9uID0gKGV2ZW50OiBEZXZpY2VNb3Rpb25FdmVudCkgPT4ge1xyXG4gICAgICBjb25zdCBhY2MgPSBldmVudC5hY2NlbGVyYXRpb25JbmNsdWRpbmdHcmF2aXR5XHJcbiAgICAgIGNvbnN0IHJvdGF0aW9uID0gZXZlbnQucm90YXRpb25SYXRlXHJcbiAgICAgIFxyXG4gICAgICBpZiAoIWFjYyB8fCBhY2MueCA9PT0gbnVsbCB8fCBhY2MueSA9PT0gbnVsbCB8fCBhY2MueiA9PT0gbnVsbCkgcmV0dXJuXHJcblxyXG4gICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpXHJcbiAgICAgIGNvbnN0IHRpbWVEaWZmID0gKG5vdyAtIGxhc3RUaW1lLmN1cnJlbnQpIC8gMTAwMCAvLyBzZWNvbmRzXHJcblxyXG4gICAgICBpZiAodGltZURpZmYgPCAwLjEpIHJldHVybiAvLyBJZ25vcmUgdG9vIGZyZXF1ZW50IHVwZGF0ZXNcclxuXHJcbiAgICAgIC8vIENhbGN1bGF0ZSBqZXJrIChyYXRlIG9mIGNoYW5nZSBvZiBhY2NlbGVyYXRpb24pXHJcbiAgICAgIGNvbnN0IGplcmtYID0gTWF0aC5hYnMoYWNjLnggLSBsYXN0QWNjZWxlcmF0aW9uLmN1cnJlbnQueCkgLyB0aW1lRGlmZlxyXG4gICAgICBjb25zdCBqZXJrWSA9IE1hdGguYWJzKGFjYy55IC0gbGFzdEFjY2VsZXJhdGlvbi5jdXJyZW50LnkpIC8gdGltZURpZmZcclxuICAgICAgY29uc3QgamVya1ogPSBNYXRoLmFicyhhY2MueiAtIGxhc3RBY2NlbGVyYXRpb24uY3VycmVudC56KSAvIHRpbWVEaWZmXHJcblxyXG4gICAgICBjb25zdCB0b3RhbEplcmsgPSBNYXRoLnNxcnQoamVya1ggKiogMiArIGplcmtZICoqIDIgKyBqZXJrWiAqKiAyKVxyXG5cclxuICAgICAgLy8gVG90YWwgYWNjZWxlcmF0aW9uIG1hZ25pdHVkZSBpbiBHJ3NcclxuICAgICAgY29uc3QgdG90YWxHID0gTWF0aC5zcXJ0KGFjYy54ICoqIDIgKyBhY2MueSAqKiAyICsgYWNjLnogKiogMikgLyA5LjhcclxuXHJcbiAgICAgIC8vIEdldCBneXJvc2NvcGUgcm90YXRpb24gcmF0ZSBpZiBhdmFpbGFibGVcclxuICAgICAgbGV0IGd5cm9Sb3RhdGlvblJhdGUgPSAwXHJcbiAgICAgIGlmIChyb3RhdGlvbiAmJiByb3RhdGlvbi5hbHBoYSAhPT0gbnVsbCAmJiByb3RhdGlvbi5iZXRhICE9PSBudWxsICYmIHJvdGF0aW9uLmdhbW1hICE9PSBudWxsKSB7XHJcbiAgICAgICAgZ3lyb1JvdGF0aW9uUmF0ZSA9IE1hdGguc3FydChcclxuICAgICAgICAgIHJvdGF0aW9uLmFscGhhICoqIDIgKyByb3RhdGlvbi5iZXRhICoqIDIgKyByb3RhdGlvbi5nYW1tYSAqKiAyXHJcbiAgICAgICAgKVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBEZXRlcm1pbmUgY3Jhc2ggdHlwZSBiYXNlZCBvbiBhY2NlbGVyYXRpb24gZGlyZWN0aW9uXHJcbiAgICAgIGxldCBjcmFzaFR5cGU6IFwiZnJvbnRhbFwiIHwgXCJzaWRlXCIgfCBcInJlYXJcIiB8IFwicm9sbG92ZXJcIiB8IFwidW5rbm93blwiID0gXCJ1bmtub3duXCJcclxuICAgICAgY29uc3QgZG9taW5hbnRBeGlzID0gTWF0aC5tYXgoTWF0aC5hYnMoYWNjLngpLCBNYXRoLmFicyhhY2MueSksIE1hdGguYWJzKGFjYy56KSlcclxuICAgICAgXHJcbiAgICAgIGlmIChNYXRoLmFicyhhY2MueSkgPT09IGRvbWluYW50QXhpcykge1xyXG4gICAgICAgIGNyYXNoVHlwZSA9IGFjYy55ID4gMCA/IFwiZnJvbnRhbFwiIDogXCJyZWFyXCJcclxuICAgICAgfSBlbHNlIGlmIChNYXRoLmFicyhhY2MueCkgPT09IGRvbWluYW50QXhpcykge1xyXG4gICAgICAgIGNyYXNoVHlwZSA9IFwic2lkZVwiXHJcbiAgICAgIH0gZWxzZSBpZiAoZ3lyb1JvdGF0aW9uUmF0ZSA+IDUgfHwgcm90YXRpb25SYXRlID4gNjApIHtcclxuICAgICAgICBjcmFzaFR5cGUgPSBcInJvbGxvdmVyXCJcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gRW5oYW5jZWQgY3Jhc2ggZGV0ZWN0aW9uIGNyaXRlcmlhOlxyXG4gICAgICAvLyAxLiBIaWdoIEctZm9yY2UgKD4gNGcgZm9yIGRlZmluaXRlIGNyYXNoLCA+IDNnIGZvciBwb3NzaWJsZSlcclxuICAgICAgLy8gMi4gSGlnaCBqZXJrIChzdWRkZW4gY2hhbmdlID4gNDApXHJcbiAgICAgIC8vIDMuIFNwZWVkIHdhcyA+IDIwIGttL2ggYmVmb3JlIGltcGFjdCAodG8gYXZvaWQgZmFsc2UgcG9zaXRpdmVzIGZyb20gZHJvcHMpXHJcbiAgICAgIC8vIDQuIEd5cm9zY29wZSByb3RhdGlvbiByYXRlIGNoZWNrIGZvciByb2xsb3ZlclxyXG5cclxuICAgICAgY29uc3QgaXNIaWdoSW1wYWN0ID0gdG90YWxHID4gNCAmJiB0b3RhbEplcmsgPiA0MCAmJiBwcmV2aW91c1NwZWVkLmN1cnJlbnQgPiAyMFxyXG4gICAgICBjb25zdCBpc01lZGl1bUltcGFjdCA9IHRvdGFsRyA+IDMgJiYgdG90YWxKZXJrID4gMzAgJiYgcHJldmlvdXNTcGVlZC5jdXJyZW50ID4gMTVcclxuICAgICAgY29uc3QgaXNSb2xsb3ZlciA9IChneXJvUm90YXRpb25SYXRlID4gNSB8fCByb3RhdGlvblJhdGUgPiA2MCkgJiYgcHJldmlvdXNTcGVlZC5jdXJyZW50ID4gMTVcclxuXHJcbiAgICAgIGlmIChpc0hpZ2hJbXBhY3QgfHwgaXNNZWRpdW1JbXBhY3QgfHwgaXNSb2xsb3Zlcikge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiQ1JBU0ggREVURUNURUQhXCIsIHtcclxuICAgICAgICAgIHRvdGFsRzogdG90YWxHLnRvRml4ZWQoMiksXHJcbiAgICAgICAgICB0b3RhbEplcms6IHRvdGFsSmVyay50b0ZpeGVkKDIpLFxyXG4gICAgICAgICAgc3BlZWQ6IHByZXZpb3VzU3BlZWQuY3VycmVudCxcclxuICAgICAgICAgIGNyYXNoVHlwZSxcclxuICAgICAgICAgIHJvdGF0aW9uUmF0ZTogKGd5cm9Sb3RhdGlvblJhdGUgfHwgcm90YXRpb25SYXRlKS50b0ZpeGVkKDIpLFxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgICAgIHNldENyYXNoRGV0ZWN0ZWQodHJ1ZSlcclxuICAgICAgICBvbkNyYXNoRGV0ZWN0ZWQoe1xyXG4gICAgICAgICAgZ0ZvcmNlOiB0b3RhbEcsXHJcbiAgICAgICAgICB0aW1lc3RhbXA6IG5vdyxcclxuICAgICAgICAgIHBvc2l0aW9uLFxyXG4gICAgICAgICAgc3BlZWQ6IHByZXZpb3VzU3BlZWQuY3VycmVudCxcclxuICAgICAgICAgIGNyYXNoVHlwZSxcclxuICAgICAgICAgIHJvdGF0aW9uUmF0ZTogZ3lyb1JvdGF0aW9uUmF0ZSB8fCByb3RhdGlvblJhdGUsXHJcbiAgICAgICAgfSlcclxuICAgICAgfVxyXG5cclxuICAgICAgbGFzdEFjY2VsZXJhdGlvbi5jdXJyZW50ID0geyB4OiBhY2MueCwgeTogYWNjLnksIHo6IGFjYy56IH1cclxuICAgICAgbGFzdFRpbWUuY3VycmVudCA9IG5vd1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFJlcXVlc3QgcGVybWlzc2lvbiBmb3IgbW90aW9uIHNlbnNvcnMgKGlPUyAxMyspXHJcbiAgICBpZiAoXHJcbiAgICAgIHR5cGVvZiBEZXZpY2VNb3Rpb25FdmVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJlxyXG4gICAgICB0eXBlb2YgKERldmljZU1vdGlvbkV2ZW50IGFzIGFueSkucmVxdWVzdFBlcm1pc3Npb24gPT09IFwiZnVuY3Rpb25cIlxyXG4gICAgKSB7XHJcbiAgICAgIDsoRGV2aWNlTW90aW9uRXZlbnQgYXMgYW55KVxyXG4gICAgICAgIC5yZXF1ZXN0UGVybWlzc2lvbigpXHJcbiAgICAgICAgLnRoZW4oKHJlc3BvbnNlOiBzdHJpbmcpID0+IHtcclxuICAgICAgICAgIGlmIChyZXNwb25zZSA9PT0gXCJncmFudGVkXCIpIHtcclxuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJkZXZpY2Vtb3Rpb25cIiwgaGFuZGxlTW90aW9uKVxyXG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImRldmljZW9yaWVudGF0aW9uXCIsIGhhbmRsZU9yaWVudGF0aW9uKVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLmNhdGNoKChlcnJvcjogRXJyb3IpID0+IHtcclxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJNb3Rpb24gcGVybWlzc2lvbiBkZW5pZWQ6XCIsIGVycm9yKVxyXG4gICAgICAgIH0pXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBBbmRyb2lkIG9yIG9sZGVyIGlPU1xyXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImRldmljZW1vdGlvblwiLCBoYW5kbGVNb3Rpb24pXHJcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiZGV2aWNlb3JpZW50YXRpb25cIiwgaGFuZGxlT3JpZW50YXRpb24pXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJkZXZpY2Vtb3Rpb25cIiwgaGFuZGxlTW90aW9uKVxyXG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImRldmljZW9yaWVudGF0aW9uXCIsIGhhbmRsZU9yaWVudGF0aW9uKVxyXG4gICAgfVxyXG4gIH0sIFtpc0VuYWJsZWQsIHBvc2l0aW9uLCBvbkNyYXNoRGV0ZWN0ZWRdKVxyXG5cclxuICByZXR1cm4geyBjcmFzaERldGVjdGVkLCBzZXRDcmFzaERldGVjdGVkIH1cclxufVxyXG4iXSwibmFtZXMiOlsidXNlRWZmZWN0IiwidXNlUmVmIiwidXNlU3RhdGUiLCJ1c2VDcmFzaERldGVjdGlvbiIsImlzRW5hYmxlZCIsImN1cnJlbnRTcGVlZCIsInBvc2l0aW9uIiwib25DcmFzaERldGVjdGVkIiwiY3Jhc2hEZXRlY3RlZCIsInNldENyYXNoRGV0ZWN0ZWQiLCJsYXN0QWNjZWxlcmF0aW9uIiwieCIsInkiLCJ6IiwibGFzdFJvdGF0aW9uIiwiYWxwaGEiLCJiZXRhIiwiZ2FtbWEiLCJsYXN0VGltZSIsIkRhdGUiLCJub3ciLCJwcmV2aW91c1NwZWVkIiwiYmFzZWxpbmVPcmllbnRhdGlvbiIsImltcGFjdFNhbXBsZXMiLCJhdWRpb0NvbnRleHQiLCJhbmFseXNlciIsImxvdWRTb3VuZERldGVjdGVkIiwic3BlZWRIaXN0b3J5IiwibGFzdENyYXNoVGltZSIsImN1cnJlbnQiLCJwdXNoIiwibGVuZ3RoIiwic2hpZnQiLCJzZXR1cEF1ZGlvRGV0ZWN0aW9uIiwic3RyZWFtIiwibmF2aWdhdG9yIiwibWVkaWFEZXZpY2VzIiwiZ2V0VXNlck1lZGlhIiwiYXVkaW8iLCJ3aW5kb3ciLCJBdWRpb0NvbnRleHQiLCJ3ZWJraXRBdWRpb0NvbnRleHQiLCJzb3VyY2UiLCJjcmVhdGVNZWRpYVN0cmVhbVNvdXJjZSIsImNyZWF0ZUFuYWx5c2VyIiwiZmZ0U2l6ZSIsImNvbm5lY3QiLCJjaGVja1NvdW5kIiwiZGF0YUFycmF5IiwiVWludDhBcnJheSIsImZyZXF1ZW5jeUJpbkNvdW50IiwiZ2V0Qnl0ZUZyZXF1ZW5jeURhdGEiLCJhdmVyYWdlIiwicmVkdWNlIiwiYSIsImIiLCJjb25zb2xlIiwibG9nIiwic2V0VGltZW91dCIsInNldEludGVydmFsIiwiZXJyb3IiLCJjbG9zZSIsInJvdGF0aW9uUmF0ZSIsImhhc0d5cm9zY29wZSIsImhhbmRsZU9yaWVudGF0aW9uIiwiZXZlbnQiLCJ0aW1lRGlmZiIsImFscGhhQ2hhbmdlIiwiTWF0aCIsImFicyIsImJldGFDaGFuZ2UiLCJnYW1tYUNoYW5nZSIsIm5vcm1hbGl6ZWRBbHBoYUNoYW5nZSIsInNxcnQiLCJ0b0ZpeGVkIiwic3BlZWQiLCJnRm9yY2UiLCJ0aW1lc3RhbXAiLCJjcmFzaFR5cGUiLCJoYW5kbGVNb3Rpb24iLCJhY2MiLCJhY2NlbGVyYXRpb25JbmNsdWRpbmdHcmF2aXR5Iiwicm90YXRpb24iLCJqZXJrWCIsImplcmtZIiwiamVya1oiLCJ0b3RhbEplcmsiLCJ0b3RhbEciLCJneXJvUm90YXRpb25SYXRlIiwiZG9taW5hbnRBeGlzIiwibWF4IiwiaXNIaWdoSW1wYWN0IiwiaXNNZWRpdW1JbXBhY3QiLCJpc1JvbGxvdmVyIiwiRGV2aWNlTW90aW9uRXZlbnQiLCJyZXF1ZXN0UGVybWlzc2lvbiIsInRoZW4iLCJyZXNwb25zZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJjYXRjaCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./hooks/use-crash-detection.ts\n"));

/***/ })

});