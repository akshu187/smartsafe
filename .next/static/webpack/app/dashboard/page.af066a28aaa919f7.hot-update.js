"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/dashboard/page",{

/***/ "(app-pages-browser)/./hooks/use-crash-detection.ts":
/*!**************************************!*\
  !*** ./hooks/use-crash-detection.ts ***!
  \**************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useCrashDetection: () => (/* binding */ useCrashDetection)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\nfunction useCrashDetection(isEnabled, currentSpeed, position, onCrashDetected) {\n    const [crashDetected, setCrashDetected] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const lastAcceleration = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        x: 0,\n        y: 0,\n        z: 0\n    });\n    const lastRotation = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        alpha: 0,\n        beta: 0,\n        gamma: 0\n    });\n    const lastTime = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(Date.now());\n    const previousSpeed = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const baselineOrientation = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        alpha: 0,\n        beta: 0,\n        gamma: 0\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useCrashDetection.useEffect\": ()=>{\n            previousSpeed.current = currentSpeed;\n        }\n    }[\"useCrashDetection.useEffect\"], [\n        currentSpeed\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useCrashDetection.useEffect\": ()=>{\n            if (!isEnabled || \"object\" === \"undefined\") return;\n            let rotationRate = 0;\n            let hasGyroscope = false;\n            // Handle gyroscope data for rollover detection\n            const handleOrientation = {\n                \"useCrashDetection.useEffect.handleOrientation\": (event)=>{\n                    if (event.alpha === null || event.beta === null || event.gamma === null) return;\n                    hasGyroscope = true;\n                    const now = Date.now();\n                    const timeDiff = (now - lastTime.current) / 1000;\n                    if (timeDiff < 0.1) return;\n                    // Calculate rotation rate (degrees per second)\n                    const alphaChange = Math.abs(event.alpha - lastRotation.current.alpha);\n                    const betaChange = Math.abs(event.beta - lastRotation.current.beta);\n                    const gammaChange = Math.abs(event.gamma - lastRotation.current.gamma);\n                    // Handle 360-degree wraparound for alpha\n                    const normalizedAlphaChange = alphaChange > 180 ? 360 - alphaChange : alphaChange;\n                    rotationRate = Math.sqrt(normalizedAlphaChange ** 2 + betaChange ** 2 + gammaChange ** 2) / timeDiff;\n                    // Detect rollover: extreme rotation (>90 degrees/sec) while moving\n                    if (rotationRate > 90 && previousSpeed.current > 15) {\n                        console.log(\"ROLLOVER DETECTED!\", {\n                            rotationRate: rotationRate.toFixed(2),\n                            speed: previousSpeed.current\n                        });\n                        setCrashDetected(true);\n                        onCrashDetected({\n                            gForce: 0,\n                            timestamp: now,\n                            position,\n                            speed: previousSpeed.current,\n                            crashType: \"rollover\",\n                            rotationRate\n                        });\n                    }\n                    lastRotation.current = {\n                        alpha: event.alpha,\n                        beta: event.beta,\n                        gamma: event.gamma\n                    };\n                }\n            }[\"useCrashDetection.useEffect.handleOrientation\"];\n            const handleMotion = {\n                \"useCrashDetection.useEffect.handleMotion\": (event)=>{\n                    const acc = event.accelerationIncludingGravity;\n                    const rotation = event.rotationRate;\n                    if (!acc || acc.x === null || acc.y === null || acc.z === null) return;\n                    const now = Date.now();\n                    const timeDiff = (now - lastTime.current) / 1000 // seconds\n                    ;\n                    if (timeDiff < 0.1) return; // Ignore too frequent updates\n                    // Calculate jerk (rate of change of acceleration)\n                    const jerkX = Math.abs(acc.x - lastAcceleration.current.x) / timeDiff;\n                    const jerkY = Math.abs(acc.y - lastAcceleration.current.y) / timeDiff;\n                    const jerkZ = Math.abs(acc.z - lastAcceleration.current.z) / timeDiff;\n                    const totalJerk = Math.sqrt(jerkX ** 2 + jerkY ** 2 + jerkZ ** 2);\n                    // Total acceleration magnitude in G's\n                    const totalG = Math.sqrt(acc.x ** 2 + acc.y ** 2 + acc.z ** 2) / 9.8;\n                    // Get gyroscope rotation rate if available\n                    let gyroRotationRate = 0;\n                    if (rotation && rotation.alpha !== null && rotation.beta !== null && rotation.gamma !== null) {\n                        gyroRotationRate = Math.sqrt(rotation.alpha ** 2 + rotation.beta ** 2 + rotation.gamma ** 2);\n                    }\n                    // Determine crash type based on acceleration direction\n                    let crashType = \"unknown\";\n                    const dominantAxis = Math.max(Math.abs(acc.x), Math.abs(acc.y), Math.abs(acc.z));\n                    if (Math.abs(acc.y) === dominantAxis) {\n                        crashType = acc.y > 0 ? \"frontal\" : \"rear\";\n                    } else if (Math.abs(acc.x) === dominantAxis) {\n                        crashType = \"side\";\n                    } else if (gyroRotationRate > 5 || rotationRate > 60) {\n                        crashType = \"rollover\";\n                    }\n                    // Enhanced crash detection criteria:\n                    // 1. High G-force (> 4g for definite crash, > 3g for possible)\n                    // 2. High jerk (sudden change > 40)\n                    // 3. Speed was > 20 km/h before impact (to avoid false positives from drops)\n                    // 4. Gyroscope rotation rate check for rollover\n                    const isHighImpact = totalG > 4 && totalJerk > 40 && previousSpeed.current > 20;\n                    const isMediumImpact = totalG > 3 && totalJerk > 30 && previousSpeed.current > 15;\n                    const isRollover = (gyroRotationRate > 5 || rotationRate > 60) && previousSpeed.current > 15;\n                    if (isHighImpact || isMediumImpact || isRollover) {\n                        console.log(\"CRASH DETECTED!\", {\n                            totalG: totalG.toFixed(2),\n                            totalJerk: totalJerk.toFixed(2),\n                            speed: previousSpeed.current,\n                            crashType,\n                            rotationRate: (gyroRotationRate || rotationRate).toFixed(2)\n                        });\n                        setCrashDetected(true);\n                        onCrashDetected({\n                            gForce: totalG,\n                            timestamp: now,\n                            position,\n                            speed: previousSpeed.current,\n                            crashType,\n                            rotationRate: gyroRotationRate || rotationRate\n                        });\n                    }\n                    lastAcceleration.current = {\n                        x: acc.x,\n                        y: acc.y,\n                        z: acc.z\n                    };\n                    lastTime.current = now;\n                }\n            }[\"useCrashDetection.useEffect.handleMotion\"];\n            // Request permission for motion sensors (iOS 13+)\n            if (typeof DeviceMotionEvent !== \"undefined\" && typeof DeviceMotionEvent.requestPermission === \"function\") {\n                ;\n                DeviceMotionEvent.requestPermission().then({\n                    \"useCrashDetection.useEffect\": (response)=>{\n                        if (response === \"granted\") {\n                            window.addEventListener(\"devicemotion\", handleMotion);\n                            window.addEventListener(\"deviceorientation\", handleOrientation);\n                        }\n                    }\n                }[\"useCrashDetection.useEffect\"]).catch({\n                    \"useCrashDetection.useEffect\": (error)=>{\n                        console.error(\"Motion permission denied:\", error);\n                    }\n                }[\"useCrashDetection.useEffect\"]);\n            } else {\n                // Android or older iOS\n                window.addEventListener(\"devicemotion\", handleMotion);\n                window.addEventListener(\"deviceorientation\", handleOrientation);\n            }\n            return ({\n                \"useCrashDetection.useEffect\": ()=>{\n                    window.removeEventListener(\"devicemotion\", handleMotion);\n                    window.removeEventListener(\"deviceorientation\", handleOrientation);\n                }\n            })[\"useCrashDetection.useEffect\"];\n        }\n    }[\"useCrashDetection.useEffect\"], [\n        isEnabled,\n        position,\n        onCrashDetected\n    ]);\n    return {\n        crashDetected,\n        setCrashDetected\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2hvb2tzL3VzZS1jcmFzaC1kZXRlY3Rpb24udHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQW1EO0FBVzVDLFNBQVNHLGtCQUNkQyxTQUFrQixFQUNsQkMsWUFBb0IsRUFDcEJDLFFBQTZDLEVBQzdDQyxlQUEwQztJQUUxQyxNQUFNLENBQUNDLGVBQWVDLGlCQUFpQixHQUFHUCwrQ0FBUUEsQ0FBQztJQUNuRCxNQUFNUSxtQkFBbUJULDZDQUFNQSxDQUFDO1FBQUVVLEdBQUc7UUFBR0MsR0FBRztRQUFHQyxHQUFHO0lBQUU7SUFDbkQsTUFBTUMsZUFBZWIsNkNBQU1BLENBQUM7UUFBRWMsT0FBTztRQUFHQyxNQUFNO1FBQUdDLE9BQU87SUFBRTtJQUMxRCxNQUFNQyxXQUFXakIsNkNBQU1BLENBQUNrQixLQUFLQyxHQUFHO0lBQ2hDLE1BQU1DLGdCQUFnQnBCLDZDQUFNQSxDQUFDO0lBQzdCLE1BQU1xQixzQkFBc0JyQiw2Q0FBTUEsQ0FBQztRQUFFYyxPQUFPO1FBQUdDLE1BQU07UUFBR0MsT0FBTztJQUFFO0lBRWpFakIsZ0RBQVNBO3VDQUFDO1lBQ1JxQixjQUFjRSxPQUFPLEdBQUdsQjtRQUMxQjtzQ0FBRztRQUFDQTtLQUFhO0lBRWpCTCxnREFBU0E7dUNBQUM7WUFDUixJQUFJLENBQUNJLGFBQWEsYUFBa0IsYUFBYTtZQUVqRCxJQUFJb0IsZUFBZTtZQUNuQixJQUFJQyxlQUFlO1lBRW5CLCtDQUErQztZQUMvQyxNQUFNQztpRUFBb0IsQ0FBQ0M7b0JBQ3pCLElBQUlBLE1BQU1aLEtBQUssS0FBSyxRQUFRWSxNQUFNWCxJQUFJLEtBQUssUUFBUVcsTUFBTVYsS0FBSyxLQUFLLE1BQU07b0JBRXpFUSxlQUFlO29CQUNmLE1BQU1MLE1BQU1ELEtBQUtDLEdBQUc7b0JBQ3BCLE1BQU1RLFdBQVcsQ0FBQ1IsTUFBTUYsU0FBU0ssT0FBTyxJQUFJO29CQUU1QyxJQUFJSyxXQUFXLEtBQUs7b0JBRXBCLCtDQUErQztvQkFDL0Ms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Tzs0QkFDNUJtQjs0QkFDQWxCLGNBQWM0QixvQkFBb0I1Qjt3QkFDcEM7b0JBQ0Y7b0JBRUFkLGlCQUFpQmEsT0FBTyxHQUFHO3dCQUFFWixHQUFHaUMsSUFBSWpDLENBQUM7d0JBQUVDLEdBQUdnQyxJQUFJaEMsQ0FBQzt3QkFBRUMsR0FBRytCLElBQUkvQixDQUFDO29CQUFDO29CQUMxREssU0FBU0ssT0FBTyxHQUFHSDtnQkFDckI7O1lBRUEsa0RBQWtEO1lBQ2xELElBQ0UsT0FBT3NDLHNCQUFzQixlQUM3QixPQUFPLGtCQUEyQkMsaUJBQWlCLEtBQUssWUFDeEQ7O2dCQUNFRCxrQkFDQ0MsaUJBQWlCLEdBQ2pCQyxJQUFJO21EQUFDLENBQUNDO3dCQUNMLElBQUlBLGFBQWEsV0FBVzs0QkFDMUJDLE9BQU9DLGdCQUFnQixDQUFDLGdCQUFnQnBCOzRCQUN4Q21CLE9BQU9DLGdCQUFnQixDQUFDLHFCQUFxQnJDO3dCQUMvQztvQkFDRjtrREFDQ3NDLEtBQUs7bURBQUMsQ0FBQ0M7d0JBQ043QixRQUFRNkIsS0FBSyxDQUFDLDZCQUE2QkE7b0JBQzdDOztZQUNKLE9BQU87Z0JBQ0wsdUJBQXVCO2dCQUN2QkgsT0FBT0MsZ0JBQWdCLENBQUMsZ0JBQWdCcEI7Z0JBQ3hDbUIsT0FBT0MsZ0JBQWdCLENBQUMscUJBQXFCckM7WUFDL0M7WUFFQTsrQ0FBTztvQkFDTG9DLE9BQU9JLG1CQUFtQixDQUFDLGdCQUFnQnZCO29CQUMzQ21CLE9BQU9JLG1CQUFtQixDQUFDLHFCQUFxQnhDO2dCQUNsRDs7UUFDRjtzQ0FBRztRQUFDdEI7UUFBV0U7UUFBVUM7S0FBZ0I7SUFFekMsT0FBTztRQUFFQztRQUFlQztJQUFpQjtBQUMzQyIsInNvdXJjZXMiOlsiRDpcXHNtYXJ0c2FmZVxcc21hcnQtYWNjaWRlbnQtc2FmZXR5XFxob29rc1xcdXNlLWNyYXNoLWRldGVjdGlvbi50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVJlZiwgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIlxyXG5cclxuaW50ZXJmYWNlIENyYXNoRGF0YSB7XHJcbiAgZ0ZvcmNlOiBudW1iZXJcclxuICB0aW1lc3RhbXA6IG51bWJlclxyXG4gIHBvc2l0aW9uOiB7IGxhdDogbnVtYmVyOyBsbmc6IG51bWJlciB9IHwgbnVsbFxyXG4gIHNwZWVkOiBudW1iZXJcclxuICBjcmFzaFR5cGU/OiBcImZyb250YWxcIiB8IFwic2lkZVwiIHwgXCJyZWFyXCIgfCBcInJvbGxvdmVyXCIgfCBcInVua25vd25cIlxyXG4gIHJvdGF0aW9uUmF0ZT86IG51bWJlclxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdXNlQ3Jhc2hEZXRlY3Rpb24oXHJcbiAgaXNFbmFibGVkOiBib29sZWFuLFxyXG4gIGN1cnJlbnRTcGVlZDogbnVtYmVyLFxyXG4gIHBvc2l0aW9uOiB7IGxhdDogbnVtYmVyOyBsbmc6IG51bWJlciB9IHwgbnVsbCxcclxuICBvbkNyYXNoRGV0ZWN0ZWQ6IChkYXRhOiBDcmFzaERhdGEpID0+IHZvaWRcclxuKSB7XHJcbiAgY29uc3QgW2NyYXNoRGV0ZWN0ZWQsIHNldENyYXNoRGV0ZWN0ZWRdID0gdXNlU3RhdGUoZmFsc2UpXHJcbiAgY29uc3QgbGFzdEFjY2VsZXJhdGlvbiA9IHVzZVJlZih7IHg6IDAsIHk6IDAsIHo6IDAgfSlcclxuICBjb25zdCBsYXN0Um90YXRpb24gPSB1c2VSZWYoeyBhbHBoYTogMCwgYmV0YTogMCwgZ2FtbWE6IDAgfSlcclxuICBjb25zdCBsYXN0VGltZSA9IHVzZVJlZihEYXRlLm5vdygpKVxyXG4gIGNvbnN0IHByZXZpb3VzU3BlZWQgPSB1c2VSZWYoMClcclxuICBjb25zdCBiYXNlbGluZU9yaWVudGF0aW9uID0gdXNlUmVmKHsgYWxwaGE6IDAsIGJldGE6IDAsIGdhbW1hOiAwIH0pXHJcblxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBwcmV2aW91c1NwZWVkLmN1cnJlbnQgPSBjdXJyZW50U3BlZWRcclxuICB9LCBbY3VycmVudFNwZWVkXSlcclxuXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGlmICghaXNFbmFibGVkIHx8IHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHJldHVyblxyXG5cclxuICAgIGxldCByb3RhdGlvblJhdGUgPSAwXHJcbiAgICBsZXQgaGFzR3lyb3Njb3BlID0gZmFsc2VcclxuXHJcbiAgICAvLyBIYW5kbGUgZ3lyb3Njb3BlIGRhdGEgZm9yIHJvbGxvdmVyIGRldGVjdGlvblxyXG4gICAgY29uc3QgaGFuZGxlT3JpZW50YXRpb24gPSAoZXZlbnQ6IERldmljZU9yaWVudGF0aW9uRXZlbnQpID0+IHtcclxuICAgICAgaWYgKGV2ZW50LmFscGhhID09PSBudWxsIHx8IGV2ZW50LmJldGEgPT09IG51bGwgfHwgZXZlbnQuZ2FtbWEgPT09IG51bGwpIHJldHVyblxyXG4gICAgICBcclxuICAgICAgaGFzR3lyb3Njb3BlID0gdHJ1ZVxyXG4gICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpXHJcbiAgICAgIGNvbnN0IHRpbWVEaWZmID0gKG5vdyAtIGxhc3RUaW1lLmN1cnJlbnQpIC8gMTAwMFxyXG5cclxuICAgICAgaWYgKHRpbWVEaWZmIDwgMC4xKSByZXR1cm5cclxuXHJcbiAgICAgIC8vIENhbGN1bGF0ZSByb3RhdGlvbiByYXRlIChkZWdyZWVzIHBlciBzZWNvbmQpXHJcbiAgICAgIGNvbnN0IGFscGhhQ2hhbmdlID0gTWF0aC5hYnMoZXZlbnQuYWxwaGEgLSBsYXN0Um90YXRpb24uY3VycmVudC5hbHBoYSlcclxuICAgICAgY29uc3QgYmV0YUNoYW5nZSA9IE1hdGguYWJzKGV2ZW50LmJldGEgLSBsYXN0Um90YXRpb24uY3VycmVudC5iZXRhKVxyXG4gICAgICBjb25zdCBnYW1tYUNoYW5nZSA9IE1hdGguYWJzKGV2ZW50LmdhbW1hIC0gbGFzdFJvdGF0aW9uLmN1cnJlbnQuZ2FtbWEpXHJcblxyXG4gICAgICAvLyBIYW5kbGUgMzYwLWRlZ3JlZSB3cmFwYXJvdW5kIGZvciBhbHBoYVxyXG4gICAgICBjb25zdCBub3JtYWxpemVkQWxwaGFDaGFuZ2UgPSBhbHBoYUNoYW5nZSA+IDE4MCA/IDM2MCAtIGFscGhhQ2hhbmdlIDogYWxwaGFDaGFuZ2VcclxuXHJcbiAgICAgIHJvdGF0aW9uUmF0ZSA9IE1hdGguc3FydChcclxuICAgICAgICBub3JtYWxpemVkQWxwaGFDaGFuZ2UgKiogMiArIGJldGFDaGFuZ2UgKiogMiArIGdhbW1hQ2hhbmdlICoqIDJcclxuICAgICAgKSAvIHRpbWVEaWZmXHJcblxyXG4gICAgICAvLyBEZXRlY3Qgcm9sbG92ZXI6IGV4dHJlbWUgcm90YXRpb24gKD45MCBkZWdyZWVzL3NlYykgd2hpbGUgbW92aW5nXHJcbiAgICAgIGlmIChyb3RhdGlvblJhdGUgPiA5MCAmJiBwcmV2aW91c1NwZWVkLmN1cnJlbnQgPiAxNSkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiUk9MTE9WRVIgREVURUNURUQhXCIsIHtcclxuICAgICAgICAgIHJvdGF0aW9uUmF0ZTogcm90YXRpb25SYXRlLnRvRml4ZWQoMiksXHJcbiAgICAgICAgICBzcGVlZDogcHJldmlvdXNTcGVlZC5jdXJyZW50LFxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgICAgIHNldENyYXNoRGV0ZWN0ZWQodHJ1ZSlcclxuICAgICAgICBvbkNyYXNoRGV0ZWN0ZWQoe1xyXG4gICAgICAgICAgZ0ZvcmNlOiAwLFxyXG4gICAgICAgICAgdGltZXN0YW1wOiBub3csXHJcbiAgICAgICAgICBwb3NpdGlvbixcclxuICAgICAgICAgIHNwZWVkOiBwcmV2aW91c1NwZWVkLmN1cnJlbnQsXHJcbiAgICAgICAgICBjcmFzaFR5cGU6IFwicm9sbG92ZXJcIixcclxuICAgICAgICAgIHJvdGF0aW9uUmF0ZSxcclxuICAgICAgICB9KVxyXG4gICAgICB9XHJcblxyXG4gICAgICBsYXN0Um90YXRpb24uY3VycmVudCA9IHsgYWxwaGE6IGV2ZW50LmFscGhhLCBiZXRhOiBldmVudC5iZXRhLCBnYW1tYTogZXZlbnQuZ2FtbWEgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGhhbmRsZU1vdGlvbiA9IChldmVudDogRGV2aWNlTW90aW9uRXZlbnQpID0+IHtcclxuICAgICAgY29uc3QgYWNjID0gZXZlbnQuYWNjZWxlcmF0aW9uSW5jbHVkaW5nR3Jhdml0eVxyXG4gICAgICBjb25zdCByb3RhdGlvbiA9IGV2ZW50LnJvdGF0aW9uUmF0ZVxyXG4gICAgICBcclxuICAgICAgaWYgKCFhY2MgfHwgYWNjLnggPT09IG51bGwgfHwgYWNjLnkgPT09IG51bGwgfHwgYWNjLnogPT09IG51bGwpIHJldHVyblxyXG5cclxuICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKVxyXG4gICAgICBjb25zdCB0aW1lRGlmZiA9IChub3cgLSBsYXN0VGltZS5jdXJyZW50KSAvIDEwMDAgLy8gc2Vjb25kc1xyXG5cclxuICAgICAgaWYgKHRpbWVEaWZmIDwgMC4xKSByZXR1cm4gLy8gSWdub3JlIHRvbyBmcmVxdWVudCB1cGRhdGVzXHJcblxyXG4gICAgICAvLyBDYWxjdWxhdGUgamVyayAocmF0ZSBvZiBjaGFuZ2Ugb2YgYWNjZWxlcmF0aW9uKVxyXG4gICAgICBjb25zdCBqZXJrWCA9IE1hdGguYWJzKGFjYy54IC0gbGFzdEFjY2VsZXJhdGlvbi5jdXJyZW50LngpIC8gdGltZURpZmZcclxuICAgICAgY29uc3QgamVya1kgPSBNYXRoLmFicyhhY2MueSAtIGxhc3RBY2NlbGVyYXRpb24uY3VycmVudC55KSAvIHRpbWVEaWZmXHJcbiAgICAgIGNvbnN0IGplcmtaID0gTWF0aC5hYnMoYWNjLnogLSBsYXN0QWNjZWxlcmF0aW9uLmN1cnJlbnQueikgLyB0aW1lRGlmZlxyXG5cclxuICAgICAgY29uc3QgdG90YWxKZXJrID0gTWF0aC5zcXJ0KGplcmtYICoqIDIgKyBqZXJrWSAqKiAyICsgamVya1ogKiogMilcclxuXHJcbiAgICAgIC8vIFRvdGFsIGFjY2VsZXJhdGlvbiBtYWduaXR1ZGUgaW4gRydzXHJcbiAgICAgIGNvbnN0IHRvdGFsRyA9IE1hdGguc3FydChhY2MueCAqKiAyICsgYWNjLnkgKiogMiArIGFjYy56ICoqIDIpIC8gOS44XHJcblxyXG4gICAgICAvLyBHZXQgZ3lyb3Njb3BlIHJvdGF0aW9uIHJhdGUgaWYgYXZhaWxhYmxlXHJcbiAgICAgIGxldCBneXJvUm90YXRpb25SYXRlID0gMFxyXG4gICAgICBpZiAocm90YXRpb24gJiYgcm90YXRpb24uYWxwaGEgIT09IG51bGwgJiYgcm90YXRpb24uYmV0YSAhPT0gbnVsbCAmJiByb3RhdGlvbi5nYW1tYSAhPT0gbnVsbCkge1xyXG4gICAgICAgIGd5cm9Sb3RhdGlvblJhdGUgPSBNYXRoLnNxcnQoXHJcbiAgICAgICAgICByb3RhdGlvbi5hbHBoYSAqKiAyICsgcm90YXRpb24uYmV0YSAqKiAyICsgcm90YXRpb24uZ2FtbWEgKiogMlxyXG4gICAgICAgIClcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gRGV0ZXJtaW5lIGNyYXNoIHR5cGUgYmFzZWQgb24gYWNjZWxlcmF0aW9uIGRpcmVjdGlvblxyXG4gICAgICBsZXQgY3Jhc2hUeXBlOiBcImZyb250YWxcIiB8IFwic2lkZVwiIHwgXCJyZWFyXCIgfCBcInJvbGxvdmVyXCIgfCBcInVua25vd25cIiA9IFwidW5rbm93blwiXHJcbiAgICAgIGNvbnN0IGRvbWluYW50QXhpcyA9IE1hdGgubWF4KE1hdGguYWJzKGFjYy54KSwgTWF0aC5hYnMoYWNjLnkpLCBNYXRoLmFicyhhY2MueikpXHJcbiAgICAgIFxyXG4gICAgICBpZiAoTWF0aC5hYnMoYWNjLnkpID09PSBkb21pbmFudEF4aXMpIHtcclxuICAgICAgICBjcmFzaFR5cGUgPSBhY2MueSA+IDAgPyBcImZyb250YWxcIiA6IFwicmVhclwiXHJcbiAgICAgIH0gZWxzZSBpZiAoTWF0aC5hYnMoYWNjLngpID09PSBkb21pbmFudEF4aXMpIHtcclxuICAgICAgICBjcmFzaFR5cGUgPSBcInNpZGVcIlxyXG4gICAgICB9IGVsc2UgaWYgKGd5cm9Sb3RhdGlvblJhdGUgPiA1IHx8IHJvdGF0aW9uUmF0ZSA+IDYwKSB7XHJcbiAgICAgICAgY3Jhc2hUeXBlID0gXCJyb2xsb3ZlclwiXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEVuaGFuY2VkIGNyYXNoIGRldGVjdGlvbiBjcml0ZXJpYTpcclxuICAgICAgLy8gMS4gSGlnaCBHLWZvcmNlICg+IDRnIGZvciBkZWZpbml0ZSBjcmFzaCwgPiAzZyBmb3IgcG9zc2libGUpXHJcbiAgICAgIC8vIDIuIEhpZ2ggamVyayAoc3VkZGVuIGNoYW5nZSA+IDQwKVxyXG4gICAgICAvLyAzLiBTcGVlZCB3YXMgPiAyMCBrbS9oIGJlZm9yZSBpbXBhY3QgKHRvIGF2b2lkIGZhbHNlIHBvc2l0aXZlcyBmcm9tIGRyb3BzKVxyXG4gICAgICAvLyA0LiBHeXJvc2NvcGUgcm90YXRpb24gcmF0ZSBjaGVjayBmb3Igcm9sbG92ZXJcclxuXHJcbiAgICAgIGNvbnN0IGlzSGlnaEltcGFjdCA9IHRvdGFsRyA+IDQgJiYgdG90YWxKZXJrID4gNDAgJiYgcHJldmlvdXNTcGVlZC5jdXJyZW50ID4gMjBcclxuICAgICAgY29uc3QgaXNNZWRpdW1JbXBhY3QgPSB0b3RhbEcgPiAzICYmIHRvdGFsSmVyayA+IDMwICYmIHByZXZpb3VzU3BlZWQuY3VycmVudCA+IDE1XHJcbiAgICAgIGNvbnN0IGlzUm9sbG92ZXIgPSAoZ3lyb1JvdGF0aW9uUmF0ZSA+IDUgfHwgcm90YXRpb25SYXRlID4gNjApICYmIHByZXZpb3VzU3BlZWQuY3VycmVudCA+IDE1XHJcblxyXG4gICAgICBpZiAoaXNIaWdoSW1wYWN0IHx8IGlzTWVkaXVtSW1wYWN0IHx8IGlzUm9sbG92ZXIpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhcIkNSQVNIIERFVEVDVEVEIVwiLCB7XHJcbiAgICAgICAgICB0b3RhbEc6IHRvdGFsRy50b0ZpeGVkKDIpLFxyXG4gICAgICAgICAgdG90YWxKZXJrOiB0b3RhbEplcmsudG9GaXhlZCgyKSxcclxuICAgICAgICAgIHNwZWVkOiBwcmV2aW91c1NwZWVkLmN1cnJlbnQsXHJcbiAgICAgICAgICBjcmFzaFR5cGUsXHJcbiAgICAgICAgICByb3RhdGlvblJhdGU6IChneXJvUm90YXRpb25SYXRlIHx8IHJvdGF0aW9uUmF0ZSkudG9GaXhlZCgyKSxcclxuICAgICAgICB9KVxyXG5cclxuICAgICAgICBzZXRDcmFzaERldGVjdGVkKHRydWUpXHJcbiAgICAgICAgb25DcmFzaERldGVjdGVkKHtcclxuICAgICAgICAgIGdGb3JjZTogdG90YWxHLFxyXG4gICAgICAgICAgdGltZXN0YW1wOiBub3csXHJcbiAgICAgICAgICBwb3NpdGlvbixcclxuICAgICAgICAgIHNwZWVkOiBwcmV2aW91c1NwZWVkLmN1cnJlbnQsXHJcbiAgICAgICAgICBjcmFzaFR5cGUsXHJcbiAgICAgICAgICByb3RhdGlvblJhdGU6IGd5cm9Sb3RhdGlvblJhdGUgfHwgcm90YXRpb25SYXRlLFxyXG4gICAgICAgIH0pXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGxhc3RBY2NlbGVyYXRpb24uY3VycmVudCA9IHsgeDogYWNjLngsIHk6IGFjYy55LCB6OiBhY2MueiB9XHJcbiAgICAgIGxhc3RUaW1lLmN1cnJlbnQgPSBub3dcclxuICAgIH1cclxuXHJcbiAgICAvLyBSZXF1ZXN0IHBlcm1pc3Npb24gZm9yIG1vdGlvbiBzZW5zb3JzIChpT1MgMTMrKVxyXG4gICAgaWYgKFxyXG4gICAgICB0eXBlb2YgRGV2aWNlTW90aW9uRXZlbnQgIT09IFwidW5kZWZpbmVkXCIgJiZcclxuICAgICAgdHlwZW9mIChEZXZpY2VNb3Rpb25FdmVudCBhcyBhbnkpLnJlcXVlc3RQZXJtaXNzaW9uID09PSBcImZ1bmN0aW9uXCJcclxuICAgICkge1xyXG4gICAgICA7KERldmljZU1vdGlvbkV2ZW50IGFzIGFueSlcclxuICAgICAgICAucmVxdWVzdFBlcm1pc3Npb24oKVxyXG4gICAgICAgIC50aGVuKChyZXNwb25zZTogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgICBpZiAocmVzcG9uc2UgPT09IFwiZ3JhbnRlZFwiKSB7XHJcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiZGV2aWNlbW90aW9uXCIsIGhhbmRsZU1vdGlvbilcclxuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJkZXZpY2VvcmllbnRhdGlvblwiLCBoYW5kbGVPcmllbnRhdGlvbilcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgICAgIC5jYXRjaCgoZXJyb3I6IEVycm9yKSA9PiB7XHJcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiTW90aW9uIHBlcm1pc3Npb24gZGVuaWVkOlwiLCBlcnJvcilcclxuICAgICAgICB9KVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gQW5kcm9pZCBvciBvbGRlciBpT1NcclxuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJkZXZpY2Vtb3Rpb25cIiwgaGFuZGxlTW90aW9uKVxyXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImRldmljZW9yaWVudGF0aW9uXCIsIGhhbmRsZU9yaWVudGF0aW9uKVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiZGV2aWNlbW90aW9uXCIsIGhhbmRsZU1vdGlvbilcclxuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJkZXZpY2VvcmllbnRhdGlvblwiLCBoYW5kbGVPcmllbnRhdGlvbilcclxuICAgIH1cclxuICB9LCBbaXNFbmFibGVkLCBwb3NpdGlvbiwgb25DcmFzaERldGVjdGVkXSlcclxuXHJcbiAgcmV0dXJuIHsgY3Jhc2hEZXRlY3RlZCwgc2V0Q3Jhc2hEZXRlY3RlZCB9XHJcbn1cclxuIl0sIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZVJlZiIsInVzZVN0YXRlIiwidXNlQ3Jhc2hEZXRlY3Rpb24iLCJpc0VuYWJsZWQiLCJjdXJyZW50U3BlZWQiLCJwb3NpdGlvbiIsIm9uQ3Jhc2hEZXRlY3RlZCIsImNyYXNoRGV0ZWN0ZWQiLCJzZXRDcmFzaERldGVjdGVkIiwibGFzdEFjY2VsZXJhdGlvbiIsIngiLCJ5IiwieiIsImxhc3RSb3RhdGlvbiIsImFscGhhIiwiYmV0YSIsImdhbW1hIiwibGFzdFRpbWUiLCJEYXRlIiwibm93IiwicHJldmlvdXNTcGVlZCIsImJhc2VsaW5lT3JpZW50YXRpb24iLCJjdXJyZW50Iiwicm90YXRpb25SYXRlIiwiaGFzR3lyb3Njb3BlIiwiaGFuZGxlT3JpZW50YXRpb24iLCJldmVudCIsInRpbWVEaWZmIiwiYWxwaGFDaGFuZ2UiLCJNYXRoIiwiYWJzIiwiYmV0YUNoYW5nZSIsImdhbW1hQ2hhbmdlIiwibm9ybWFsaXplZEFscGhhQ2hhbmdlIiwic3FydCIsImNvbnNvbGUiLCJsb2ciLCJ0b0ZpeGVkIiwic3BlZWQiLCJnRm9yY2UiLCJ0aW1lc3RhbXAiLCJjcmFzaFR5cGUiLCJoYW5kbGVNb3Rpb24iLCJhY2MiLCJhY2NlbGVyYXRpb25JbmNsdWRpbmdHcmF2aXR5Iiwicm90YXRpb24iLCJqZXJrWCIsImplcmtZIiwiamVya1oiLCJ0b3RhbEplcmsiLCJ0b3RhbEciLCJneXJvUm90YXRpb25SYXRlIiwiZG9taW5hbnRBeGlzIiwibWF4IiwiaXNIaWdoSW1wYWN0IiwiaXNNZWRpdW1JbXBhY3QiLCJpc1JvbGxvdmVyIiwiRGV2aWNlTW90aW9uRXZlbnQiLCJyZXF1ZXN0UGVybWlzc2lvbiIsInRoZW4iLCJyZXNwb25zZSIsIndpbmRvdyIsImFkZEV2ZW50TGlzdGVuZXIiLCJjYXRjaCIsImVycm9yIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./hooks/use-crash-detection.ts\n"));

/***/ })

});